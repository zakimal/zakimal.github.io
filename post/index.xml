<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | zak</title>
    <link>/post/</link>
      <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>ja-JP</language><copyright>© zak 2019</copyright><lastBuildDate>Tue, 29 Oct 2019 19:50:58 +0900</lastBuildDate>
    <image>
      <url>/img/icon-1080.png</url>
      <title>Posts</title>
      <link>/post/</link>
    </image>
    
    <item>
      <title>GitHub上でのmerge</title>
      <link>/post/three-kinds-of-merge-on-github/</link>
      <pubDate>Tue, 29 Oct 2019 19:50:58 +0900</pubDate>
      <guid>/post/three-kinds-of-merge-on-github/</guid>
      <description>

&lt;h2 id=&#34;github上でのmerge&#34;&gt;GitHub上でのmerge&lt;/h2&gt;

&lt;p&gt;GitHub上で行えるmergeには3種類あります．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a merge commit&lt;/li&gt;
&lt;li&gt;Squash and merge&lt;/li&gt;
&lt;li&gt;Rebase and merge&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらは，「merge commitの有無」「merge commitのauthorが誰になるのか」などの点で微妙に異なります．&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;merge commitの有無&lt;/th&gt;
&lt;th&gt;merge commitのauthor&lt;/th&gt;
&lt;th&gt;merge元のbranchのcommit log&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Create a merge commit&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;merge先&lt;/td&gt;
&lt;td&gt;残る&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Squash and merge&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;merge元&lt;/td&gt;
&lt;td&gt;残らない&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Rebase and merge&lt;/td&gt;
&lt;td&gt;無&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;残る&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;create-a-merge-commit&#34;&gt;Create a merge commit&lt;/h3&gt;

&lt;p&gt;「Create a merge commit」では，&lt;code&gt;git merge --no-ff&lt;/code&gt;でmergeすることになります．つまり，merge先に新たなcommitが作成され，そのcommitがmerge元のcommitを取り込みます．このとき作成されるmerge commitのauthorはmerge先のauthorとして記録されます．&lt;/p&gt;

&lt;p&gt;この方法は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「何をmergeしたのか」がmerge commitという形で記録として残る&lt;/li&gt;
&lt;li&gt;merge元のbranchがそのまま残るので変更箇所を追いやすい&lt;/li&gt;
&lt;li&gt;merge後に，merge元のbranchを削除したとしても，このbranchのcommit logがmerge先に残る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という特徴があります．わかりやすい一方で，「merge commitのauthorがmerge元ではない」のが（個人的に）「その人の頑張りを讃えたいのになぁ」とか思っちゃったりしてちょっと申し訳ない気がするとかしないとか．&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;create-merge-commit.gif&#34; data-caption=&#34;Create a merge commit&#34;&gt;
&lt;img src=&#34;create-merge-commit.gif&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Create a merge commit
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;h3 id=&#34;squash-and-merge&#34;&gt;Squash and merge&lt;/h3&gt;

&lt;p&gt;「Squash and merge」では，&lt;code&gt;git merge --squash&lt;/code&gt;でmergeすることになります．つまり，merge元のcommitを一つのcommitにまとめた上で，merge先にmerge commitとして先頭に追加されます．このときのmerge commitのauthorはmerge元のauthorとなります．&lt;/p&gt;

&lt;p&gt;この方法は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「何をmergeしたのか」がmerge commitという形で記録として残る&lt;/li&gt;
&lt;li&gt;複数のcommitをまとめて一つにできるのでmerge先のcommit logがわかりやすい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という特徴があります．一方で，一度commitをまとめてしまうと，「どの変更が誰によってどのcommitで行われたのか」という情報が失われてしまうことになります．他の人の複数のcommitを一つのcommitに押し込むことになるので，個人的には若干怖さがあります．&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;squash-and-merge.gif&#34; data-caption=&#34;Squash and merge&#34;&gt;
&lt;img src=&#34;squash-and-merge.gif&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Squash and merge
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;h3 id=&#34;rebase-and-merge&#34;&gt;Rebase and merge&lt;/h3&gt;

&lt;p&gt;「Rebase and merge」では，まずmerge元のブランチにあるcommit列に対して&lt;code&gt;git rebase&lt;/code&gt;して，commit列が一列になったところでfast-forwardの形でmergeが実行されます．&lt;/p&gt;

&lt;p&gt;この方法は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mergeした結果，merge先のcommit logが一直線で見やすい&lt;/li&gt;
&lt;li&gt;merge commitが作成されない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という特徴があります．&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;rebase-and-merge.gif&#34; data-caption=&#34;Rebase and merge&#34;&gt;
&lt;img src=&#34;rebase-and-merge.gif&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Rebase and merge
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://help.github.com/en/github/administering-a-repository/about-merge-methods-on-github&#34; target=&#34;_blank&#34;&gt;About merge methods on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>暗号の基礎技術</title>
      <link>/post/basic-cryptographic-technologies/</link>
      <pubDate>Mon, 28 Oct 2019 12:40:48 +0900</pubDate>
      <guid>/post/basic-cryptographic-technologies/</guid>
      <description>

&lt;h2 id=&#34;暗号の基礎技術&#34;&gt;暗号の基礎技術&lt;/h2&gt;

&lt;p&gt;暗号技術の中でも基礎となるもの．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;暗号&lt;/li&gt;
&lt;li&gt;鍵配送&lt;/li&gt;
&lt;li&gt;ハッシュ関数&lt;/li&gt;
&lt;li&gt;メッセージ認証コード&lt;/li&gt;
&lt;li&gt;デジタル署名&lt;/li&gt;
&lt;li&gt;擬似乱数生成器&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;暗号&#34;&gt;暗号&lt;/h3&gt;

&lt;p&gt;暗号とは，「正当な送信者と受信者以外に内容を秘匿する技術」のこと．送信者は平文に対して，なんらかの操作を施すことで，暗号文を生成する．この過程を暗号化という．一方で，受信者は暗号文に対してなんらかの操作を施すことで平文を得る．この過程を復号という．&lt;/p&gt;

&lt;h3 id=&#34;鍵配送&#34;&gt;鍵配送&lt;/h3&gt;

&lt;p&gt;鍵配送とは，暗号化や復号に用いる鍵を安全に配送・共有するための技術や方式のこと．鍵は「第三者に知られないように」配送する必要があります．&lt;/p&gt;

&lt;h3 id=&#34;ハッシュ関数&#34;&gt;ハッシュ関数&lt;/h3&gt;

&lt;p&gt;ハッシュ関数とは，任意長のビット列を入力として固定長のビット列を出力する関数のこと．同一の入力に対して同一の出力をする一方で，異なる入力に対して異なる出力となり，異なる入力に対して同一の出力にならないという性質が求められる．&lt;/p&gt;

&lt;h3 id=&#34;メッセージ認証コード&#34;&gt;メッセージ認証コード&lt;/h3&gt;

&lt;p&gt;メッセージ認証コードとは，「伝送路上を通ってきたデータが改ざんされていないこと」「データが期待した通信相手から送信されていること」を検証するための技術のこと．&lt;/p&gt;

&lt;h3 id=&#34;デジタル署名&#34;&gt;デジタル署名&lt;/h3&gt;

&lt;p&gt;デジタル署名とは，契約書における物理的なサインのデジタル版で，ユーザー認証とデータ認証を同時に実現する技術のこと．メッセージの改ざんを防ぎ，メッセージに対する署名は署名した本人でしか生成できないことから，後から署名者が署名した契約について否認することを防止することができる．&lt;/p&gt;

&lt;h3 id=&#34;擬似乱数生成器&#34;&gt;擬似乱数生成器&lt;/h3&gt;

&lt;p&gt;真の乱数ではないにしても，暗号論的に安全とみなせる乱数列を生成するための技術のこと．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>情報セキュリティの構成要素</title>
      <link>/post/six-elements-of-infomation-security/</link>
      <pubDate>Mon, 28 Oct 2019 11:54:27 +0900</pubDate>
      <guid>/post/six-elements-of-infomation-security/</guid>
      <description>

&lt;h2 id=&#34;情報セキュリティの構成要素&#34;&gt;情報セキュリティの構成要素&lt;/h2&gt;

&lt;p&gt;「情報セキュリティ」の言葉の指し示す意味範囲は&lt;a href=&#34;oecd.org/internet/ieconomy/15582260.pdf&#34; target=&#34;_blank&#34;&gt;OECDの情報セキュリティガイドライン&lt;/a&gt;やISO/IEC TR13335&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;として国際的に定義されている．&lt;/p&gt;

&lt;p&gt;ISO/IEC TR13335にて情報セキュリティとは下記6要素のことを指すとされている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;機密性 Confidentiality&lt;/li&gt;
&lt;li&gt;完全性 Integrity&lt;/li&gt;
&lt;li&gt;可用性 Availability&lt;/li&gt;
&lt;li&gt;責任追跡性 Accountability&lt;/li&gt;
&lt;li&gt;真正性 Authenticity&lt;/li&gt;
&lt;li&gt;信頼性 Reliability&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;機密性-confidentiality&#34;&gt;機密性 Confidentiality&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;意味

&lt;ul&gt;
&lt;li&gt;意図した相手以外に情報が漏れないこと&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;リスク

&lt;ul&gt;
&lt;li&gt;盗聴や内部からの情報漏洩&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;対策

&lt;ul&gt;
&lt;li&gt;暗号技術&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;完全性-integrity&#34;&gt;完全性 Integrity&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;意味

&lt;ul&gt;
&lt;li&gt;情報が正確であること&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;リスク

&lt;ul&gt;
&lt;li&gt;情報の改ざん，ノイズによるビット反転・ビットの欠落&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;対策

&lt;ul&gt;
&lt;li&gt;誤り訂正符号，ハッシュ関数，メッセージ認証コード，デジタル署名&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;可用性-availability&#34;&gt;可用性 Availability&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;意味

&lt;ul&gt;
&lt;li&gt;ある情報にアクセスすることが許されている主体が，任意の時点で情報にアクセスすることができること&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;リスク

&lt;ul&gt;
&lt;li&gt;システムへの過負荷，災害，意図しないロック&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;対策

&lt;ul&gt;
&lt;li&gt;システムの多重化，クラウド化，負荷分散&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;責任追跡性-accountability&#34;&gt;責任追跡性 Accountability&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;意味

&lt;ul&gt;
&lt;li&gt;ユーザやシステムの振る舞いについて説明が可能であること&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;リスク

&lt;ul&gt;
&lt;li&gt;ログの改ざん，否認&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;対策

&lt;ul&gt;
&lt;li&gt;ロギング，デジタル署名（否認防止）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;真正性-authenticity&#34;&gt;真正性 Authenticity&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;意味

&lt;ul&gt;
&lt;li&gt;観測されるユーザやシステムの振る舞いが，その主体によるものであること（なりすましではない）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;リスク

&lt;ul&gt;
&lt;li&gt;なりすまし&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;対策

&lt;ul&gt;
&lt;li&gt;認証，デジタル署名（なりすまし防止）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;信頼性-reliability&#34;&gt;信頼性 Reliability&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;意味

&lt;ul&gt;
&lt;li&gt;システムが一貫して動作すること&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;リスク

&lt;ul&gt;
&lt;li&gt;盗聴や内部からの情報漏洩&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;対策

&lt;ul&gt;
&lt;li&gt;システムの多重化，負荷の監視&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;正確には企業のセキュリティリスクを査定する際のガイドラインを定めたものになっている．通称GMITS（Guidelines for the Management for IT Security）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>FramworkとLibraryの違い</title>
      <link>/post/what-is-the-difference-between-library-and-framework/</link>
      <pubDate>Fri, 25 Oct 2019 22:45:15 +0900</pubDate>
      <guid>/post/what-is-the-difference-between-library-and-framework/</guid>
      <description>

&lt;h2 id=&#34;ありがちな会話&#34;&gt;ありがちな会話&lt;/h2&gt;

&lt;p&gt;「Web Application Frameworkと言ったら，やっぱりRuby on Railsだよね！」&lt;/p&gt;

&lt;p&gt;「Webのフロント開発ではjQueryってライブラリがあってだな&amp;hellip;」&lt;/p&gt;

&lt;p&gt;「最近だと，FacebookがJavascriptのフレームワークとしてReactを発表してるよね」&lt;/p&gt;

&lt;p&gt;「ReactよりAngular JSの方がいいよ」&lt;/p&gt;

&lt;p&gt;Web系の技術の話では，たくさんのFrameworkだのLibraryだのが提案されて使用されていると思います．僕なんかも初めて聞くものがあれば，すぐにググってその正体を知ろうとするのですが，どれもこれも「これは便利なWeb Frameworkです」ぐらいしか教えてくれません．Frameworkの正体って一体何なのでしょうか．気になったので調べてみました．&lt;/p&gt;

&lt;h2 id=&#34;library-v-s-framework&#34;&gt;Library v.s. Framework&lt;/h2&gt;

&lt;h3 id=&#34;library&#34;&gt;Library&lt;/h3&gt;

&lt;p&gt;Libraryは，コードの再利用を目的とした「便利な関数やクラスの（ただの）コレクション」のようなものです．Libraryに含まれる関数やクラスは，ある特定の処理を達成するロジックを含んでいて，開発者がそれらを利用することで開発を進めていくことになります．例えばグラフアルゴリズムのライブラリなら，Dijkstra法とかBellman-Ford法を実装した関数が含まれていて，開発者がその関数を利用することでアプリケーションを開発します．アプリケーションの開発者が書いているロジックにライブラリの関数が利用されるので，アプリケーションの制御は開発者側にあります．&lt;/p&gt;

&lt;p&gt;Libraryを用いることで，他の人の仕事の恩恵に与りながら開発を進めることができます．これはとても嬉しいことです．開発の速度が上がります．&lt;/p&gt;

&lt;p&gt;要するに「&lt;strong&gt;Libraryのコードを開発者が利用する&lt;/strong&gt;」のがLibraryです．&lt;/p&gt;

&lt;h3 id=&#34;framework&#34;&gt;Framework&lt;/h3&gt;

&lt;p&gt;Frameworkは， (初期化から実際の処理，終了といった) アプリケーションの制御は &lt;em&gt;全てFramework側にあります&lt;/em&gt; ．アプリケーションを開発者は，Frameworkが要求するロジックを部品としてFrameworkに提供することになるわけです．Frameworkはアプリケーションの骨格を定義しているともいるかもしれません．外枠だけ定義しているのです．このFrameworkの持つ性質は，ソフトウェア工学的には「制御の反転 IoC (Inversion of Control)」と呼ばれています．&lt;/p&gt;

&lt;p&gt;Frameworkを用いることで，アプリケーション開発者は設計についてあれやこれや悩む必要がなくなります．Frameworkの要求に従っていれば，それなりの品質のシステムが勝手に出来上がることになるからです．また，Frameworkに則ってアプリケーションを開発していくと，コードに一貫性が生まれます．これはコードに可読性を与え，メンテナンスがしやすくなります．&lt;/p&gt;

&lt;p&gt;一方で，Frameworkは「制約の集合」でもあります．アプリケーションの全体としての制御が開発者の自由にできないわけですから，Frameworkを導入するならばFrameworkの課すルールを理解する必要があります．ルールを理解するのには時間がかかるものですし，Frameworkのルールに窮屈さを感じることもあるかもしれません．小規模なその場限りの開発現場などでは，この制約がFrameworkのメリットを上回ることがあるので，Frameworkを導入しないこともあるでしょう．&lt;/p&gt;

&lt;p&gt;要するに「&lt;strong&gt;Frameworkが開発者のコードを利用する&lt;/strong&gt;」のがFrameworkです．&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;library-framework-relationship.jpeg&#34; data-caption=&#34;LibraryとFrameworkとあなた&#34;&gt;
&lt;img src=&#34;library-framework-relationship.jpeg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    LibraryとFrameworkとあなた
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.nikkeibp.co.jp/it/article/lecture/20070205/260697/&#34; target=&#34;_blank&#34;&gt;ソフトウエアのフレームワークとはなにか (日経XTECH)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/azuki8/items/ad7710fdefaedc63e3f7&#34; target=&#34;_blank&#34;&gt;フレームワークとライブラリの違い (Qiita)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/&#34; target=&#34;_blank&#34;&gt;The Difference Between a Framework and a Library (freeCodeCamp)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library&#34; target=&#34;_blank&#34;&gt;What is the difference between a framework and a library? (stackoverflow)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>🚩flagパッケージでコマンドライン引数を扱う</title>
      <link>/post/handle-commandline-args-with-flag-package/</link>
      <pubDate>Fri, 25 Oct 2019 19:04:31 +0900</pubDate>
      <guid>/post/handle-commandline-args-with-flag-package/</guid>
      <description>

&lt;h2 id=&#34;flag-パッケージ&#34;&gt;&lt;code&gt;flag&lt;/code&gt;パッケージ&lt;/h2&gt;

&lt;p&gt;Golangでは，標準パッケージとしてコマンドライン引数を扱う&lt;a href=&#34;https://golang.org/pkg/flag/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt;パッケージが付属しています．「痒い所に手が届く」とはこのことですね．&lt;/p&gt;

&lt;h2 id=&#34;フラグの立っていないコマンドライン引数の取得&#34;&gt;フラグの立っていないコマンドライン引数の取得&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Parse()&lt;/code&gt;の後に&lt;code&gt;Args()&lt;/code&gt;で&lt;code&gt;[]string&lt;/code&gt;として取得できます．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;pakcage main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	flag.Parse()
	args := flag.Args()
	fmt.Println(args)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go run with-no-flag0.go a b c
[a b c]
$ go run with-no-flag0.go 1 2 3
[1 2 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$n$番目の要素のみを取り出したい場合は&lt;code&gt;Arg(n)&lt;/code&gt;で&lt;code&gt;string&lt;/code&gt;として取得できます．$n$番目の要素が存在しない場合は&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;が返ってくるようです．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	flag.Parse()
	fmt.Println(flag.Arg(0), flag.Arg(1))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go run with-no-flag1.go hoge fuga
hoge fuga
$ go run with-no-flag1.go 1
1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;フラグの立っているコマンドライン引数の取得&#34;&gt;フラグの立っているコマンドライン引数の取得&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;型名()&lt;/code&gt;もしくは&lt;code&gt;型名Var()&lt;/code&gt;で，フラグを定義したのち，&lt;code&gt;Parse()&lt;/code&gt;でそれぞれの変数を取得できます．&lt;/p&gt;

&lt;p&gt;フラグの定義は「フラグ名」「デフォルト値」「ヘルプメッセージ」で行います．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;型名()&lt;/code&gt;の場合は，指定した型へのポインタが返ってきます．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	var (
		i = flag.Int(&amp;quot;int&amp;quot;, 0, &amp;quot;int flag&amp;quot;)
		s = flag.String(&amp;quot;str&amp;quot;, &amp;quot;default&amp;quot;, &amp;quot;string flag&amp;quot;)
		b = flag.Bool(&amp;quot;bool&amp;quot;, false, &amp;quot;bool flag&amp;quot;)
	)
	flag.Parse()
	fmt.Println(*i, *s, *b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go run with-flag0.go -int 2 -str hello -bool true
2 hello true
$ go run with-flag0.go
0 default false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;型名Var()&lt;/code&gt;の場合は，引数で渡した変数に代入されます．また，適切な値を渡さないと怒られます．ダメな理由も教えてくれるので怒られがいがあります．定義していないフラグも受け付けてくれません．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	var (
		d time.Duration
		f float64
	)
	flag.DurationVar(&amp;amp;d, &amp;quot;dur&amp;quot;, 1 * time.Second, &amp;quot;duration flag&amp;quot;)
	flag.Float64Var(&amp;amp;f, &amp;quot;float&amp;quot;, 0.1, &amp;quot;float flag&amp;quot;)
	flag.Parse()
	fmt.Println(d, f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go run with-flag1.go -dur 1h -float 2.3
1h0m0s 2.3
$ go run with-flag1.go -float str
invalid value &amp;quot;str&amp;quot; for flag -float: strconv.ParseFloat: parsing &amp;quot;str&amp;quot;: invalid syntax
Usage of /var/folders/.../with-flag1:
  -dur duration
    	duration flag (default 1s)
  -float float
    	float flag (default 0.1)
exit status 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;フラグの書き方&#34;&gt;フラグの書き方&lt;/h2&gt;

&lt;p&gt;フラグの書き方は次の2通りが可能です．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-flag value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-flag=value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ただし，Bool値を取得する場合は&lt;code&gt;flag=value&lt;/code&gt;を使った方がいいかもしれません．というのも， &lt;strong&gt;フラグの型がBool値かつ引数が続かない場合，フラグが立っただけで&lt;code&gt;true&lt;/code&gt;となる&lt;/strong&gt;からです．&lt;/p&gt;

&lt;p&gt;つまり，フラグを立ててBool値を取得したい場合は&lt;code&gt;-bool=true&lt;/code&gt;/&lt;code&gt;-bool=false&lt;/code&gt;としなければならないということです．&lt;code&gt;-bool false&lt;/code&gt;では&lt;code&gt;true&lt;/code&gt;となってしまいます．また&lt;code&gt;-bool false&lt;/code&gt;以降の引数が全てフラグ無しで渡された引数として評価されてしまいます．注意が必要ですね．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	var (
		i = flag.Int(&amp;quot;int&amp;quot;, 0, &amp;quot;int flag&amp;quot;)
		s = flag.String(&amp;quot;str&amp;quot;, &amp;quot;default&amp;quot;, &amp;quot;string flag&amp;quot;)
		b = flag.Bool(&amp;quot;bool&amp;quot;, false, &amp;quot;bool flag&amp;quot;)
	)
	flag.Parse()
	fmt.Println(*i, *s, *b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go run with-flag0.go -bool false -int 123 -str abc # falseを含むそれ以降が全て非フラグで渡されたコマンドライン引数として扱われる
0 default true 
$ go run with-flag0.go -bool=true -int 123 -str abc
123 abc true
$ go run with-flag0.go -bool=false -int 123 -str abc
123 abc false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに&lt;code&gt;-h&lt;/code&gt;でヘルプを表示してくれます．賢いですね．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go run with-flag0.go -h
Usage of /var/folders/.../with-flag0:
  -bool
    	bool flag
  -int int
    	int flag
  -str string
    	string flag (default &amp;quot;default&amp;quot;)
exit status 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コマンドライン引数の個数を数える&#34;&gt;コマンドライン引数の個数を数える&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;NArg()&lt;/code&gt;で非フラグなものを，&lt;code&gt;NFlag()&lt;/code&gt;でフラグなものをカウントできます．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	flag.Int(&amp;quot;int&amp;quot;, 0, &amp;quot;int flag&amp;quot;)
	flag.String(&amp;quot;str&amp;quot;, &amp;quot;default&amp;quot;, &amp;quot;string flag&amp;quot;)
	flag.Bool(&amp;quot;bool&amp;quot;, false, &amp;quot;bool flag&amp;quot;)
	flag.Parse()
	fmt.Println(&amp;quot;non flag:&amp;quot;, flag.NArg())
	fmt.Println(&amp;quot;flag:&amp;quot;, flag.NFlag())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go run flag-test.go -int 1 -str foo -bool=true a b
non flag: 2
flag: 3
$ go run flag-test.go -int 1 -str foo -bool true a b
non flag: 3
flag: 3
$ go run flag-test.go -bool true -int 1 -str foo a b
non flag: 7
flag: 1
$ go run flag-test.go a b c -bool=true -str foo
non flag: 6
flag: 0
$ go run flag-test.go -bool=true -str foo a b c
non flag: 3
flag: 2
$ go run flag-test.go a b c
non flag: 3
flag: 0
$ go run flag-test.go -bool=true -str foo
non flag: 0
flag: 2
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HugoとGitHub Pagesでブログを作ってみた！</title>
      <link>/post/about-this-site/</link>
      <pubDate>Fri, 25 Oct 2019 17:21:38 +0900</pubDate>
      <guid>/post/about-this-site/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;最近はもっぱら卒論の実装ばかりやっています，zakです．&lt;/p&gt;

&lt;p&gt;プログラム書くのって難しいですよね．僕にとってはとても難しいので，わからないことがあったらデキる人のブログを参考にさせていただいたりしています．
そんな中で，自分もコードを書くことが増えてきて，そこで得た知識をなんらかの形で発信できないかなと思って，このブログを思いつきで始めました．&lt;/p&gt;

&lt;h2 id=&#34;採用技術&#34;&gt;採用技術&lt;/h2&gt;

&lt;p&gt;このブログはサイトジェネレータとしてHugo，ホスティングサービスとしてGitHub Pagesを採用しています．&lt;/p&gt;

&lt;p&gt;HugoはGolangで記述されたオープンソースの静的サイトジェネレーターです．設定をtomlで書いて，記事をMarkdownで書いて，それをHugoがHTMLその他ファイルに爆速でしたためてくれます．真面目にウェブサイトを作ろうとすると，「書きにくいHTMLで文章を書いて，CSSで見栄えを整えて」という感じで作っていくことになります．HTMLってあんまり洗練されていなくて人間にとっては読みずらいですよね．一方でMarkdownは文法が簡単なので，箇条書きでメモってるぐらいの感覚で構造を持った文章が書けてしまいます．Hugoを使うことで，サイト作成者はMarkdownというわかりやすい文法で記事を書くことができ，本来の仕事に専念できるわけです．&lt;/p&gt;

&lt;p&gt;Hugoのいいところはそれだけではありません．Hugoはその便利さから，多くのユーザーから愛されていて，そのユーザーらがそれぞれ美しいデザインテーマを公開してくれています．どれもセンスが良く，機能面でも充実しています．このテーマはオープンソースで公開されているので，カスタマイズも簡単です．そこらへんのブログサービスを利用すると，テーマがどれも陳腐で不満ですよね．&lt;/p&gt;

&lt;p&gt;今回はMarkdownで記事が執筆できるところとHugoで用いることができるAcademicというテーマが気に入ったので，Hugoを使うことにしました．&lt;/p&gt;

&lt;p&gt;GitHub Pagesは，GitHubが提供している静的サイトのホスティングサービスです．GitHubのアカウントさえあれば，誰でも静的なサイトを公開することができます．何より無料なので，これを使わない手はありません．サイトのソースコードをGitHubで管理しつつ公開もできちゃうなんて，GitHubは太っ腹ですね．&lt;/p&gt;

&lt;p&gt;GitHub Pagesの他にもホスティングサービスはありますが，ソースコード管理と一緒にホスティングできるところが便利だと思ったので採用しました．&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;気が向いたら，もうちょっと追記します 🙇&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>🚀最初の投稿</title>
      <link>/post/first-post/</link>
      <pubDate>Fri, 25 Oct 2019 17:07:09 +0900</pubDate>
      <guid>/post/first-post/</guid>
      <description>

&lt;h1 id=&#34;ご挨拶&#34;&gt;ご挨拶&lt;/h1&gt;

&lt;p&gt;はじめまして．技術ブログ始めてみました．ぼちぼち投稿します 👍&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
