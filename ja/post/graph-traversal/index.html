<!DOCTYPE html>
<html lang="ja-JP">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.5.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="尾崎 耀一 (@zak)">

  
  
  
    
  
  <meta name="description" content="グラフを探索したい 計算機を「与えられた対象の中から，目的に合致するものを見つけ出したり，最良のものを見つけ出す」という「探索」目的で用いる場">

  
  <link rel="alternate" hreflang="ja-JP" href="/ja/post/graph-traversal/">

  


  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/atom-one-dark.min.css" crossorigin="anonymous" title="hl-light">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/atom-one-dark.min.css" crossorigin="anonymous" title="hl-dark" disabled>
      
    

    

    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.css">

  




  


  

  <link rel="manifest" href="/ja/index.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon-32.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/ja/post/graph-traversal/">

  
  
  
  
    
  
  
  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@zak74702675">
  <meta property="twitter:creator" content="@zak74702675">
  
  <meta property="og:site_name" content="zak">
  <meta property="og:url" content="/ja/post/graph-traversal/">
  <meta property="og:title" content="グラフ探索 | zak">
  <meta property="og:description" content="グラフを探索したい 計算機を「与えられた対象の中から，目的に合致するものを見つけ出したり，最良のものを見つけ出す」という「探索」目的で用いる場"><meta property="og:image" content="/ja/post/graph-traversal/featured.png">
  <meta property="twitter:image" content="/ja/post/graph-traversal/featured.png"><meta property="og:locale" content="ja-JP">
  
    
      <meta property="article:published_time" content="2020-04-07T10:27:03&#43;09:00">
    
    <meta property="article:modified_time" content="2020-04-07T10:27:03&#43;09:00">
  

  


    






  






<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/ja/post/graph-traversal/"
  },
  "headline": "グラフ探索",
  
  "image": [
    "/ja/post/graph-traversal/featured.png"
  ],
  
  "datePublished": "2020-04-07T10:27:03+09:00",
  "dateModified": "2020-04-07T10:27:03+09:00",
  
  "author": {
    "@type": "Person",
    "name": "尾崎 耀一 (@zak)"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "zak",
    "logo": {
      "@type": "ImageObject",
      "url": "/img/zak.gif"
    }
  },
  "description": "グラフを探索したい 計算機を「与えられた対象の中から，目的に合致するものを見つけ出したり，最良のものを見つけ出す」という「探索」目的で用いる場"
}
</script>

  

  


  


  





  <title>グラフ探索 | zak</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="検索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/ja"><img src="/img/zak.gif" alt="zak"></a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="ナビゲーションの切り替え">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/ja/#about"><span>ホーム</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/ja/#posts"><span>ブログ</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/ja/post/book-shelf"><span>本棚</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/ja/#contact"><span>お問い合わせ</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/ja/files/cv.pdf"><span>履歴書</span></a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        

      </ul>

    </div>
  </div>
</nav>


  <article class="article">

  




















  
  
    
  


<div class="article-container pt-3">
  <h1>グラフ探索</h1>

  

  


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    Tue, Apr 7, 2020
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    27 分で読める
  </span>
  

  
  
  

  
  

</div>

  














</div>


<div class="article-header article-container featured-image-wrapper mt-4 mb-4" style="max-width: 720px; max-height: 405px;">
  <div style="position: relative">
    <img src="/ja/post/graph-traversal/featured_hu03fce8ea4a9ee6f6aba1696f8b83d1be_40672_720x0_resize_lanczos_2.png" alt="" class="featured-image">
    
  </div>
</div>



  <div class="article-container">

    <div class="article-style">
      <h2 id="グラフを探索したい">グラフを探索したい</h2>
<p>計算機を「与えられた対象の中から，目的に合致するものを見つけ出したり，最良のものを見つけ出す」という「探索」目的で用いる場面は多くある．世の中にはびこっている問題たちは，考えられるすべての場合をくまなく調べつ尽くすことによって原理的に解決することができる．</p>
<p>問題を「グラフ」としてモデル化・定式化することで高速な探索アルゴリズムを考えることができることが多い．例えば，首都圏の電車の乗換案内アプリケーションはほとんどそのままグラフ上の最短経路探索問題として定式化できるし，他にもオセロや将棋などのボードゲームも，ユーザの操作によって盤上の状態を頂点とするグラフ上を移動しているとすればグラフ上の探索問題とみなせる．</p>
<h2 id="グラフ">グラフ</h2>
<p>グラフとは，<strong>対象物を構成する事物の集合とその集合を構成する対象物間の関係にのみ注目したデータ構造</strong>のことで，卑近な例で言えば，人間関係はグラフとして表現することができる．</p>
<p><strong>グラフ$G$</strong>はそれを構成する頂点の有限集合$V = \{v_1, v_2, &hellip;, v_n\}$と頂点間に生える辺の有限集合$E = \{e_1, e_2, &hellip;, e_m\}$の組として定義される．</p>
<p>$$
G = (V, E)
$$</p>
<p>頂点$v_i$と$v_j$が辺$e$によって接続されているとき，頂点$v_i$と$v_j$は互いに<strong>隣接</strong>しているといい，$v_i$，$v_j$は$e$の<strong>端点</strong>であるという．</p>
<p>グラフ$G$の各辺$e = (v_i, v_j)$について，$(v_i, v_j)$と$(v_j, v_i)$を区別しないとき，$G$を<strong>無向グラフ</strong>と呼び，逆に区別するとき<strong>有向グラフ</strong>と呼ぶ．</p>













<figure>


  <a data-fancybox="" href="graph1.png" data-caption="無向グラフ">
<img src="graph1.png" alt="" ></a>


  
  
  <figcaption>
    無向グラフ
  </figcaption>


</figure>














<figure>


  <a data-fancybox="" href="graph2.png" data-caption="有向グラフ">
<img src="graph2.png" alt="" ></a>


  
  
  <figcaption>
    有向グラフ
  </figcaption>


</figure>

<p>グラフ$G$上の 2 頂点$u$，$v$について，$u$を出発して隣接する頂点をたどることで$v$に到達できるとき，その経路を<strong>$u$-$v$路</strong>という．またこのとき$u$をその路の<strong>始点</strong>，$v$を<strong>終点</strong>という．さらに，路のうち，同じ頂点を 2 度以上通らないものを<strong>パス</strong>という．また，路のうち，始点と終点が等しいものを<strong>閉路</strong>（または<strong>サイクル</strong>）と呼ぶ．</p>













<figure>


  <a data-fancybox="" href="graph3.png" data-caption="パス">
<img src="graph3.png" alt="" ></a>


  
  
  <figcaption>
    パス
  </figcaption>


</figure>














<figure>


  <a data-fancybox="" href="graph4.png" data-caption="閉路">
<img src="graph4.png" alt="" ></a>


  
  
  <figcaption>
    閉路
  </figcaption>


</figure>

<p>グラフ$G$の任意の 2 頂点$u$，$v$ $\in V$に対して，$u$-$v$パス・$v$-$u$パスが存在するとき，$G$は<strong>連結</strong>であるという．特に，有向グラフ$G$の任意の 2 頂点$u$，$v$ $\in V$に対して，$u$-$v$パス・$v$-$u$パスが存在するとき，$G$は<strong>強連結</strong>であるという．</p>













<figure>


  <a data-fancybox="" href="graph5.png" data-caption="連結なグラフ">
<img src="graph5.png" alt="" ></a>


  
  
  <figcaption>
    連結なグラフ
  </figcaption>


</figure>














<figure>


  <a data-fancybox="" href="graph6.png" data-caption="連結でないグラフ">
<img src="graph6.png" alt="" ></a>


  
  
  <figcaption>
    連結でないグラフ
  </figcaption>


</figure>

<h2 id="計算機上でのグラフの実装">計算機上でのグラフの実装</h2>
<p>計算機上ではグラフは大きく分けて以下の二通りがある．</p>
<ul>
<li><strong>隣接リスト</strong></li>
</ul>
<p>グラフ$G$を構成する各頂点について，その頂点の隣接頂点をリストとして保持することでグラフを表現する．頂点数に対して辺の本数が比較的少ない疎なグラフの実装において（隣接行列表現と比較して）有利なことがある．</p>
<ul>
<li><strong>隣接行列</strong></li>
</ul>
<p>グラフ$G$を構成する$n$頂点について，$n \times n$の大きさのテーブルを用意し，頂点$i$-$j$間に辺が生えているとき，そのテーブルの$(i, j)$に<code>1</code>を立てることで辺を表現する．頂点数に対して辺の本数が比較的多い密なグラフの実装において（隣接リスト表現と比較して）有利なことがある．</p>
<p>以下では，グラフを隣接リストとして実装する．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;
Graph G;
</code></pre></div><p>例えば，入力が以下のように与えられたとき，グラフ$G$は次のように構築される．</p>
<blockquote>
<p>【<strong>入力</strong>】：</p>
<p>$$
N \space M
$$</p>
<p>$$
u_1 \space v_1
$$</p>
<p>$$
u_2 \space v_2
$$</p>
<p>$$
u_3 \space v_3
$$</p>
<p>$$
&hellip;
$$</p>
<p>$$
u_M \space v_M
$$</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    <span style="color:#75715e">// G[v].push_back(u);
</span><span style="color:#75715e"></span>  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>辺に重みのあるグラフであれば，<code>Edge</code>という辺を表す構造体を定義してやるとわかりやすい．</p>
<blockquote>
<p>【<strong>入力</strong>】：</p>
<p>$$
N \space M
$$</p>
<p>$$
u_1 \space v_1 \space w_1
$$</p>
<p>$$
u_2 \space v_2 \space w_2
$$</p>
<p>$$
u_3 \space v_3 \space w_3
$$</p>
<p>$$
&hellip;
$$</p>
<p>$$
u_M \space v_M \space w_M
$$</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span> {
  <span style="color:#66d9ef">int</span> to;
  <span style="color:#66d9ef">int</span> weight;
  Edge(<span style="color:#66d9ef">int</span> to, <span style="color:#66d9ef">int</span> weight)<span style="color:#f92672">:</span> to(to), weight(weight) {}
};
<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;&gt;</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> from, to, weight; cin <span style="color:#f92672">&gt;&gt;</span> from <span style="color:#f92672">&gt;&gt;</span> to <span style="color:#f92672">&gt;&gt;</span> weight;
    G[from].push_back(Edge(to, weight));
    <span style="color:#75715e">// G[to].push_back(Edge(from, weight));
</span><span style="color:#75715e"></span>  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="グラフの探索">グラフの探索</h2>
<p>一般にグラフ上の探索にはどのような方針が考えられるのだろうか．例えば以下のようなグラフに対する頂点 0 を始点とした探索を考える．</p>













<figure>


  <a data-fancybox="" href="traversal1.png" data-caption="頂点$0$から探索を始める．">
<img src="traversal1.png" alt="" ></a>


  
  
  <figcaption>
    頂点$0$から探索を始める．
  </figcaption>


</figure>

<p>頂点$0$に訪問した後，次に訪問する頂点を探す．つまり頂点$0$の隣接頂点を調べると，頂点$1$と頂点$2$を発見し保留メモに追記する．とりあえず，次に訪問する頂点を頂点$1$に決め，探索を続ける．</p>
<p>












<figure>


  <a data-fancybox="" href="traversal2.png" data-caption="頂点$0$に訪問した．">
<img src="traversal2.png" alt="" ></a>


  
  
  <figcaption>
    頂点$0$に訪問した．
  </figcaption>


</figure>














<figure>


  <a data-fancybox="" href="traversal3.png" data-caption="$次に訪問する頂点を決める．$">
<img src="traversal3.png" alt="" ></a>


  
  
  <figcaption>
    $次に訪問する頂点を決める．$
  </figcaption>


</figure>
</p>
<p>頂点$1$に訪問した後，次に訪問する頂点を探す．つまり，頂点$1$の隣接頂点を調べると，頂点$3$と頂点$4$を発見し保留メモに追記する．．そこで次に訪問する頂点の選び方が 2 通り考えられる．</p>
<ul>
<li><strong>「後に保留メモに追記した頂点$3$・頂点$4$を，頂点$2$より先に訪問する」</strong></li>
<li><strong>「先に保留メモに追記した頂点$2$を，頂点$3$・頂点$4$より先に訪問する」</strong></li>
</ul>
<p>「後に保留メモに追記した頂点$3$・頂点$4$を，頂点$2$より先に訪問する」という方針で続く探索を <strong>深さ優先探索 Depth-First Search（DFS）</strong> と呼び，「先に保留メモに追記した頂点$2$を，頂点$3$・頂点$4$より先に訪問する」という方針で続く探索を <strong>幅優先探索 Breadth-First Search（BFS）</strong> と呼ぶ．</p>
<p>DFS では保留メモの挙動が，Last-In-First-Out なのでスタックや再帰関数で実装することができる．一方で，BFS では保留メモの挙動が，First-In-First-Out なのでキューで実装することができる．</p>
<p>












<figure>


  <a data-fancybox="" href="traversal4.png" >
<img src="traversal4.png" alt="" ></a>



</figure>














<figure>


  <a data-fancybox="" href="traversal.png" >
<img src="traversal.png" alt="" ></a>



</figure>
</p>
<p>どういう方針で保留メモから次に訪れる頂点を選択するかを一旦脇においておいて，グラフ上の探索を書き下すと</p>
<pre><code>has_visited[i]: 頂点iが訪問済みならtrue，そうでないならfalseを格納する配列
suspended: 保留メモ（未訪問かつ存在を発見済みの頂点の集合）

has_visited全体をfalseで初期化・suspendedを空に初期化;
has_visited[始点頂点] = true; suspendedに始点頂点を追加;
while (!suspendedが空) {
  u := suspendedから1つ頂点を取り出す（このときの取り出し方で探索の性格が決まる）;
  for (v: uの隣接頂点) {
    if (has_visited[v]) continue; // すでに訪問済みだったのでスルー
    else {
      has_visited[u] = true; // 訪問したので印をつける
      suspended.append(v);   // 保留メモに追記する
    }
  }
}
</code></pre><p>また，閉路が存在しないかつ連結であるようなグラフは「<strong>木</strong>」と呼ばれる．木は，グラフの特殊型であるので，グラフでの探索と同様の議論が木での探索にも言える．</p>
<h2 id="深さ優先探索-depth-frist-seachdfs">深さ優先探索 Depth-Frist Seach（DFS)</h2>
<p>グラフ上を探索する手法として有名．「行けるところまで進んで，行き止まりになったら戻って別の道を試す」という方針でグラフ上を探索する．上の説明で言えば「保留メモから LIFO で頂点を取り出す」のが DFS．「保留メモから LIFO で頂点を取り出す」という方針がスタックや再帰関数の性質と一致し実装に用いられる．</p>
<h3 id="スタックによる-dfs-の実装">スタックによる DFS の実装</h3>
<p>スタックを用いて DFS を実装すると以下のようになる．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> suspended;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  suspended.push(v);

  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> suspended.top(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[u]) {
      <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">else</span> {
          has_visited[u] <span style="color:#f92672">=</span> true;
          suspended.push(w);
      }
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  has_visited.assign(N, false);

  DFS(G, <span style="color:#ae81ff">0</span>);

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="再帰関数による-dfs-の実装">再帰関数による DFS の実装</h3>
<p>再帰関数を用いて DFS を実装すると以下のようになる．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> u: G[v]) {
    <span style="color:#66d9ef">if</span> (has_visited[u]) <span style="color:#66d9ef">continue</span>;
    DFS(G, u);
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  has_visited.assign(N, false);

  DFS(G, <span style="color:#ae81ff">0</span>);
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="幅優先探索-breadth-first-searchbfs">幅優先探索 Breadth-First Search（BFS）</h2>
<p>グラフ上を探索する手法として有名．「分かれ道に遭遇したら，全ての分かれ道についてちょっとずつ等しく訪問していく」という方針でグラフ上を探索する．上の説明で言えば「保留メモから FIFO で頂点を取り出す」のが BFS．「保留メモから FIFO で頂点を取り出す」という方針がキューの性質と一致し実装に用いられる．</p>
<h3 id="キューによる-bfs-の実装">キューによる BFS の実装</h3>
<p>キューを用いて BFS を実装すると以下のようになる．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> suspended;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  suspended.push(v);

  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> suspended.front(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[u]) {
      <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">else</span> {
          has_visited[w] <span style="color:#f92672">=</span> true;
          suspended.push(w);
      }
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  has_visited.assign(N, false);

  BFS(G, <span style="color:#ae81ff">0</span>);

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="bfs-にあって-dfs-にないもの">BFS にあって DFS にないもの</h3>
<p>BFS は全頂点を始点からの辺の本数によってレベル分けすることになる．特に，全ての辺の重さが$1$であるような重み付きグラフで BFS を行うと，<strong>その始点からの各頂点の最短距離を求めるアルゴリズム</strong>としても使うことができる．ただし，<strong>BFS が最短距離を求めるアルゴリズムとして使えるのは，全ての辺の重さが$1$であるグラフに限る</strong>ことに注意しなければならない．そうでないグラフなら dijkstra 法など他のアルゴリズムを用いないと正しい答えが得られない．</p>
<p>BFS ですべての辺の重さが$1$であるようなグラフを構成する各頂点の，頂点$0$からの最短距離を求める処理を実装すると次の通り．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> distance; <span style="color:#75715e">// &lt;-- vector&lt;bool&gt; has_visited;
</span><span style="color:#75715e"></span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> suspended;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  distance[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 始点の距離は0
</span><span style="color:#75715e"></span>  suspended.push(v);

  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> suspended.front(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[u]) {
      <span style="color:#66d9ef">if</span> (distance[w] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// 訪問済みなのでスルー
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">else</span> {
          distance[w] <span style="color:#f92672">=</span> distance[u] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 頂点wは頂点uの隣接頂点
</span><span style="color:#75715e"></span>          suspended.push(w);
      }
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) distance[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// distance[i] == -1 --&gt; 頂点iには未訪問
</span><span style="color:#75715e"></span>
  BFS(G, <span style="color:#ae81ff">0</span>);

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;node[&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> distance[i] <span style="color:#f92672">&lt;&lt;</span> endl;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="グラフ探索の例題">グラフ探索の例題</h2>
<h3 id="到達可能性判定">到達可能性判定</h3>
<p>2 頂点$s$，$t$ $\in V$が与えられ，$s$から$t$へ辺をたどって到達することが可能であるかを判定する問題．単純に，<strong>$s$を始点とした DFS または BFS を実行し，<code>has_visited[s]</code>を確かめれば良い</strong>．</p>
<ul>
<li>スタックを使った DFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> suspended;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  suspended.push(v);

  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> suspended.top(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[u]) {
      <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">else</span> {
          has_visited[u] <span style="color:#f92672">=</span> true;
          suspended.push(w);
      }
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M, s, t; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M <span style="color:#f92672">&gt;&gt;</span> s <span style="color:#f92672">&gt;&gt;</span> t;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
  }
  has_visited.assign(N, false);
  DFS(G, s);
  <span style="color:#66d9ef">if</span> (has_visited[t]) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;No&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ul>
<li>再帰を使った DFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
    <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
    DFS(G, w);
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M, s, t; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M <span style="color:#f92672">&gt;&gt;</span> s <span style="color:#f92672">&gt;&gt;</span> t;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
  }
  has_visited.assign(N, false);
  DFS(G, s);
  <span style="color:#66d9ef">if</span> (has_visited[t]) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;No&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ul>
<li>BFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> suspended;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  suspended.push(v);

  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> suspended.front(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[u]) {
      <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">else</span> {
          has_visited[u] <span style="color:#f92672">=</span> true;
          suspended.push(w);
      }
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M, s, t; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M <span style="color:#f92672">&gt;&gt;</span> s <span style="color:#f92672">&gt;&gt;</span> t;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
  }
  has_visited.assign(N, false);
  BFS(G, s);
  <span style="color:#66d9ef">if</span> (has_visited[t]) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;No&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="グリッドグラフ">グリッドグラフ</h4>
<p>グラフが二次元グリッドとして与えられるような問題も頻出である．グリッド形式でのグラフの入力はたいてい以下のような形式である．</p>
<blockquote>
<p>【<strong>入力</strong>】</p>
<pre><code>10 10       // 盤面サイズ（縦・横）
s.........  // s: スタート位置
#########.  // g: ゴール位置
#.......#.  // 「.」は通路
#..####.#.  // 「#」は壁（進むことができない）
##....#.#.
#####.#.#.
g.#.#.#.#.
#.#.#.#.#.
#.#.#.#.#.
#.....#...
</code></pre></blockquote>
<p>与えられた迷路内を，上下左右に移動しながら通路マス<code>.</code>のみを通って<code>s</code>から<code>g</code>までたどり着けるかを判定する．</p>
<ul>
<li>スタックを使った DFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dy[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> H, W;
vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> maze;

<span style="color:#66d9ef">bool</span> has_visited[<span style="color:#ae81ff">510</span>][<span style="color:#ae81ff">510</span>];
stack<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> suspended;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">int</span> h, <span style="color:#66d9ef">int</span> w) {
  suspended.push(make_pair(h, w));
  has_visited[h][w] <span style="color:#f92672">=</span> true;

  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> ch, cw;
    tie(ch, cw) <span style="color:#f92672">=</span> suspended.top(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; dir<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> ch <span style="color:#f92672">+</span> dx[dir];
      <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> cw <span style="color:#f92672">+</span> dy[dir];
      <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// 場外なので進めず
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (maze[nh][nw] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// 壁なので進めず
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (has_visited[nh][nw]) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">else</span> {
        has_visited[ch][cw] <span style="color:#f92672">=</span> true;
        suspended.push(make_pair(nh, nw));
      }
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  cin <span style="color:#f92672">&gt;&gt;</span> H <span style="color:#f92672">&gt;&gt;</span> W;
  maze.resize(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> maze[h];

  <span style="color:#66d9ef">int</span> sh, sw, gh, gw;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> W; w<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (maze[h][w] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;s&#39;</span>) sh <span style="color:#f92672">=</span> h, sw <span style="color:#f92672">=</span> w;
      <span style="color:#66d9ef">if</span> (maze[h][w] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;g&#39;</span>) gh <span style="color:#f92672">=</span> h, gw <span style="color:#f92672">=</span> w;
    }
  }

  memset(has_visited, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(has_visited));

  DFS(sh, sw);

  <span style="color:#66d9ef">if</span> (has_visited[gh][gw]) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;No&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ul>
<li>再帰を使った DFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dy[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> H, W;
vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> maze;

<span style="color:#66d9ef">bool</span> has_visited[<span style="color:#ae81ff">510</span>][<span style="color:#ae81ff">510</span>];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">int</span> h, <span style="color:#66d9ef">int</span> w) {
  has_visited[h][w] <span style="color:#f92672">=</span> true;

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; dir<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> h <span style="color:#f92672">+</span> dx[dir];
    <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> w <span style="color:#f92672">+</span> dy[dir];

    <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// 場外なので進めず
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (maze[nh][nw] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// 壁なので進めず
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span> (has_visited[nh][nw]) <span style="color:#66d9ef">continue</span>;

    DFS(nh, nw);
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  cin <span style="color:#f92672">&gt;&gt;</span> H <span style="color:#f92672">&gt;&gt;</span> W;
  maze.resize(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> maze[h];

  <span style="color:#66d9ef">int</span> sh, sw, gh, gw;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> W; w<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (maze[h][w] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;s&#39;</span>) sh <span style="color:#f92672">=</span> h, sw <span style="color:#f92672">=</span> w;
      <span style="color:#66d9ef">if</span> (maze[h][w] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;g&#39;</span>) gh <span style="color:#f92672">=</span> h, gw <span style="color:#f92672">=</span> w;
    }
  }

  memset(has_visited, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(has_visited));

  DFS(sh, sw);

  <span style="color:#66d9ef">if</span> (has_visited[gh][gw]) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;No&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ul>
<li>BFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dy[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> H, W;
vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> maze;

<span style="color:#66d9ef">bool</span> has_visited[<span style="color:#ae81ff">510</span>][<span style="color:#ae81ff">510</span>];
queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> suspended;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">int</span> h, <span style="color:#66d9ef">int</span> w) {
  suspended.push(make_pair(h, w));
  has_visited[h][w] <span style="color:#f92672">=</span> true;

  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> ch, cw;
    tie(ch, cw) <span style="color:#f92672">=</span> suspended.front(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; dir<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> ch <span style="color:#f92672">+</span> dx[dir];
      <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> cw <span style="color:#f92672">+</span> dy[dir];
      <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// 場外なので進めず
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (maze[nh][nw] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// 壁なので進めず
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (has_visited[nh][nw]) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">else</span> {
        has_visited[ch][cw] <span style="color:#f92672">=</span> true;
        suspended.push(make_pair(nh, nw));
      }
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  cin <span style="color:#f92672">&gt;&gt;</span> H <span style="color:#f92672">&gt;&gt;</span> W;
  maze.resize(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> maze[h];

  <span style="color:#66d9ef">int</span> sh, sw, gh, gw;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> W; w<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (maze[h][w] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;s&#39;</span>) sh <span style="color:#f92672">=</span> h, sw <span style="color:#f92672">=</span> w;
      <span style="color:#66d9ef">if</span> (maze[h][w] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;g&#39;</span>) gh <span style="color:#f92672">=</span> h, gw <span style="color:#f92672">=</span> w;
    }
  }

  memset(has_visited, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(has_visited));

  BFS(sh, sw);

  <span style="color:#66d9ef">if</span> (has_visited[gh][gw]) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;No&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="連結成分のカウント">連結成分のカウント</h3>
<p>連結とは限らない（つまりぶった切れているかもしれない）グラフが与えられ，その連結成分の個数を数える．これも単純に<strong>まだ探索していない頂点を 1 つ選んで$v$とし，$v$を始点とする DFS または BFS を実行することを，全頂点が探索済みになるまで繰り返せば良い</strong>．</p>
<ul>
<li>スタックを使った DFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> suspended;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  suspended.push(v);
  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> suspended.top(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[u]) {
      <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">else</span> {
        has_visited[u] <span style="color:#f92672">=</span> true;
        suspended.push(w);
      }
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  has_visited.assign(N, false);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (has_visited[v]) <span style="color:#66d9ef">continue</span>;
    DFS(G, v);
    cnt<span style="color:#f92672">++</span>;
  }
  cout <span style="color:#f92672">&lt;&lt;</span> cnt <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ul>
<li>再帰を使った DFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
    <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">else</span> DFS(G, w);
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  has_visited.assign(N, false);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (has_visited[v]) <span style="color:#66d9ef">continue</span>;
    DFS(G, v);
    cnt<span style="color:#f92672">++</span>;
  }
  cout <span style="color:#f92672">&lt;&lt;</span> cnt <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ul>
<li>BFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> suspended;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  suspended.push(v);
  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> suspended.front(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[u]) {
      <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">else</span> {
        has_visited[u] <span style="color:#f92672">=</span> true;
        suspended.push(w);
      }
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  has_visited.assign(N, false);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (has_visited[v]) <span style="color:#66d9ef">continue</span>;
    BFS(G, v);
    cnt<span style="color:#f92672">++</span>;
  }
  cout <span style="color:#f92672">&lt;&lt;</span> cnt <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="二部グラフ判定">二部グラフ判定</h3>
<p>与えられたグラフが二部グラフであるかを判定する．二部グラフとは「全頂点を白または黒に塗っていくとき，白頂点同士が辺で結ばれることがなくかつ黒頂点同士が辺で結ばれることがないように頂点を塗り分けられるグラフ」のことである．</p>
<p>判定方法は簡単である．適当な頂点を白もしくは黒に塗ったとき，その頂点を始点に自動的に隣接頂点たちの色が次々に決まる．塗りながら，隣接する頂点が同じ色になってしまうかを確認すれば判定できる．全頂点を塗ることができれば，そのグラフは二部グラフであると言える．</p>
<p>また，配列<code>has_visited</code>は未訪問であることを表す色を導入することで，頂点の色を保持する配列にまとめさせることができる．</p>
<ul>
<li>再帰を使った DFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> color; <span style="color:#75715e">// color[i]: 0 = 黒, 1 = 白, -1 = 未訪問
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v, <span style="color:#66d9ef">int</span> current_color <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
  color[v] <span style="color:#f92672">=</span> current_color;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
    <span style="color:#66d9ef">if</span> (color[w] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
      <span style="color:#66d9ef">if</span> (color[w] <span style="color:#f92672">==</span> current_color) <span style="color:#66d9ef">return</span> false;
      <span style="color:#66d9ef">continue</span>;
    }
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>DFS(G, w, <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> current_color)) <span style="color:#66d9ef">return</span> false;
  }
  <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }
  color.assign(N, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  <span style="color:#66d9ef">bool</span> is_bipartite <span style="color:#f92672">=</span> true;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (color[v] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>DFS(G, v)) is_bipartite <span style="color:#f92672">=</span> false;
  }

  <span style="color:#66d9ef">if</span> (is_bipartite) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;No&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>BFS では「始点頂点からの距離によって頂点をレベル分けする」ことになり，与えられたグラフが二部グラフなら始点からの距離が偶数なら始点と同じ色，奇数なら異なる色となる．ここで，互いに隣接する頂点間では始点からの距離が 1 だけことなるので，<strong>「グラフが二部グラフである」と「BFS によって計算される各頂点の始点からの距離が等しい 2 頂点は隣接しない」は同値</strong>となる．</p>
<ul>
<li>BFS による解答</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  <span style="color:#66d9ef">bool</span> is_bipartite <span style="color:#f92672">=</span> true;
  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> distance(N, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> suspended;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (distance[v] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
    distance[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    suspended.push(v);
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.epmty()) {
      <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> suspended.front(); suspended.pop();
      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
        <span style="color:#66d9ef">if</span> (dist[w] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
          dist[w] <span style="color:#f92672">=</span> dist[v] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
          suspended.push(w);
        } <span style="color:#66d9ef">else</span> {
          <span style="color:#66d9ef">if</span> (dist[v] <span style="color:#f92672">==</span> dist[w]) is_bipartite <span style="color:#f92672">=</span> false;
        }
      }
    }
  }

  <span style="color:#66d9ef">if</span> (is_bipartite) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;No&#34;</span> MM endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="木に対する-dfs">木に対する DFS</h3>
<p>「木」は「閉路のない連結なグラフ」である．木に対する DFS では，次に訪問する頂点を探すときに，必ず「親がすでに訪問済みである」とマークされている．このことを利用することで，根のない木に対して，与えられた頂点を根としたときの根付き木を計算することができる．以下では，与えられたグラフ$G$を，頂点$0$を根とした根付き木と見たときの，各頂点の深さ（根からの距離）とその頂点を根とする部分木のサイズを計算する．頂点の深さは，根からの距離であり，<strong>行きがけ時に決まる</strong>．なぜなら，ある頂点の深さは，その頂点の親の深さに 1 を足したものである．一方で，部分木のサイズは，<strong>帰りがけ時に決まる</strong>．なぜなら，自身を根とする部分木のサイズは，自分の子供を根とする部分木のサイズの総和に 1 足したものである．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> depth;
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> subtree_size;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> d) {
  <span style="color:#75715e">// 行きがけ時
</span><span style="color:#75715e"></span>  depth[v] <span style="color:#f92672">=</span> d;

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
    <span style="color:#66d9ef">if</span> (w <span style="color:#f92672">==</span> p) <span style="color:#66d9ef">continue</span>;
    DFS(G, w, v);
  }

  <span style="color:#75715e">// 帰りがけ時
</span><span style="color:#75715e"></span>  subtree_size[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> child: G[v]) {
    <span style="color:#66d9ef">if</span> (child <span style="color:#f92672">==</span> p) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// 隣接頂点が親しかいない．つまり木から見ると葉
</span><span style="color:#75715e"></span>    subtree_size[v] <span style="color:#f92672">+=</span> subtree_size[c];
  }
  subtree_size[v] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 自分自身
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N; cin <span style="color:#f92672">&gt;&gt;</span> N; <span style="color:#75715e">// 木の辺数 = 頂点数 - 1
</span><span style="color:#75715e"></span>  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }
  <span style="color:#66d9ef">int</span> root <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  depth.assign(N, <span style="color:#ae81ff">0</span>);
  subtree_size.assign(N, <span style="color:#ae81ff">0</span>);
  DFS(G, root, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">// グラフGを，頂点0を根とした根付き木としてDFS
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span>  N; v<span style="color:#f92672">++</span>) {
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;node[&#34;</span> <span style="color:#f92672">&lt;&lt;</span> v  <span style="color:#e6db74">&#34;]: depth = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> depth[v] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, subtree_size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> subtree_size[v] <span style="color:#f92672">&lt;&lt;</span> endl;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>一般に，子ノードの情報を用いて親ノードの情報を更新する処理を<strong>木 DP</strong>という．<strong>行きがけ時には「親ノードの情報を子ノードに配る」ような処理</strong>をし，<strong>帰りがけ時には「子ノードの情報を親ノードに集めて親ノードの情報を更新する」ような処理</strong>をすると良い．</p>
<h3 id="トポロジカルソート">トポロジカルソート</h3>
<p>トポロジカルソートとは，閉路の存在しない有向グラフ（このようなグラフを DAG という）に対して，辺の向きが揃うように頂点を並べるようなソートのことを指し，ソフトウェアのモジュール間・ソースコード間の依存関係を解決するような場面で用いられる．また，DAG であることはトポロジカルソートが可能であることと同値であるらしい．</p>
<p>トポロジカルソートでは，その頂点を始点とする辺が 0 本であるような頂点（シンクノード）が末尾に来る.シンクノードを取り除き，その頂点に向かっていた辺を削除すると，新たにシンクノードになる頂点が発生する．新たに発生したシンクノードから適当に一つ選び削除し同様のことを行う．これをすべての頂点が削除されるまで行い，頂点の削除された逆順を出力するとトポロジカルソートが実現できる．この方法だと逆向きの BFS っぽい挙動となる．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);

  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> out_degree(N); <span style="color:#75715e">// out_degree[i]: 頂点iを始点とする辺の本数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> from, to; cin <span style="color:#f92672">&gt;&gt;</span> from <span style="color:#f92672">&gt;&gt;</span> to;
    G[to].push_back(from); <span style="color:#75715e">// 辺を逆向きに保存する
</span><span style="color:#75715e"></span>    out_degree[from]<span style="color:#f92672">++</span>;
  }

  queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) <span style="color:#66d9ef">if</span> (out_degree <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) q.push(i); <span style="color:#75715e">// シンクノードをキューに突っ込む
</span><span style="color:#75715e"></span>
  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> order; <span style="color:#75715e">// order[i]: 頂点iのトポロジカルソートにおける順位の逆順
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
    <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> q.front(); q.pop();
    order.push_back(v);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> neighbor: G[v]) {
      out_degree[neighbor]<span style="color:#f92672">--</span>; <span style="color:#75715e">// シンクノードに向かって生えていた辺を消す
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (out_degree[neighbor] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) q.push(neighbor);
    }
  }
  reverse(order.begin(), order.end());
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> v: order) cout <span style="color:#f92672">&lt;&lt;</span> v <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>ここで，DFS の帰りがけ順を考えると，これはまさしくトポロジカルソートとなる．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>has_visited, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>order) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
    <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
    DFS(G, w, has_visited, order);
  }

  <span style="color:#75715e">// 帰りがけ時
</span><span style="color:#75715e"></span>  order.push_back(v);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> from, to; cin <span style="color:#f92672">&gt;&gt;</span> from <span style="color:#f92672">&gt;&gt;</span> to;
    G[from].push_back(to);
  }

  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited(N, false);
  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> order;

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (has_visited[v]) <span style="color:#66d9ef">continue</span>;
    DFS(G, v, has_visited, order);
  }

  reverse(order.begin(), order.end());
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> v: order) cout <span style="color:#f92672">&lt;&lt;</span> v <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="閉路検出">閉路検出</h3>
<p>グラフに閉路が存在するかを検出する問題．BFS っぽいトポロジカルソートの手法を考慮すると，<strong>サイクルに含まれる頂点はシンクノードになることがない</strong>ので，トポロジカルソートできる範囲でトポロジカルソートした後に，キューに入ったことがない頂点が存在すれば，閉路が存在することがわかる．</p>
<p>以下は，サイクルを 1 つ含むことが保証された無向グラフに対して，2 頂点$a$，$b$がともにそのサイクル上にあるときは<code>2</code>を，そうでないときは<code>1</code>を出力せよという<a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2891">問題</a>の解答である．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N; cin <span style="color:#f92672">&gt;&gt;</span> N; <span style="color:#75715e">// サイクルを1つ含むグラフなので辺数もN
</span><span style="color:#75715e"></span>  Graph G(N);
  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> degree(N, <span style="color:#ae81ff">0</span>);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v;
    u<span style="color:#f92672">--</span>; v<span style="color:#f92672">--</span>;
    G[u].push_back(v);
    G[v].push_back(u);
    degree[u]<span style="color:#f92672">++</span>; degree[v]<span style="color:#f92672">++</span>;
  }

  queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) <span style="color:#66d9ef">if</span> (degree[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) q.push(i);

  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_enqueued(N, false); <span style="color:#75715e">// has_enqueued[i]: 頂点iがキューに入ったことがあるか
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
    <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> q.front(); q.pop();
    has_enqueued[v] <span style="color:#f92672">=</span> true;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
      degree[w]<span style="color:#f92672">--</span>;
      <span style="color:#66d9ef">if</span> (degree[w] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) q.push(w);
    }
  }

  <span style="color:#66d9ef">int</span> Q; cin <span style="color:#f92672">&gt;&gt;</span> Q;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> _ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; _ <span style="color:#f92672">&lt;</span> Q; _<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> a, b; cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b; a<span style="color:#f92672">--</span>; b<span style="color:#f92672">--</span>;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>has_enqueued[a] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>has_enqueued[b]) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  }
}
</code></pre></div><p>また，与えられたグラフに閉路があるとき，ある頂点$v$に対して，<strong>$v$から到達することができる全頂点の探索の終了より前に（つまり帰りがけ時になる前に）$v$に戻って来ることができる</strong>ことと同値である．これを検知してやっても閉路検知になる．これを実現するためには，<code>has_visited[i]: 頂点iを行きがけ順の意味で訪問済み</code>，<code>has_finished[i]: 頂点iを帰りがけ順の意味で訪問終了</code>とする配列を用意れば良い．また，閉路を復元までしたい場合には，<strong>行きがけ時に積み，帰りがけ時に取り出すスタック</strong>を用意すると，閉路を検知した時点でのスタックの中身が閉路を構成する頂点になっている．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited, has_finished;
<span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> history;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v, <span style="color:#66d9ef">int</span> p) {
  has_visited[v] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 行きがけ順の意味で訪問済み
</span><span style="color:#75715e"></span>  history.push(v);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
    <span style="color:#66d9ef">if</span> (w <span style="color:#f92672">==</span> p) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">if</span> (has_finished[w]) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">if</span> (has_visited[w] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>has_finished[w]) { <span style="color:#75715e">// 行きがけ順の意味で訪問済みなのに帰りがけ順の意味で未訪問
</span><span style="color:#75715e"></span>      pos <span style="color:#f92672">=</span> w;
      <span style="color:#66d9ef">return</span>;
    }
    DFS(G, w, v);
    <span style="color:#66d9ef">if</span> (pos <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span>;
  }
  history.pop();
  has_finished[v] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 帰りがけ順の意味で訪問済み
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N; cin <span style="color:#f92672">&gt;&gt;</span> N;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v; u<span style="color:#f92672">--</span>; v<span style="color:#f92672">--</span>;
    G[u].push_back(v);
    G[v].push_back(u);
  }
  has_visited.assign(N, false);
  has_finished.assign(N, false);
  pos <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  DFS(G, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

  set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> cycle;
  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>history.empty()) {
    <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> history.pop();
    cycle.insert(v);
    history.pop();
    <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">==</span> pos) <span style="color:#66d9ef">break</span>;
  }

  <span style="color:#66d9ef">int</span> Q; cin <span style="color:#f92672">&gt;&gt;</span> Q;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> _ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; _ <span style="color:#f92672">&lt;</span> Q; _<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> a, b; cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b; a<span style="color:#f92672">--</span>; b<span style="color:#f92672">--</span>;
    <span style="color:#66d9ef">if</span> (cycle.count(a) <span style="color:#f92672">&amp;&amp;</span> cycle.count(b)) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="グラフ探索の練習問題">グラフ探索の練習問題</h2>
<ul>
<li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_11_B&amp;lang=ja">ALDS 1-11 B</a></li>
<li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1160&amp;lang=jp">AOJ 1160</a></li>
<li><a href="https://atcoder.jp/contests/abc138/tasks/abc138_d">ABC 138 D</a></li>
<li><a href="https://atcoder.jp/contests/joi2009yo/tasks/joi2009yo_d">JOI2009 予選 4</a></li>
<li><a href="https://atcoder.jp/contests/arc031/tasks/arc031_2">ARC 31 B</a></li>
<li><a href="https://atcoder.jp/contests/abc126/tasks/abc126_d">ABC 126 D</a></li>
<li><a href="https://atcoder.jp/contests/code-festival-2017-qualb/tasks/code_festival_2017_qualb_c">CODE FSTIVAL2017 qualB C</a></li>
<li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_11_C&amp;lang=ja">ALDS 1-11 C</a></li>
<li><a href="https://atcoder.jp/contests/abc007/tasks/abc007_3">ABC 7 C</a></li>
<li><a href="https://atcoder.jp/contests/joi2011yo/tasks/joi2011yo_e">JOI2011 予選 5</a></li>
<li><a href="https://atcoder.jp/contests/joi2012yo/tasks/joi2012yo_e">JOI2012 予選 5</a></li>
<li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1166&amp;lang=jp">AOJ 1166</a></li>
<li><a href="https://atcoder.jp/contests/abc088/tasks/abc088_d">ABC 88 D</a></li>
<li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2891">AOJ 2891</a></li>
</ul>
<h2 id="解説">解説</h2>
<h3 id="alds-1-11-bhttpjudgeu-aizuacjponlinejudgedescriptionjspidalds1_11_blangja"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_11_B&amp;lang=ja">ALDS 1-11 B</a></h3>
<p>基本問題．再帰の DFS が書きやすい．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d; <span style="color:#75715e">// 行きがけのタイムスタンプ
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> f; <span style="color:#75715e">// 帰りがけのタイムスタンプ
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> tick <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  tick<span style="color:#f92672">++</span>;
  d[v] <span style="color:#f92672">=</span> tick;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
    <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
    DFS(G, w);
  }
  tick<span style="color:#f92672">++</span>;
  f[v] <span style="color:#f92672">=</span> tick;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N; cin <span style="color:#f92672">&gt;&gt;</span> N;
  Graph G(N);
  has_visited.resize(N); has_visited.assign(N, false);
  d.resize(N); d.assign(N, <span style="color:#ae81ff">0</span>);
  f.resize(N); f.assign(N, <span style="color:#ae81ff">0</span>);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, k;
    cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> k; u<span style="color:#f92672">--</span>;
    G[u].resize(<span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">int</span> v;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k; i<span style="color:#f92672">++</span>) {
      cin <span style="color:#f92672">&gt;&gt;</span> v; v<span style="color:#f92672">--</span>;
      G[u].push_back(v);
    }
  }
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>has_visited[i]) DFS(G, i);
  }
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    cout <span style="color:#f92672">&lt;&lt;</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> d[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> f[i] <span style="color:#f92672">&lt;&lt;</span> endl;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="aoj-1160httpjudgeu-aizuacjponlinejudgedescriptionjspid1160langjp"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1160&amp;lang=jp">AOJ 1160</a></h3>
<p>グリッドグラフの連結成分をカウントする問題．深さ優先探索でカウントしていく．陸が<code>1</code>で海が<code>0</code>であるが，訪問済みのマス目を<code>0</code>で潰していくことで配列<code>has_visited</code>を用意せずとも実装できる．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> H, W;
vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> field;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">int</span> h, <span style="color:#66d9ef">int</span> w) {
  field[h][w] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 訪問した陸のマスを海にしてしまう
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dh <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; dh <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; dh<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dw <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; dw <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; dw<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> h <span style="color:#f92672">+</span> dh;
      <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> w <span style="color:#f92672">+</span> dw;
      <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">if</span> (field[nh][nw] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;

      DFS(nh, nw);
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">while</span> (cin <span style="color:#f92672">&gt;&gt;</span> W <span style="color:#f92672">&gt;&gt;</span> H) {
    <span style="color:#66d9ef">if</span> (H <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
    field.assign(H, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(W, <span style="color:#ae81ff">0</span>));
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> W; w<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> field[h][w];
      }
    }

    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> W; w<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (field[h][w] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
        DFS(h, w);
        cnt<span style="color:#f92672">++</span>;
      }
    }
    cout <span style="color:#f92672">&lt;&lt;</span> cnt <span style="color:#f92672">&lt;&lt;</span> endl;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="abc-138-dhttpsatcoderjpcontestsabc138tasksabc138_d"><a href="https://atcoder.jp/contests/abc138/tasks/abc138_d">ABC 138 D</a></h3>
<p>親ノードの情報を子ノードに配るので，DFS で行きがけにカウンタの値を更新する．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span> counters;
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_visited;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  has_visited[v] <span style="color:#f92672">=</span> true;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
    <span style="color:#66d9ef">if</span> (has_visited[w]) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">else</span> {
      counters[w] <span style="color:#f92672">+=</span> counters[v];
      DFS(G, w);
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, Q; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> Q;
  Graph G(N);
  has_visited.resize(N);
  has_visited.assign(N, false);
  counters.resize(N);
  counters.assign(N, <span style="color:#ae81ff">0</span>);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> a, b; cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b; a<span style="color:#f92672">--</span>; b<span style="color:#f92672">--</span>;
    G[a].push_back(b);
    G[b].push_back(a);
  }
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> Q; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> p; cin <span style="color:#f92672">&gt;&gt;</span> p; p<span style="color:#f92672">--</span>;
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> x; cin <span style="color:#f92672">&gt;&gt;</span> x;
    counters[p] <span style="color:#f92672">+=</span> x;
  }
  DFS(G, <span style="color:#ae81ff">0</span>);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) cout <span style="color:#f92672">&lt;&lt;</span> counters[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> counters[i] <span style="color:#f92672">&lt;&lt;</span> endl;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="joi2009-予選-4httpsatcoderjpcontestsjoi2009yotasksjoi2009yo_d"><a href="https://atcoder.jp/contests/joi2009yo/tasks/joi2009yo_d">JOI2009 予選 4</a></h3>
<p>薄氷の地図をグリッドグラフとみなすと，割ることのできる薄氷の枚数はグラフの深さに対応する．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dy[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> H, W, ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;</span> has_broken;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> h, <span style="color:#66d9ef">int</span> w, <span style="color:#66d9ef">int</span> d) {
  ans <span style="color:#f92672">=</span> max(ans, d);
  has_broken[h][w] <span style="color:#f92672">=</span> true;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; dir<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> h <span style="color:#f92672">+</span> dx[dir];
    <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> w <span style="color:#f92672">+</span> dy[dir];
    <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">if</span> (has_broken[nh][nw]) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>G[nh][nw]) <span style="color:#66d9ef">continue</span>;
    DFS(G, nh, nw, d<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
  }
  has_broken[h][w] <span style="color:#f92672">=</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  cin <span style="color:#f92672">&gt;&gt;</span> W;
  cin <span style="color:#f92672">&gt;&gt;</span> H;

  has_broken.resize(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) has_broken[i].resize(W);
  Graph G(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) {
    G[i].resize(W);
  }
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> W; j<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">int</span> x; cin <span style="color:#f92672">&gt;&gt;</span> x;
      G[i][j] <span style="color:#f92672">=</span> x;
    }
  }
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> W; w<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>G[h][w]) <span style="color:#66d9ef">continue</span>;
      DFS(G, h, w, <span style="color:#ae81ff">1</span>);
    }
  }
  cout <span style="color:#f92672">&lt;&lt;</span> ans <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="arc-31-bhttpsatcoderjpcontestsarc031tasksarc031_2"><a href="https://atcoder.jp/contests/arc031/tasks/arc031_2">ARC 31 B</a></h3>
<p>グリッドグラフの連結成分カウント問題．DFS で解ける．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dh[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dw[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> H <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>, W <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> h, <span style="color:#66d9ef">int</span> w) {
  G[h][w] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;*&#39;</span>; <span style="color:#75715e">// 訪問済み
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; dir<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> h <span style="color:#f92672">+</span> dh[dir];
    <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> w <span style="color:#f92672">+</span> dw[dir];
    <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">if</span> (G[nh][nw] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span>) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">if</span> (G[nh][nw] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;x&#39;</span>) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">else</span> {
      DFS(G, nh, nw);
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">check</span>(Graph <span style="color:#f92672">&amp;</span>G) {
  <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> W; w<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (G[h][w] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;o&#39;</span>) {
        DFS(G, h, w);
        cnt<span style="color:#f92672">++</span>;
      }
    }
  }
  <span style="color:#66d9ef">return</span> cnt;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  Graph G(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> G[h];
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> W; w<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (G[h][w] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;x&#39;</span>) {
        G[h][w] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;o&#39;</span>;
        <span style="color:#66d9ef">if</span> (check(G) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
          cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;YES&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
          <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; h <span style="color:#f92672">&lt;</span> H; h<span style="color:#f92672">++</span>) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; w <span style="color:#f92672">&lt;</span> W; w<span style="color:#f92672">++</span>) <span style="color:#66d9ef">if</span> (G[h][w] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span>) G[h][w] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;o&#39;</span>;
        G[h][w] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;x&#39;</span>;
      }
    }
  }
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;NO&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="abc-126-dhttpsatcoderjpcontestsabc126tasksabc126_d"><a href="https://atcoder.jp/contests/abc126/tasks/abc126_d">ABC 126 D</a></h3>
<p>二部グラフ判定問題に似ている．「同じ色に塗られた任意の 2 頂点についてその距離が偶数」という条件から，ある 1 つ頂点の色を決めてしまえば，他の頂点の色は自動的に決定してしまう．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span> {
  <span style="color:#66d9ef">int</span> to;
  <span style="color:#66d9ef">int</span> weight;
  Edge(<span style="color:#66d9ef">int</span> to, <span style="color:#66d9ef">int</span> weight)<span style="color:#f92672">:</span> to(to), weight(weight) {}
};

<span style="color:#66d9ef">using</span> Tree <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;&gt;</span>;

<span style="color:#75715e">// 1: 黒, 0: 白, -1:未訪問
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> color;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Tree <span style="color:#f92672">&amp;</span>T, <span style="color:#66d9ef">int</span> v, <span style="color:#66d9ef">int</span> current_color <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
  color[v] <span style="color:#f92672">=</span> current_color;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> e: T[v]) {
    <span style="color:#66d9ef">if</span> (color[e.to] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
      <span style="color:#66d9ef">if</span> ((e.weight<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> color[e.to] <span style="color:#f92672">==</span> current_color) <span style="color:#f92672">&amp;&amp;</span>
          (e.weight<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> color[e.to] <span style="color:#f92672">!=</span> current_color)) {
            <span style="color:#66d9ef">return</span> false;
      } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">continue</span>;
      }
    }

    <span style="color:#66d9ef">if</span> (e.weight<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>DFS(T, e.to, current_color)) {
        <span style="color:#66d9ef">return</span> false;
      }
    } <span style="color:#66d9ef">else</span> {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>DFS(T, e.to, <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> current_color)) {
        <span style="color:#66d9ef">return</span> false;
      }
    }
  }
  <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  <span style="color:#66d9ef">int</span> N; cin <span style="color:#f92672">&gt;&gt;</span> N;
  Tree T(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, v, w; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v <span style="color:#f92672">&gt;&gt;</span> w; u<span style="color:#f92672">--</span>; v<span style="color:#f92672">--</span>;
    T[u].push_back(Edge(v, w));
    T[v].push_back(Edge(u, w));
  }
  color.assign(N, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (color[v] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">if</span> (DFS(T, v)) <span style="color:#66d9ef">break</span>;
  }
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) cout <span style="color:#f92672">&lt;&lt;</span> color[v] <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="code-fstival2017-qualb-chttpsatcoderjpcontestscode-festival-2017-qualbtaskscode_festival_2017_qualb_c"><a href="https://atcoder.jp/contests/code-festival-2017-qualb/tasks/code_festival_2017_qualb_c">CODE FSTIVAL2017 qualB C</a></h3>
<p>🍎さんが持っているのは，$N$頂点の<strong>連結な</strong>無向グラフ．操作によって頂点$u$-頂点$v$には長さ$3$のパスと長さ$1$のパスが存在することになる．奇数長のパスを持つ 2 頂点$u$，$v$ $\in V$に対して，「操作」を繰り返すことで$u$，$v$を直接結ぶ辺が登場する．これは帰納的に証明できる．<strong>「グラフに奇数長のパスが存在するかどうか」はそのグラフが二部グラフであるかどうかによって変わる</strong>．</p>
<p>まず，グラフ$G$が二部グラフであるときを考える．$G$は二部グラフなので頂点を黒・白で塗り分けることができる．異なる色で塗られた任意の頂点対を取ると，$G$は連結なグラフなので，その頂点対間にはパスが存在して，その長さは奇数である．ゆえに，「操作」を繰り返すことでいつかはその頂点対間には辺が張られる．よって，<strong>$G$が二部グラフであるとき，「操作」を繰り返すことで任意の黒色頂点-任意の白色頂点間に辺を張ることができる</strong>．追加できる辺の本数は，黒色頂点数と白色頂点数の積からすでに存在する辺数$M$を引いた値となる．</p>
<p>次にグラフ$G$が二部グラフでないときを考える．$G$が二部グラフでないならば，同じ色で塗られた頂点を結ぶ辺が存在することになる．$G$は連結でもあるので$V$内の任意の 2 頂点間にはパスが存在する．よって，同じ色で塗られた頂点を結ぶ辺の端点を含む長さが奇数の閉路が$G$に存在することになる．この閉路を用いることで，$G$内の任意の 2 頂点間に長さが奇数のパスを見つけることができる．$G$は連結なので，$V$内の任意の 2 頂点間にはパスが存在し，たとえそれが偶数であっても，奇数長の閉路を余分に経ることでそのパスの長さを奇数にすることができる．奇数長のパスが存在するときその端点の頂点は「操作」を繰り返すことで直接結ぶ辺が張られるので，$G$は完全グラフになっていく．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> color;
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v, <span style="color:#66d9ef">int</span> current_color <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
  color[v] <span style="color:#f92672">=</span> current_color;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> w: G[v]) {
    <span style="color:#66d9ef">if</span> (color[w] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
      <span style="color:#66d9ef">if</span> (color[w] <span style="color:#f92672">==</span> current_color) <span style="color:#66d9ef">return</span> false;
      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">continue</span>;
    }
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>DFS(G, w, <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> current_color)) <span style="color:#66d9ef">return</span> false;
  }
  <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N, M; cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> M;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> a, b; cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b; a<span style="color:#f92672">--</span>; b<span style="color:#f92672">--</span>;
    G[a].push_back(b);
    G[b].push_back(a);
  }
  color.assign(N, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  <span style="color:#66d9ef">bool</span> is_bipartite <span style="color:#f92672">=</span> true;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (color[v] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>DFS(G, v)) is_bipartite <span style="color:#f92672">=</span> false;
  }
  <span style="color:#66d9ef">if</span> (is_bipartite) {
    <span style="color:#66d9ef">int</span> B <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, W <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> N; v<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (color[v] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) W<span style="color:#f92672">++</span>;
      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (color[v] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) B<span style="color:#f92672">++</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> W<span style="color:#f92672">*</span>B <span style="color:#f92672">-</span> M <span style="color:#f92672">&lt;&lt;</span> endl;
  } <span style="color:#66d9ef">else</span> {
    cout <span style="color:#f92672">&lt;&lt;</span> N<span style="color:#f92672">*</span>(N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> M <span style="color:#f92672">&lt;&lt;</span> endl;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="alds-1-11-chttpjudgeu-aizuacjponlinejudgedescriptionjspidalds1_11_clangja"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_11_C&amp;lang=ja">ALDS 1-11 C</a></h3>
<p>幅優先探索の基本問題．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dist;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">const</span> Graph <span style="color:#f92672">&amp;</span>G, <span style="color:#66d9ef">int</span> v) {
  queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
  dist[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  q.push(v);

  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
    <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> q.front(); q.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> nn: G[w]) {
      <span style="color:#66d9ef">if</span> (dist[nn] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
      dist[nn] <span style="color:#f92672">=</span> dist[w] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
      q.push(nn);
    }
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> N; cin <span style="color:#f92672">&gt;&gt;</span> N;
  Graph G(N);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">int</span> u, k; cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> k; u<span style="color:#f92672">--</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> k; j<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">int</span> v; cin <span style="color:#f92672">&gt;&gt;</span> v; v<span style="color:#f92672">--</span>;
      G[u].push_back(v);
    }
  }
  dist.assign(N, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

  BFS(G, <span style="color:#ae81ff">0</span>);

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    cout <span style="color:#f92672">&lt;&lt;</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dist[i] <span style="color:#f92672">&lt;&lt;</span> endl;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="abc-7-chttpsatcoderjpcontestsabc007tasksabc007_3"><a href="https://atcoder.jp/contests/abc007/tasks/abc007_3">ABC 7 C</a></h3>
<p>グリッド形式での迷路探索．「最小手数」がほしいので BFS が手軽．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dh[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dw[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>;
queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> suspended;
vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dist; <span style="color:#75715e">// dist[i][j]: 位置(sx, sy)から位置(i, j)までの最小手数
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> H, W; cin <span style="color:#f92672">&gt;&gt;</span> H <span style="color:#f92672">&gt;&gt;</span> W;
  <span style="color:#66d9ef">int</span> sh, sw, gh, gw; cin <span style="color:#f92672">&gt;&gt;</span> sh <span style="color:#f92672">&gt;&gt;</span> sw <span style="color:#f92672">&gt;&gt;</span> gh <span style="color:#f92672">&gt;&gt;</span> gw; sh<span style="color:#f92672">--</span>; sw<span style="color:#f92672">--</span>; gh<span style="color:#f92672">--</span>; gw<span style="color:#f92672">--</span>;
  Graph G(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> G[i];
  dist.resize(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) {
    dist[i].resize(W);
    dist[i].assign(W, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  }

  dist[sh][sw] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  suspended.push(make_pair(sh, sw));
  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> h, w;
    tie(h, w) <span style="color:#f92672">=</span> suspended.front(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; dir<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> h <span style="color:#f92672">+</span> dh[dir];
      <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> w <span style="color:#f92672">+</span> dw[dir];
      <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">if</span> (dist[nh][nw] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">if</span> (G[nh][nw] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) <span style="color:#66d9ef">continue</span>;
      dist[nh][nw] <span style="color:#f92672">=</span> dist[h][w] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
      suspended.push(make_pair(nh, nw));
    }
  }

  cout <span style="color:#f92672">&lt;&lt;</span> dist[gh][gw] <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="joi2011-予選-5httpsatcoderjpcontestsjoi2011yotasksjoi2011yo_e"><a href="https://atcoder.jp/contests/joi2011yo/tasks/joi2011yo_e">JOI2011 予選 5</a></h3>
<p>ネズミの体力の初期値が$1$であり，チーズ$1$個ごとに体力が$1$増えるので，柔らかさ順にチーズを食べていくことになる．チーズ工場間の最短距離を求めていく．全対最短距離を求めるアルゴリズムを使っても良い．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">using</span> Field <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>;
Field F;
<span style="color:#66d9ef">int</span> H, W, N;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dh[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dw[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BFS</span>(pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> from, pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> to) {
  vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dist(H, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(W, <span style="color:#ae81ff">1e8</span>));
  queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> q;

  dist[from.first][from.second] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  q.push(from);

  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
    <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> q.front(); q.pop();
    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> p.first;
    <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> p.second;
    <span style="color:#66d9ef">if</span> (pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(h, w) <span style="color:#f92672">==</span> to) {
      <span style="color:#66d9ef">return</span> dist[h][w];
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; dir<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> h <span style="color:#f92672">+</span> dh[dir];
      <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> w <span style="color:#f92672">+</span> dw[dir];
      <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">if</span> (F[nh][nw] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;X&#39;</span>) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">if</span> (dist[h][w] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> dist[nh][nw]) {
        dist[nh][nw] <span style="color:#f92672">=</span> dist[h][w] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        q.push(pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(nh, nw));
      }
    }
  }
  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// should not reach here
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  cin <span style="color:#f92672">&gt;&gt;</span> H <span style="color:#f92672">&gt;&gt;</span> W <span style="color:#f92672">&gt;&gt;</span> N;
  F.resize(H);
  vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> factories(N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> F[i];
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> W; j<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (F[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;S&#39;</span>) F[i][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
      <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">&lt;=</span> F[i][j] <span style="color:#f92672">&amp;&amp;</span> F[i][j] <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;9&#39;</span>) {
        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> F[i][j] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>;
        factories[idx] <span style="color:#f92672">=</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(i, j);
      }
    }
  }

  <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
    ans <span style="color:#f92672">+=</span> BFS(factories[i], factories[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
  }
  cout <span style="color:#f92672">&lt;&lt;</span> ans <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="joi2012-予選-5httpsatcoderjpcontestsjoi2012yotasksjoi2012yo_e"><a href="https://atcoder.jp/contests/joi2012yo/tasks/joi2012yo_e">JOI2012 予選 5</a></h3>
<p>チョット変な座標系に対する BFS．建物のない区画に印をつけ，建物のない区画の周囲に建物が立っている区画があればその境界は色を塗ることになる．座標によって周囲 6 区画の，マス目位置が変わってくることに注意．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> odx[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> ody[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> edx[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> edy[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> w, h;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  cin <span style="color:#f92672">&gt;&gt;</span> w <span style="color:#f92672">&gt;&gt;</span> h;
  w <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>; h <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
  vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> a(h, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(w, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> h<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> w<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">++</span>) {
      cin <span style="color:#f92672">&gt;&gt;</span> a[i][j];
    }
  }

  <span style="color:#66d9ef">auto</span> paint_BFS <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span> sx, <span style="color:#66d9ef">int</span> sy) {
    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> q;
    q.push(make_pair(sx, sy));
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
      <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> q.front(); q.pop();
      <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> p.first, y <span style="color:#f92672">=</span> p.second;
      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>; dir<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> nx, ny;
        <span style="color:#66d9ef">if</span> (x<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
          nx <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> odx[dir]; ny <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> ody[dir];
        } <span style="color:#66d9ef">else</span> {
          nx <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> edx[dir]; ny <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> edy[dir];
        }

        <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> h <span style="color:#f92672">&lt;=</span> nx <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> w <span style="color:#f92672">&lt;=</span> ny) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (a[nx][ny] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (a[nx][ny] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
        a[nx][ny] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        q.push(make_pair(nx, ny));
      }
    }
  };

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> h; i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> w; j<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (a[i][j] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) paint_BFS(i, j);
    }
  }

  <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  {
    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> q;
    q.push(make_pair(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>));
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
      <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> q.front(); q.pop();
      <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> p.first, y <span style="color:#f92672">=</span> p.second;
      <span style="color:#66d9ef">if</span> (a[x][y] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>; dir<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> nx, ny;
        <span style="color:#66d9ef">if</span> (x<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
          nx <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> odx[dir]; ny <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> ody[dir];
        } <span style="color:#66d9ef">else</span> {
          nx <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> edx[dir]; ny <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> edy[dir];
        }

        <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> h <span style="color:#f92672">&lt;=</span> nx <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> w <span style="color:#f92672">&lt;=</span> ny) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (a[nx][ny] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (a[nx][ny] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
          ans<span style="color:#f92672">++</span>;
          <span style="color:#66d9ef">continue</span>;
        }
        q.push(make_pair(nx, ny));
      }
      a[x][y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }
  }
  cout <span style="color:#f92672">&lt;&lt;</span> ans <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="aoj-1166httpjudgeu-aizuacjponlinejudgedescriptionjspid1166langjp"><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1166&amp;lang=jp">AOJ 1166</a></h3>
<p>ややトリッキーな形で迷路情報が与えられる．内容は基本的な BFS に過ぎない．BFS のどこで迷路の情報を使うかというと，「隣接マスに行けるのか」を知るタイミングである．よって，縦横の仕切りの情報をそれぞれ別の形で持っておいて，隣接マスへの移動を考えるタイミングでその情報にアクセスするように実装する．</p>
<p><code>horizontal_partition</code>，<code>vertical_partition</code>という 2 つの配列で迷路情報を保持する．</p>













<figure>


  <a data-fancybox="" href="maze.png" data-caption="どの配列のどの要素がどこの壁のことを指すのかを整理する．">
<img src="maze.png" alt="" ></a>


  
  
  <figcaption>
    どの配列のどの要素がどこの壁のことを指すのかを整理する．
  </figcaption>


</figure>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">1001001</span>;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dh[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dw[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">int</span> W, H; cin <span style="color:#f92672">&gt;&gt;</span> W <span style="color:#f92672">&gt;&gt;</span> H;

    <span style="color:#66d9ef">if</span> (W <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> H <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;

    <span style="color:#66d9ef">int</span> vertical_partition[H][W<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">int</span> horizontal_partition[H<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][W];

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>H <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (i<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> W<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> vertical_partition[i<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>][j];
      } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> W; j<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> horizontal_partition[i<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>][j];
      }
    }

    <span style="color:#66d9ef">int</span> dist[H][W];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> W; j<span style="color:#f92672">++</span>) dist[i][j] <span style="color:#f92672">=</span> INF;
    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> q;

    dist[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    q.push(make_pair(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>));

    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
      <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> q.front(); q.pop();
      <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> p.first;
      <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> p.second;
      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; dir<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> h <span style="color:#f92672">+</span> dh[dir];
        <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> w <span style="color:#f92672">+</span> dw[dir];
        <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">==</span> h<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> nw <span style="color:#f92672">==</span> w <span style="color:#f92672">&amp;&amp;</span> horizontal_partition[h][w] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">==</span> h <span style="color:#f92672">&amp;&amp;</span> nw <span style="color:#f92672">==</span> w<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> vertical_partition[h][w] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">==</span> h<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> nw <span style="color:#f92672">==</span> w <span style="color:#f92672">&amp;&amp;</span> horizontal_partition[h<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][w] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">==</span> h <span style="color:#f92672">&amp;&amp;</span> nw <span style="color:#f92672">==</span> w<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> vertical_partition[h][w<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (dist[nh][nw] <span style="color:#f92672">!=</span> INF) <span style="color:#66d9ef">continue</span>;
        dist[nh][nw] <span style="color:#f92672">=</span> dist[h][w] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        q.push(make_pair(nh, nw));
      }
    }
    cout <span style="color:#f92672">&lt;&lt;</span>  (dist[H<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][W<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> INF <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> dist[H<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][W<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="abc-88-dhttpsatcoderjpcontestsabc088tasksabc088_d"><a href="https://atcoder.jp/contests/abc088/tasks/abc088_d">ABC 88 D</a></h3>
<p>要するに，$(1, 1)$から$(H, W)$まで最短経路で（＝通る白いマスの数が最小な経路で）いけば，それ以外のマスは黒に塗ることができ得点を最大化できる．</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dh[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dw[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">using</span> Graph <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>;
queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> suspended;
vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dist; <span style="color:#75715e">// dist[i][j]: 位置(sx, sy)から位置(i, j)までの最小手数
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> H, W; cin <span style="color:#f92672">&gt;&gt;</span> H <span style="color:#f92672">&gt;&gt;</span> W;
  Graph G(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> G[i];
  dist.resize(H);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) {
    dist[i].resize(W);
    dist[i].assign(W, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  }

  dist[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  suspended.push(make_pair(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>));
  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>suspended.empty()) {
    <span style="color:#66d9ef">int</span> h, w;
    tie(h, w) <span style="color:#f92672">=</span> suspended.front(); suspended.pop();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dir <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; dir<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">int</span> nh <span style="color:#f92672">=</span> h <span style="color:#f92672">+</span> dh[dir];
      <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> w <span style="color:#f92672">+</span> dw[dir];
      <span style="color:#66d9ef">if</span> (nh <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> H <span style="color:#f92672">&lt;=</span> nh <span style="color:#f92672">||</span> nw <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> W <span style="color:#f92672">&lt;=</span> nw) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">if</span> (dist[nh][nw] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
      <span style="color:#66d9ef">if</span> (G[nh][nw] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) <span style="color:#66d9ef">continue</span>;
      dist[nh][nw] <span style="color:#f92672">=</span> dist[h][w] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
      suspended.push(make_pair(nh, nw));
    }
  }
  <span style="color:#66d9ef">int</span> white <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> H; i<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> W; j<span style="color:#f92672">++</span>) {
          <span style="color:#66d9ef">if</span> (G[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span>) white<span style="color:#f92672">++</span>;
      }
  }
  <span style="color:#66d9ef">if</span> (dist[H<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][W<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> white <span style="color:#f92672">-</span> dist[H<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][W<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
    </div>

    





<div class="article-tags">
  
  <a class="badge badge-light" href="/ja/tags/atcoder/">AtCoder</a>
  
  <a class="badge badge-light" href="/ja/tags/competitive-programming/">Competitive Programming</a>
  
  <a class="badge badge-light" href="/ja/tags/c&#43;&#43;/">C&#43;&#43;</a>
  
  <a class="badge badge-light" href="/ja/tags/cpp/">cpp</a>
  
  <a class="badge badge-light" href="">競技プログラミング</a>
  
  <a class="badge badge-light" href="">競プロ</a>
  
  <a class="badge badge-light" href="/ja/tags/abc/">ABC</a>
  
  <a class="badge badge-light" href="">グラフ</a>
  
  <a class="badge badge-light" href="">グラフ理論</a>
  
  <a class="badge badge-light" href="/ja/tags/graph/">Graph</a>
  
  <a class="badge badge-light" href="/ja/tags/graph-theory/">Graph Theory</a>
  
  <a class="badge badge-light" href="">グラフ探索</a>
  
  <a class="badge badge-light" href="/ja/tags/graph-traversal/">Graph Traversal</a>
  
  <a class="badge badge-light" href="">深さ優先探索</a>
  
  <a class="badge badge-light" href="/ja/tags/depth-first-search/">Depth-First Search</a>
  
  <a class="badge badge-light" href="/ja/tags/dfs/">DFS</a>
  
  <a class="badge badge-light" href="">幅優先探索</a>
  
  <a class="badge badge-light" href="/ja/tags/breadth-first-search/">Breadth-First Search</a>
  
  <a class="badge badge-light" href="/ja/tags/bfs/">BFS</a>
  
</div>



<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=/ja/post/graph-traversal/&amp;text=%e3%82%b0%e3%83%a9%e3%83%95%e6%8e%a2%e7%b4%a2" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=/ja/post/graph-traversal/&amp;t=%e3%82%b0%e3%83%a9%e3%83%95%e6%8e%a2%e7%b4%a2" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook-f"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=%e3%82%b0%e3%83%a9%e3%83%95%e6%8e%a2%e7%b4%a2&amp;body=/ja/post/graph-traversal/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=/ja/post/graph-traversal/&amp;title=%e3%82%b0%e3%83%a9%e3%83%95%e6%8e%a2%e7%b4%a2" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://web.whatsapp.com/send?text=%e3%82%b0%e3%83%a9%e3%83%95%e6%8e%a2%e7%b4%a2%20/ja/post/graph-traversal/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=/ja/post/graph-traversal/&amp;title=%e3%82%b0%e3%83%a9%e3%83%95%e6%8e%a2%e7%b4%a2" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>












  






  
  
  
    
  
  
  <div class="media author-card content-widget-hr">
    
      
      <img class="portrait mr-3" src="/ja/authors/admin/avatar_hub69dcb66e1cbfdb18e29d9299880eec2_11573_250x250_fill_q90_lanczos_center.jpg" alt="Avatar">
    

    <div class="media-body">
      <h5 class="card-title"><a href="/">尾崎 耀一 (@zak)</a></h5>
      <h6 class="card-subtitle">大学院 修士2年 (修士課程)</h6>
      <p class="card-text">分散システムとかインターネット，ブロックチェーンに興味がある大学院生です．最近は分散グラフ処理系について研究しています．</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="/ja/#contact" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://twitter.com/zak74702675" target="_blank" rel="noopener">
        <i class="fab fa-twitter"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/zakimal" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://www.amazon.jp/hz/wishlist/ls/1ZX30ER9D9I4X?ref_=wl_share" target="_blank" rel="noopener">
        <i class="fab fa-amazon"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://www.linkedin.com/in/yoichi-ozaki-706760181/" target="_blank" rel="noopener">
        <i class="fab fa-linkedin"></i>
      </a>
    </li>
  
    
    
    
    
    
    
    
      
    
    <li>
      <a href="/ja/files/cv-ja.pdf" >
        <i class="ai ai-cv"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>




<section id="comments">
  
    <script src="https://utteranc.es/client.js"
        repo="zakimal/zakimal.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
  
</section>






  
  
  <div class="article-widget content-widget-hr">
    <h3>関連項目</h3>
    <ul>
      
      <li><a href="/ja/post/binary-search/">二分探索</a></li>
      
      <li><a href="/ja/post/check-all-cases/">全探索</a></li>
      
      <li><a href="/ja/post/parallelizing-sequential-graph-computations/">Parallelizing Sequential Graph Computations</a></li>
      
    </ul>
  </div>
  



  </div>
</article>

      

    
    
    
    <script src="/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.3.1/mermaid.min.js" integrity="sha256-vOIuDSYDirTfyr+S2MjFnhOz6Rgiz4ODFAHATG0rFxw=" crossorigin="anonymous" title="mermaid"></script>
      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js" integrity="sha256-1zu+3BnLYV9LdiY85uXMzii3bdrkelyp37e0ZyTAQh0=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/go.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/1c.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/abnf.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/accesslog.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/actionscript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ada.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/angelscript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/apache.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/applescript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/arcade.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/arduino.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/armasm.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/asciidoc.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/aspectj.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/autohotkey.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/autoit.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/avrasm.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/awk.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/axapta.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/bash.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/basic.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/bnf.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/brainfuck.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/cal.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/capnproto.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ceylon.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/clean.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/clojure-repl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/clojure.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/cmake.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/coffeescript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/coq.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/cos.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/cpp.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/crmsh.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/crystal.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/cs.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/csp.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/css.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/d.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/dart.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/delphi.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/diff.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/django.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/dns.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/dos.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/dsconfig.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/dts.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/dust.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ebnf.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/elixir.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/elm.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/erb.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/excel.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/fix.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/flix.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/fortran.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/fsharp.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/gams.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/gauss.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/gcode.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/gherkin.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/glsl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/gml.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/go.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/golo.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/gradle.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/groovy.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/haml.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/handlebars.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/haskell.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/haxe.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/hsp.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/htmlbars.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/http.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/hy.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/inform7.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ini.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/irpf90.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/isbl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/java.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/javascript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/jboss-cli.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/json.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/julia-repl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/julia.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/kotlin.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/lasso.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ldif.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/leaf.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/less.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/lisp.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/livecodeserver.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/livescript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/llvm.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/lsl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/lua.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/makefile.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/markdown.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/mathematica.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/matlab.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/maxima.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/mel.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/mercury.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/mipsasm.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/mizar.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/mojolicious.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/monkey.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/moonscript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/n1ql.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/nginx.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/nimrod.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/nix.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/nsis.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/objectivec.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ocaml.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/openscad.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/oxygene.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/parser3.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/perl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/pf.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/pgsql.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/php.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/plaintext.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/pony.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/powershell.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/processing.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/profile.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/prolog.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/properties.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/protobuf.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/puppet.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/purebasic.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/python.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/q.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/qml.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/reasonml.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/rib.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/roboconf.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/routeros.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/rsl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ruby.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/rust.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/sas.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/scala.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/scheme.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/scilab.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/scss.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/shell.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/smali.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/smalltalk.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/sml.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/sqf.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/sql.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/stan.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/stata.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/step21.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/stylus.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/subunit.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/swift.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/taggerscript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/tap.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/tcl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/tex.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/thrift.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/tp.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/twig.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/typescript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/vala.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/vbnet.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/vbscript-html.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/vbscript.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/verilog.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/vhdl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/vim.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/x86asm.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/xl.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/xml.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/xquery.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/yaml.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/zephir.min.js"></script>
        
      

      
      
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    

    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/ja/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"結果が見つかりませんでした","placeholder":"検索...","results":"results found"};
      const content_type = {
        'post': "投稿",
        'project': "プロジェクト",
        'publication' : "発表文献",
        'talk' : "登壇"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.d6bd04fdad2ad213aa8111c5a3b72fc5.js"></script>

    






  
  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    © zak 2021 &middot; 

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">引用</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> コピー
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> ダウンロード
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
