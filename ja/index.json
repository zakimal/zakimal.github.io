[{"authors":["admin"],"categories":null,"content":"ã¯ã˜ã‚ã¾ã—ã¦ï¼zak ã§ã™ï¼\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"ja","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/ja/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/ja/authors/admin/","section":"authors","summary":"ã¯ã˜ã‚ã¾ã—ã¦ï¼zak ã§ã™ï¼","tags":null,"title":"å°¾å´ è€€ä¸€ (@zak)","type":"authors"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼\n# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right äºŒåˆ†æœ¨rootãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œã“ã‚Œã‚’æ¬¡ã®ã‚ˆã†ãªãƒ«ãƒ¼ãƒ«ã«åŸºã¥ã„ã¦æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹å‡¦ç†ã‚’æ›¸ã‘ï¼\n root.val (å·¦éƒ¨åˆ†æœ¨) (å³éƒ¨åˆ†æœ¨) ãŸã ã—ï¼Œä¸ãˆã‚‰ã‚ŒãŸäºŒåˆ†æœ¨ãŒãã®æ–‡å­—åˆ—ã¨1å¯¾1ã«å¯¾å¿œã™ã‚‹é™ã‚Šç©ºã‹ã£ã“ï¼ˆ()ï¼‰ã‚’çœç•¥ã™ã‚‹  å…·ä½“çš„ã«ã¯ï¼Œå³å­ã—ã‹ã„ãªã„ã¨ãã®å·¦å­ç›¸å½“ã®()ã¯çœç•¥ã§ããªã„  ã“ã†ã—ãªã„ã¨ä¸€æ–¹ã—ã‹å­ä¾›ãŒã„ãªã„ã¨ãã«ãã®å­ãŒå·¦å³ã®ã©ã£ã¡ã®å­ä¾›ã‹ãŒåˆ¤æ–­ã§ããšåŒã˜æ–‡å­—åˆ—ã‹ã‚‰è¤‡æ•°ã®äºŒåˆ†æœ¨ãŒæ§‹æˆã§ãã¦ã—ã¾ã†      è§£æ³• # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def tree2str(self, root: Optional[TreeNode]) -\u0026gt; str: ans = \u0026#34;\u0026#34; def rec(node): nonlocal ans if node is None: return ans += str(node.val) if node.left is None and node.right is None: return ans += \u0026#34;(\u0026#34; rec(node.left) ans += \u0026#34;)\u0026#34; if node.right is not None: ans += \u0026#34;(\u0026#34; rec(node.right) ans += \u0026#34;)\u0026#34; rec(root) return ans å‡ºå…¸  https://leetcode.com/problems/construct-string-from-binary-tree/  ","date":1647592571,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1647592571,"objectID":"c514dbb591bd55ae3f21b9275acee7b8","permalink":"/ja/post/construct-string-from-binary-tree/","publishdate":"2022-03-18T17:36:11+09:00","relpermalink":"/ja/post/construct-string-from-binary-tree/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼ # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right äºŒåˆ†æœ¨rootãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œã“ã‚Œã‚’æ¬¡ã®ã‚ˆã†ãªãƒ«ãƒ¼ãƒ«","tags":[],"title":"Construct String From Binary Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼\n# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right 2ã¤ã®æœ¨p/qãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã‚Œã‚‰ã®å€¤ãƒ»å½¢ãŒä¸€è‡´ã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼\nè§£æ³• å†å¸°é–¢æ•°ã‚’æ›¸ãã¨ãã®è‡ªå·±æµæ‰‹é †ã‚’æ›¸ã„ã¦ãŠãï¼\nã¾ãšå…ˆã«ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã˜ã‚ƒãªã„éƒ¨åˆ†ã‚’æ›¸ã„ã¦ã—ã¾ã†ï¼ä»Šå›ãªã‚‰æ¡ä»¶ã‚’ã€Œæ ¹åŒå£«ã®å€¤ãŒä¸€è‡´ and å·¦éƒ¨åˆ†æœ¨ã®å€¤ãƒ»å½¢ãŒä¸€è‡´ and å³éƒ¨åˆ†æœ¨ã®å€¤ãƒ»å½¢ãŒä¸€è‡´ã€ã¨ã„ã†é¢¨ã«å†å¸°çš„ã«è¨€ã„æ›ãˆã‚‰ã‚Œã‚‹ã®ã§ãã‚Œã‚’å…ˆã«æ›¸ã„ã¦ã—ã¾ã†ï¼ãã†ã™ã‚‹ã¨ï¼Œã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã¨ã—ã¦ã©ã†ã„ã†æ¡ä»¶ã®æ™‚ã‚’åˆ¥å‡¦ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ãŒå½¢ã‹ã‚‰ã‚ã‹ã£ã¦ãã‚‹ï¼ˆæ°—ãŒã—ã¦ã‚‹ï¼‰ï¼å½¢ã‹ã‚‰ã‚ã‹ã‚‹ã¨ã„ã†ã®ã¯ã‚ã¾ã‚Šæ€è€ƒãŒã„ã‚‰ãªã„ã¨ã„ã†æ„å‘³ï¼ã“ã®ä¾‹ã ã¨ï¼Œp.val/q.valãªã©p/qã®å±æ€§ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒå¿…è¦ã«ãªã‚‹ã®ã§ï¼Œp/qãŒNoneã«ãªã£ã¡ã‚ƒã†ã¨å›°ã‚‹ï¼ˆnot Noneã§ã‚ã‚‹ã¨ã„ã†å‰æã‚’æš—é»™ã«ãŠã„ã¦è€ƒãˆã¦ã„ãŸã“ã¨ã«ãªã‚‹ï¼‰ï¼ãã‚Œã‚‰ã‚’æ‰‹å‰ã§å‡¦ç†ã—ã¦ç½®ã‹ãªã‘ã‚Œã°ã„ã‹ã‚“ãªãã¨ã„ã†æ°—æŒã¡ã«ãªã‚‹ã¨p/qãŒNoneã‹ãã†ã˜ã‚ƒãªã„ã‹ã®4é€šã‚Šã‚ã£ã¦ãã‚Œãã‚Œæ½°ã—ã¦ãŠãã‹ã¨ã„ã†é¢¨ã«æ€è€ƒãŒé€²ã‚€ï¼æ°—ãŒã™ã‚‹ï¼æ­£ã—ã„ã®ã‹ã¯ã‚ã‹ã‚‰ãªã„ï¼ãŒï¼Œã“ã†ã„ã†è€ƒãˆæ–¹ã§ã†ã¾ãã„ãã‚ˆã†ãªæ°—ãŒã—ã¦ã„ã‚‹ï¼\nå…¨é ‚ç‚¹ã‚’è¨ªå•ã™ã‚‹ã®ã§æ™‚é–“è¨ˆç®—é‡ã¯$O(n)$ï¼ç©ºé–“è¨ˆç®—é‡ã¯æœ¨ã®é«˜ã•ç¨‹åº¦ã«å†å¸°é–¢æ•°ãŒå‘¼ã°ã‚Œã‚‹ã®ã§$O(\\log n)$ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -\u0026gt; bool: if p is None and q is None: return True if p is None and q is not None: return False if p is not None and q is None: return False return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) stackã§æ›¸ãä¸‹ã™ã¨æ¬¡ã®ã‚ˆã†ã«ã‚‚æ›¸ã‘ã‚‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -\u0026gt; bool: def check(node1, node2): if node1 is None and node2 is None: return True if node1 is not None and node2 is None: return False if node1 is None and node2 is not None: return False return node1.val == node2.val suspended = [(p, q)] while len(suspended) != 0: (node1, node2) = suspended.pop() if not check(node1, node2): return False if node1 is not None: suspended.append((node1.left, node2.left)) suspended.append((node1.right, node2.right)) return True å‡ºå…¸  https://leetcode.com/problems/same-tree/  ","date":1647590333,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1647590333,"objectID":"85cdf94db2da419dee2c131a4455ae54","permalink":"/ja/post/same-tree/","publishdate":"2022-03-18T16:58:53+09:00","relpermalink":"/ja/post/same-tree/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼ # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right 2ã¤ã®æœ¨p/qãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã‚Œã‚‰ã®å€¤ãƒ»å½¢ãŒä¸€è‡´ã—","tags":[],"title":"Same Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼\n# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right 2ã¤ã®äºŒåˆ†æœ¨root1/root2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã‚Œã‚‰ã‚’é‡ã­ãŸçµæœå¾—ã‚‰ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è¨ˆç®—ã›ã‚ˆï¼\nä¾‹ï¼š\n 1 2 3 3 2 + 1 3 = 4 5 5 4 7 5 4 7 è§£æ³•  mergeTree(root1, root2)ã¯root1ã‚’æ ¹ã¨ã™ã‚‹æœ¨ã¨root2ã‚’å¯ã¨ã™ã‚‹æœ¨ã‚’é‡ã­ã‚‹é–¢æ•°  ã¾ãšæ ¹ï¼ˆroot1/root2ï¼‰ã‚’é‡ã­ã‚‹ å·¦å³ã®éƒ¨åˆ†æœ¨ã«ã¤ã„ã¦ã¯å†å¸°çš„ã«è€ƒãˆã‚‰ã‚Œã‚‹ï¼ã¤ã¾ã‚Š  mergeTree(root1.left, root2.left)ã¯root1.leftã‚’æ ¹ã¨ã™ã‚‹æœ¨ã¨root2.leftã‚’å¯ã¨ã™ã‚‹æœ¨ã‚’é‡ã­ã‚‹é–¢æ•° mergeTree(root1.right, root2.right)ã¯root1.rightã‚’æ ¹ã¨ã™ã‚‹æœ¨ã¨root2.rightã‚’å¯ã¨ã™ã‚‹æœ¨ã‚’é‡ã­ã‚‹é–¢æ•° ã“ã‚Œã‚‰ã®çµæœãŒé‡ã­çµ‚ã‚ã£ãŸæœ¨ã®æ ¹ã®å·¦å³ã®éƒ¨åˆ†æœ¨ã«ãªã£ã¦ã»ã—ã„ã®ã§ã¤ã‘ã‚‹ï¼  ã‚ã‚ãªã‚“ã¦å†å¸°çš„ãªã‚“ã         # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: if root1 is None: return root2 # ç›¸æ–¹ãŒã„ãªã‘ã‚Œã°è¶³ã•ãšã«ã«ãã®ã¾ã¾ if root2 is None: return root1 # ç›¸æ–¹ãŒã„ãªã‘ã‚Œã°è¶³ã•ãšã«ãã®ã¾ã¾ root1.val += root2.val root1.left = self.mergeTrees(root1.left, root2.left) root1.right = self.mergeTrees(root1.right, root2.right) return root1 å‡ºå…¸  https://leetcode.com/problems/merge-two-binary-trees/  ","date":1647589138,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1647589138,"objectID":"f1795ca74a20cd6c74127246c0c86ce3","permalink":"/ja/post/merge-two-binary-trees/","publishdate":"2022-03-18T16:38:58+09:00","relpermalink":"/ja/post/merge-two-binary-trees/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼ # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right 2ã¤ã®äºŒåˆ†æœ¨root1/root2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã‚Œã‚‰","tags":[],"title":"Merge Two Binary Trees","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼\n# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right äºŒåˆ†æœ¨ã®æ ¹rootã¨æ•´æ•°targetSumãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼æ ¹ã‹ã‚‰è‘‰ã¾ã§ã®æœ¨ä¸Šã®ãƒ‘ã‚¹ã®å’ŒãŒtargetSumã¨ç­‰ã—ããªã‚‹ã‚ˆã†ãªãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼\nè§£æ³• æœ¨ã‚’é™ã‚Šã¦ã„ããªãŒã‚‰targetSumã«ãªã‚‹ã‹ã‚’ç¢ºã‹ã‚ã‚‹ï¼\nã¾ãšã¯å†å¸°é–¢æ•°ã§DFSã™ã‚‹ã‚„ã‚Šã‹ãŸï¼DFSã§é ‚ç‚¹ã‚’è¨ªå•ã—ã«è¡Œãï¼è‘‰ãƒãƒ¼ãƒ‰ã«åˆ°é”ã—ãŸæ™‚ç‚¹ã§æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹ï¼æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ãƒ‘ã‚¹ã‚’ç™ºè¦‹ã—ãŸã‚‰ãã®æ—¨ã‚’ansã«ãŸã‚ã¦ã‚‹ï¼ä»Šå›ã®å•é¡Œã ã¨æ¡ä»¶ã‚’æº€ãŸã™ãƒ‘ã‚¹ã‚’ï¼‘ã¤ã§ã‚‚è¦‹ã¤ã‘ã‚Œã°ãã‚Œã§ååˆ†ãªã®ã§é€”ä¸­ã§æ‰“ã¡åˆ‡ã£ãŸã»ã†ãŒé«˜é€Ÿãªã®ã ã‚ã†ãŒï¼Œå†å¸°é–¢æ•°ã®é€”ä¸­ã§ä¸€æ°—ã«æŠœã‘ã‚‹ã®ã£ã¦exitã™ã‚‹ã¨ã‹ã ã‚ã†ã‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: ans = [] def dfs(node, sofar, ans): if node is not None: sofar += node.val if node.left is None and node.right is None and sofar == targetSum: ans.append(True) if node.left is not None: dfs(node.left, sofar, ans) if node.right is not None: dfs(node.right, sofar, ans) dfs(root, 0, ans) return len(ans) != 0 æ¬¡ã«stackã§DFSã™ã‚‹ã‚„ã‚Šã‹ãŸï¼çŠ¶æ…‹ã¨ã—ã¦(è¨ªå•ä¸­ã®é ‚ç‚¹, ã“ã“ã¾ã§ã®ãƒ‘ã‚¹ã®å’Œ)ã‚’æŒã£ã¦ãŠãï¼ã“ã£ã¡ã§ã‚„ã‚‹ã¨1ã¤ã§ã‚‚æ¡ä»¶ã‚’æº€ãŸã™ãƒ‘ã‚¹ã‚’è¦‹ã¤ã‘ãŸã‚‰æŠœã‘ã‚‰ã‚Œã‚‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: if root is None: return False suspended = [(root, root.val)] while len(suspended) != 0: node, sofar = suspended.pop() if node.left is None and node.right is None and sofar == targetSum: return True if node.left is not None: suspended.append((node.left, sofar + node.left.val)) if node.right is not None: suspended.append((node.right, sofar + node.right.val)) return False æœ€å¾Œã«BFSã§ã®ã‚„ã‚Šã‹ãŸï¼ä¸Šã®DFSã‚’æ›¸ã„ã¦popã‚’æœ«ç«¯ã‹ã‚‰æˆ¦é—˜ã«ã™ã‚Œã°ã„ã„ã ã‘ãªã®ã§æ¥½ã«æ›¸ã‘ã‚‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: if root is None: return False suspended = [(root, root.val)] while len(suspended) != 0: node, sofar = suspended.pop(0) if node.left is None and node.right is None and sofar == targetSum: return True if node.left is not None: suspended.append((node.left, sofar + node.left.val)) if node.right is not None: suspended.append((node.right, sofar + node.right.val)) return False sofarã«ä»Šè¨ªå•ã—ã¦ã„ã‚‹é ‚ç‚¹ã®å€¤ã‚’è¶³ã™ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§é ­ãŒæ··ä¹±ã—ãªã„ã‚ˆã†ã«æ³¨æ„ã—ã‚ˆã†ï¼\nå‡ºå…¸  https://leetcode.com/problems/path-sum/  ","date":1647587522,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1647587522,"objectID":"0f4b04da7fd588abf0ced6c28e92af3c","permalink":"/ja/post/path-sum/","publishdate":"2022-03-18T16:12:02+09:00","relpermalink":"/ja/post/path-sum/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼ # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right äºŒåˆ†æœ¨ã®æ ¹rootã¨æ•´æ•°targetSumãŒä¸ãˆã‚‰ã‚Œã‚‹","tags":[],"title":"Path Sum","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®æœ¨ã®æ·±ã•ã®æœ€å¤§å€¤ï¼ˆæ ¹ã‹ã‚‰è‘‰ã¾ã§ã®è·é›¢ã®æœ€å¤§å€¤ï¼‰ã‚’æ±‚ã‚ã‚ˆï¼\n# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right è§£æ³• æ±‚ã‚ã‚‹æ·±ã•ã®æœ€å¤§å€¤ã¯1 + max(å·¦éƒ¨åˆ†æœ¨ã®æ·±ã•ã®æœ€å¤§å€¤, å³éƒ¨åˆ†æœ¨ã®æ·±ã•ã®æœ€å¤§å€¤)ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: Optional[TreeNode]) -\u0026gt; int: if root is None: return 0 left_depth = self.maxDepth(root.left) right_depth = self.maxDepth(root.right) return max(left_depth, right_depth) + 1 å‡ºå…¸  https://leetcode.com/problems/maximum-depth-of-binary-tree/submissions/  ","date":1647587082,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1647587082,"objectID":"25fa1a4bc6e7be7ab1121e174cce30bf","permalink":"/ja/post/maximum-depth-of-binary-tree/","publishdate":"2022-03-18T16:04:42+09:00","relpermalink":"/ja/post/maximum-depth-of-binary-tree/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®æœ¨ã®æ·±ã•ã®æœ€å¤§å€¤ï¼ˆæ ¹ã‹ã‚‰è‘‰ã¾ã§ã®è·é›¢ã®æœ€å¤§å€¤ï¼‰ã‚’æ±‚ã‚ã‚ˆï¼ # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val =","tags":[],"title":"Maximum Depth of Binary Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ äºŒåˆ†æœ¨rootã¨æœ¨ã«å«ã¾ã‚Œã‚‹2é ‚ç‚¹p/qãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼pã¨qã®æœ€å°æœ¨å…±é€šå…ˆç¥–ï¼ˆLowest Common Ancestorï¼‰ã‚’æ±‚ã‚ã‚ˆï¼\nè§£æ³• rootãŒã€ŒäºŒåˆ†æ¢ç´¢æœ¨ã€ã«ãªã£ã¦ã„ã‚‹ãªã‚‰è©±ã¯ç°¡å˜ã ãŒï¼Œä»Šå›ã¯äºŒåˆ†æœ¨ï¼ã ã‹ã‚‰ã¨ã„ã£ã¦ãªã«ã‹ãŒæ ¹æœ¬çš„ã«å¤‰ã‚ã‚‹ã‚ã‘ã§ã¯ãªã„ãŒï¼\nå¸°ã‚ŠãŒã‘é †ã§DFSã—ãªãŒã‚‰ï¼Œp/qã«é­é‡ã—ãŸã‚‰é­é‡ã—ãŸæ—¨ã‚’è¦ªæ–¹å‘ã«æŒã£ã¦ã„ããªãŒã‚‰æˆ»ã£ã¦ã„ãã“ã¨ã§LCAã‚’è¦‹ã¤ã‘ã‚‰ã‚Œã‚‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: if root is None: return None def dfs(node): if node is None: return None if node.val == p.val or node.val == q.val: return node left = dfs(node.left) right = dfs(node.right) if left is not None and right is not None: return node # å·¦éƒ¨åˆ†æœ¨ã§p/qã‚’è¦‹ã‹ã‘ãŸï¼Œã‹ã¤ï¼Œå³éƒ¨åˆ†æœ¨ã§p/qã‚’è¦‹ã‹ã‘ãŸ -\u0026gt; ä»Šã„ã‚‹é ‚ç‚¹ã¯LCA return left or right return dfs(root) ã‚‚ã—ãã¯ã€Œä¸€åº¦DFSã™ã‚‹ã“ã¨ã§ï¼Œp/qã®è¦ªæƒ…å ±ã‚’äº‹å‰ã«é›†ã‚ã¦ãŠãã€ã“ã¨ã«ã‚ˆã£ã¦æ–‡å­—é€šã‚Šå…ˆç¥–ã‚’è¿½ã£ã¦ã„ãã“ã¨ã§ã‚‚è§£ã‘ã‚‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: stack = [root] parents = {root: None} while not (p in parents and q in parents): node = stack.pop() if node.left is not None: parents[node.left] = node stack.append(node.left) if node.right is not None: parents[node.right] = node stack.append(node.right) ancestors = set() while p is not None: ancestors.add(p) p = parents[p] while q not in ancestors: q = parents[q] return q å‡ºå…¸  https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/  ","date":1647522943,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1647522943,"objectID":"ced985940ce204d148d08a2e7451714b","permalink":"/ja/post/lowest-common-ancestor-of-a-binary-tree/","publishdate":"2022-03-17T22:15:43+09:00","relpermalink":"/ja/post/lowest-common-ancestor-of-a-binary-tree/","section":"post","summary":"å•é¡Œ äºŒåˆ†æœ¨rootã¨æœ¨ã«å«ã¾ã‚Œã‚‹2é ‚ç‚¹p/qãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼pã¨qã®æœ€å°æœ¨å…±é€šå…ˆç¥–ï¼ˆLowest Common Ancestorï¼‰ã‚’æ±‚ã‚ã‚ˆï¼ è§£æ³• rootãŒã€Œ","tags":[],"title":"Lowest Common Ancestor of a Binary Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ äºŒåˆ†æ¢ç´¢æœ¨rootã¨ãã®æœ¨ã«å«ã¾ã‚Œã‚‹2é ‚ç‚¹p/qãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼pã¨qã®å…±é€šã®å…ˆç¥–ã®ã†ã¡ï¼Œé«˜ã•ãŒæœ€ã‚‚ä½ã„ã‚‚ã®ï¼ˆæœ€å°å…±é€šç¥–å…ˆï¼šLowest Common Ancestorï¼‰ã‚’è¨ˆç®—ã›ã‚ˆï¼\nè§£æ³• äºŒåˆ†æ¢ç´¢æœ¨ã¯\n å·¦ã®å­ â‰¤ è¦ª â‰¤ å³ã®å­  ãŒæˆç«‹ã—ã¦ã„ã‚‹ï¼\nrootãŒpã¨qã®é–“ã«ã‚ã‚Œã°æœ€å°æœ¨å…±é€šå…ˆç¥–ã¯rootã«ãªã‚‹ï¼ã•ã‹ã®ã¼ã£ã¦ã„ã‘ã°rootã«ã¶ã¤ã‹ã‚‹ã®ã§ï¼Œå½“ãŸã‚Šå‰ã¨ã„ãˆã°å½“ãŸã‚Šå‰ï¼rootã®æ‰‹å‰ã§å…±é€šå…ˆç¥–ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒï¼Œæ±‚ã‚ãŸã„ã®ã¯æœ€å°ã®ã‚‚ã®ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ï¼\nå†å¸°é–¢æ•°ã§æ›¸ãè§£æ³•ãŒã“ã¡ã‚‰ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: if root.val \u0026lt; p.val and root.val \u0026lt; q.val: return self.lowestCommonAncestor(root.right, p, q) if p.val \u0026lt; root.val and q.val \u0026lt; root.val: return self.lowestCommonAncestor(root.left, p, q) return root currã¨ã„ã†ãƒã‚¤ãƒ³ã‚¿ã‚’æŒã¡å‡ºã—ã¦ç¹°ã‚Šè¿”ã—ã§æ›¸ãä¸‹ã™ã¨æ¬¡ã®ã‚ˆã†ã«æ›¸ã‘ã‚‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: curr = root while curr is not None: if curr.val \u0026lt; p.val and curr.val \u0026lt; q.val: curr = curr.right elif p.val \u0026lt; curr.val and q.val \u0026lt; curr.val: curr = curr.left else: return curr å‡ºå…¸  https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/  ","date":1647522078,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1647522078,"objectID":"683a48b5b99b02a12f7b709c83804768","permalink":"/ja/post/lowest-common-ancestor-of-a-binary-search-tree/","publishdate":"2022-03-17T22:01:18+09:00","relpermalink":"/ja/post/lowest-common-ancestor-of-a-binary-search-tree/","section":"post","summary":"å•é¡Œ äºŒåˆ†æ¢ç´¢æœ¨rootã¨ãã®æœ¨ã«å«ã¾ã‚Œã‚‹2é ‚ç‚¹p/qãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼pã¨qã®å…±é€šã®å…ˆç¥–ã®ã†ã¡ï¼Œé«˜ã•ãŒæœ€ã‚‚ä½ã„ã‚‚ã®ï¼ˆæœ€å°å…±é€šç¥–å…ˆï¼šLowest Common","tags":[],"title":"Lowest Common Ancestor of a Binary Search Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼\n# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ã‚ã‚‹äºŒåˆ†æœ¨ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼Œãã®äºŒåˆ†æœ¨ãŒå¹³è¡¡ã—ã¦ã„ã‚‹ï¼ˆbalancedï¼‰ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼ãªãŠäºŒåˆ†æœ¨ãŒä¸¦è¡Œã—ã¦ã„ã‚‹ã¨ã¯æ¬¡ã‚’æº€ãŸã™ã“ã¨ã¨å®šç¾©ã™ã‚‹ï¼\n äºŒåˆ†æœ¨ã«å«ã¾ã‚Œã‚‹ã©ã®é ‚ç‚¹ã‚’æ ¹ã¨ã—ãŸã¨ãã‚‚ï¼Œãã®å·¦å³ã®éƒ¨åˆ†æœ¨ã®é«˜ã•ã®å·®ãŒ1ä»¥ä¸‹ã§ã‚ã‚‹  è§£æ³• æœ¨ã®é«˜ã•ã¯å†å¸°çš„ã«è¨ˆç®—ã§ãã‚‹ã®ã§ï¼Œãã‚Œã‚’ã™ã¹ã¦ã®é ‚ç‚¹ã§ç¢ºèªã™ã‚‹ã“ã¨ã§å®šç¾©é€šã‚Šã«åˆ¤å®šã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: if root is None: return True def height(root): if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return 1 + max(left_height, right_height) return abs(height(root.left) - height(root.right)) \u0026lt;= 1 and self.isBalanced(root.left) and self.isBalanced(root.right) ã‚ã‚‹éƒ¨åˆ†æœ¨ã§height(root)ãŒ$O(n)$å›å‘¼ã°ã‚Œã‚‹ãŒï¼Œãã‚Œã‚’å…¨é ‚ç‚¹ã§è¡Œã†ã“ã¨ã«ãªã£ã¦ï¼Œå…¨ä½“ã¨ã—ã¦ã¯$O(n^2)$ã®è¨ˆç®—é‡ãŒã‹ã‹ã‚‹ï¼\nå¹³è¡¡ã—ã¦ã„ãªã„æœ¨ã‚’éƒ¨åˆ†æœ¨ã¨ã—ã¦æŒã¤æœ¨ã¯å¹³è¡¡ã—ã¦ã„ãªã„ã®ã§ï¼Œã“ã‚Œã‚’ã†ã¾ãè¿”ã—ã¦ã„ã‘ã°å…¨ä½“ã®è¨ˆç®—é‡ã‚’$O(n)$ã«ã§ãã‚‹ï¼\nä¸‹ã®å®Ÿè£…ã§ã¯ï¼Œheight(root)ã§rootã‚’æ ¹ã¨ã™ã‚‹éƒ¨åˆ†æœ¨ã®å·¦å³ã®éƒ¨åˆ†æœ¨ã®é«˜ã•ã‚’è¨ˆç®—ã™ã‚‹ãŒï¼Œé«˜ã•ã®å·®ãŒ1ã‚ˆã‚Šå¤§ãã„å ´åˆã¯-1ã‚’è¿”ã™ã“ã¨ã§ãã‚Œã‚’è¡¨ç¾ã—ã¦ã„ã‚‹ï¼height(root)ã®çµæœã¨ã—ã¦-1ãŒè¿”ã£ãŸç¬é–“ã«ç„¡é§„ãªè¨ˆç®—ã‚’ã›ãšå¹³è¡¡ã—ã¦ã„ãªã„ã“ã¨ã‚’è¿”ã›ã‚‹ï¼\n# Time: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: if root is None: return True def height(root): if root is None: return 0 left_height = height(root.left) if left_height == -1: return -1 right_height = height(root.right) if right_height == -1: return -1 if abs(left_height - right_height) \u0026gt; 1: return -1 return 1 + max(left_height, right_height) return height(root) != -1 å‡ºå…¸  https://leetcode.com/problems/balanced-binary-tree/  ","date":1647510604,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1647510604,"objectID":"a06c736f33a084669323578ca8a42d2f","permalink":"/ja/post/balanced-binary-tree/","publishdate":"2022-03-17T18:50:04+09:00","relpermalink":"/ja/post/balanced-binary-tree/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼ # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ã‚ã‚‹äºŒåˆ†æœ¨ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼Œãã®äºŒåˆ†æœ¨ãŒå¹³è¡¡ã—ã¦ã„ã‚‹","tags":[],"title":"Balanced Binary Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼\nclass TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right äºŒåˆ†æœ¨ã®ç›´å¾„ã‚’è¨ˆç®—ã›ã‚ˆï¼\nè§£æ³• äºŒåˆ†æœ¨ã‚’æ ¹ã‚’ä¸­å¿ƒã«å·¦å³ã«å¼•ã£å¼µã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ã™ã‚‹ã¨ç›´å¾„ã¯å·¦å³ã®éƒ¨åˆ†æœ¨ã®æ·±ã•ã®å’Œ+1ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ï¼æœ¨ã®æ·±ã•ã¯å†å¸°é–¢æ•°ã§è¨ˆç®—ã§ãã‚‹ï¼\n   äºŒåˆ†æœ¨ã®ç›´å¾„ã¯å·¦å³ã®æ·±ã•ã®å’Œ+1   # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: Optional[TreeNode]) -\u0026gt; int: diameter = 0 def depth(root): nonlocal diameter if root is None: return 0 left_depth = depth(root.left) right_depth = depth(root.right) diameter = max(diameter, left_depth + right_depth) return 1 + max(left_depth, right_depth) depth(root) return diameter å‡ºå…¸  https://leetcode.com/problems/diameter-of-binary-tree/  ","date":1646987897,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1646987897,"objectID":"c17da7439907888f3f99784e720c6537","permalink":"/ja/post/diameter-of-binary-tree/","publishdate":"2022-03-11T17:38:17+09:00","relpermalink":"/ja/post/diameter-of-binary-tree/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼ class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right äºŒåˆ†æœ¨ã®ç›´å¾„ã‚’è¨ˆç®—ã›ã‚ˆï¼ è§£æ³• äºŒåˆ†æœ¨ã‚’æ ¹ã‚’ä¸­å¿ƒã«å·¦å³ã«å¼•ã£å¼µã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸","tags":[],"title":"Diameter of Binary Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼\nclass TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right å·¦è‘‰ãƒãƒ¼ãƒ‰ã®åˆè¨ˆã‚’æ±‚ã‚ã‚ˆï¼\nè§£æ³•  DFSã«ã‚ˆã‚‹è§£æ³•  DFSã§å…¨é ‚ç‚¹ã‚’ãªã‚ãªãŒã‚‰ï¼Œãã®é ‚ç‚¹ãŒå·¦å´ã®å­ãªã—ã§ã‚ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹  ã€Œå­ãªã—ã€ã§ã‚ã‚‹ã“ã¨ã¯TreeNode.left/TreeNode.rightãŒNoneã§ã‚ã‚‹ã“ã¨ã‚’è¦‹ã‚Œã°è‰¯ã„ ã€Œå·¦å´ã®ã€ã§ã‚ã‚‹ã“ã¨ã¯è¿½åŠ ã®å¤‰æ•°ã§è¿½è·¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ å†å¸°é–¢æ•°ã§ã‚‚stackã§ã‚‚å®Ÿè£…ã§ãã‚‹   æ™‚é–“è¨ˆç®—é‡$O(n)$ ç©ºé–“è¨ˆç®—é‡$O(\\log n)$    # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumOfLeftLeaves(self, root: Optional[TreeNode]) -\u0026gt; int: def dfs(node, is_left): if node is None: return 0 if node.left is None and node.right is None: return node.val if is_left else 0 return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumOfLeftLeaves(self, root: TreeNode) -\u0026gt; int: ans = 0 stack = [(root, False)] while len(stack) != 0: node, is_left = stack.pop() if node.left is None and node.right is None and is_left: ans += node.val if node.left is not None: stack.append((node.left, True)) if node.right is not None: stack.append((node.right, False)) return ans  BFSã«ã‚ˆã‚‹è§£æ³•  DFSã§å…¨é ‚ç‚¹ã‚’ãªã‚ãªãŒã‚‰ï¼Œãã®é ‚ç‚¹ãŒå·¦å´ã®å­ãªã—ã§ã‚ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹  ã€Œå­ãªã—ã€ã§ã‚ã‚‹ã“ã¨ã¯TreeNode.left/TreeNode.rightãŒNoneã§ã‚ã‚‹ã“ã¨ã‚’è¦‹ã‚Œã°è‰¯ã„ ã€Œå·¦å´ã®ã€ã§ã‚ã‚‹ã“ã¨ã¯è¿½åŠ ã®å¤‰æ•°ã§è¿½è·¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹   æ™‚é–“è¨ˆç®—é‡$O(n)$ ç©ºé–“è¨ˆç®—é‡$O(\\log n)$    # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumOfLeftLeaves(self, root: TreeNode) -\u0026gt; int: ans = 0 queue = [(root, False)] while len(queue) != 0: node, is_left = queue.pop(0) if node.left is None and node.right is None and is_left: ans += node.val if node.left is not None: queue.append((node.left, True)) if node.right is not None: queue.append((node.right, False)) return ans  Morris Traversal  æ‹™è‘—è¨˜äº‹ï¼šhttps://zakimal.github.io/ja/post/morris-traversal/ inorderã§å…¨æ¢ç´¢ã™ã‚‹ã®ã‚’ç©ºé–“è¨ˆç®—é‡$O(1)$ã§å®Ÿç¾ã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ     # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumOfLeftLeaves(self, root: TreeNode) -\u0026gt; int: ans = 0 while root is not None: if root.left is not None: prev = root.left while prev.right is not None and prev.right is not root: prev = prev.right if prev.right is None: # in-orderé †ã§rootã®ç›´å‰ã®ãƒãƒ¼ãƒ‰ãŒprevã«ãªã£ã¦ã„ã‚‹ prev.right = root # ä¸€æ™‚çš„ãªãƒªãƒ³ã‚¯ã‚’å¼µã‚‹ root = root.left else: prev.right = None # ã“ã“ã§ä¸€æ™‚çš„ã«å¼µã£ãŸãƒªãƒ³ã‚¯ã‚’æ¶ˆã—ã¦ã‚‹ if prev is root.left and prev.left is None: ans += prev.val root = root.right else: # ã“ã“ã«å…¥ã‚Šè¾¼ã‚€æ™‚ç‚¹ã§rootã¯å·¦ç«¯ã®è‘‰ãƒãƒ¼ãƒ‰ root = root.right return ans å‡ºå…¸  https://leetcode.com/problems/sum-of-left-leaves/  ","date":1646923582,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1646923582,"objectID":"03d6ee286136c40c3233186a81b82865","permalink":"/ja/post/sum-of-left-leaves/","publishdate":"2022-03-10T23:46:22+09:00","relpermalink":"/ja/post/sum-of-left-leaves/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right å·¦è‘‰ãƒãƒ¼ãƒ‰ã®åˆè¨ˆã‚’æ±‚ã‚ã‚ˆï¼ è§£æ³• DFSã«ã‚ˆã‚‹è§£æ³• DFSã§å…¨é ‚ç‚¹ã‚’ãª","tags":[],"title":"Sum of Left Leaves","type":"post"},{"authors":[],"categories":[],"content":"äºŒåˆ†æœ¨ä¸Šã®æ¢ç´¢ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼\nclass: TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ã‚ã‚‹äºŒåˆ†æœ¨rootãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼Œãã®æœ¨ã‚’æ§‹æˆã™ã‚‹é ‚ç‚¹ã®å…¨æ¢ç´¢ã¯ã€Œæ·±ã•å„ªå…ˆæ¢ç´¢ Depth-First Searchï¼ˆDFSï¼‰ã€ã¨ã€Œå¹…å„ªå…ˆæ¢ç´¢ Breadth-First Searchï¼ˆBFSï¼‰ã€ã«å¤§åˆ¥ã•ã‚Œã‚‹ï¼\næ·±ã•å„ªå…ˆæ¢ç´¢ Depth-First Searchï¼ˆDFSï¼‰ äºŒåˆ†æœ¨ã«ãŠã‘ã‚‹æ·±ã•å„ªå…ˆæ¢ç´¢ã¯ã€Œä»Šã„ã‚‹é ‚ç‚¹ã‚’èª¿æŸ»ã—ã¦ï¼Œãã®å­ä¾›ã®é ‚ç‚¹ã«ã‚‚åŒã˜èª¿æŸ»ã‚’ç¹°ã‚Šè¿”ã™ã‚ˆã†ã«èµ°æŸ»ã€ã™ã‚‹ï¼\nä»Šã„ã‚‹é ‚ç‚¹ã¨å·¦å³ã®å­ä¾›ã®é ‚ç‚¹ã‚’ã©ã†ã„ã†é †ç•ªã§èµ°æŸ»ã™ã‚‹ã®ã‹ã§åå‰ãŒä»˜ã„ã¦ã„ã‚‹ï¼\n è¡ŒããŒã‘é †ï¼ˆpre-order traversalï¼‰  ã¾ãšæ ¹ãƒãƒ¼ãƒ‰ã‚’è¦‹ã¦ï¼Œç¶šã‘ã¦å·¦éƒ¨åˆ†æœ¨ã‚’è¡ŒããŒã‘é †ã§èµ°æŸ»ï¼Œæœ€å¾Œã«å³éƒ¨åˆ†æ©Ÿã‚’è¡ŒããŒã‘é †ã§èµ°æŸ»   é€šã‚ŠãŒã‘é †ï¼ˆin-order traversalï¼‰  ã¾ãšå·¦éƒ¨åˆ†æ©Ÿã‚’é€šã‚ŠãŒã‘é †ã§èµ°æŸ»ï¼Œç¶šã‘ã¦æ ¹ãƒãƒ¼ãƒ‰ã‚’è¦‹ã¦ï¼Œæœ€å¾Œã«å³éƒ¨åˆ†æ©Ÿã‚’è¡ŒããŒã‘é †ã§èµ°æŸ»   å¸°ã‚ŠãŒã‘é †ï¼ˆpost-order traversalï¼‰  ã¾ãšå·¦éƒ¨åˆ†æ©Ÿã‚’é€šã‚ŠãŒã‘é †ã§èµ°æŸ»ï¼Œç¶šã‘ã¦å³éƒ¨åˆ†æ©Ÿã‚’è¡ŒããŒã‘é †ã§èµ°æŸ»ï¼Œæœ€å¾Œã«æ ¹ãƒãƒ¼ãƒ‰ã‚’è¦‹ã¦    å†å¸°é–¢æ•°ã§ç°¡å˜ã«å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼stackã‚’ç”¨ã„ã¦ã‚‚å®Ÿè£…å¯èƒ½ï¼\nè¡ŒããŒã‘é †ã‚’å†å¸°é–¢æ•°ã§å®Ÿè£…ã™ã‚‹ã¨\ndef preorder(root): process(root) preorder(root.left) preorder(root.right) è¡ŒããŒã‘é †ã‚’stackã‚’ç”¨ã„ã¦å®Ÿè£…ã™ã‚‹ã¨\ndef preorder(root): stack = [root] while len(stack) != 0: node = stack.pop() process(node) stack.append(root.left) stack.append(root.right) é€šã‚ŠãŒã‘é †ã‚’å†å¸°é–¢æ•°ã§å®Ÿè£…ã™ã‚‹ã¨\ndef inorder(root): preorder(root.left) process(root) preorder(root.right) å¸°ã‚ŠãŒã‘é †ã‚’å†å¸°é–¢æ•°ã§å®Ÿè£…ã™ã‚‹ã¨\ndef inorder(root): preorder(root.left) preorder(root.right) process(root) å¹…å„ªå…ˆæ¢ç´¢ Breadth-First Searchï¼ˆBFSï¼‰ äºŒåˆ†æœ¨ã«ãŠã‘ã‚‹å¹…å„ªå…ˆæ¢ç´¢ã¯ã€Œæ·±ã•ãŒåŒã˜é ‚ç‚¹ç¾¤ã‚’ï¼Œæµ…ã„é †ã«èµ°æŸ»ã€ã™ã‚‹ï¼queueã‚’ç”¨ã„ã‚‹ã¨ç°¡å˜ã«å®Ÿè£…ã§ãã‚‹ï¼\ndef bfs(root): queue = [root] while len(queue) != 0: node = queue.pop(0) process(node) queue.append(root.left) queue.append(root.right) Morris Traversal å†å¸°é–¢æ•°ã«ã‚ˆã‚‹ï¼ˆè¡ŒããŒã‘é †ï½œé€šã‚ŠãŒã‘é †ï½œå¸°ã‚ŠãŒã‘é †ï¼‰DFSï¼Œstackã«ã‚ˆã‚‹ï¼ˆè¡ŒããŒã‘é †ï¼‰DFSï¼Œqueueã«ã‚ˆã‚‹BFSã¯ï¼Œæœ¨ã‚’æ§‹æˆã™ã‚‹é ‚ç‚¹ã®ç·æ•°ãŒ$n$ã§ã‚ã‚‹ã¨ã—ã¦ï¼Œ\n æ™‚é–“è¨ˆç®—é‡$O(n)$  $n$é ‚ç‚¹å…¨éƒ¨ã‚’è¨ªå•ã™ã‚‹ã‹ã‚‰   ç©ºé–“è¨ˆç®—é‡$O(\\log n)$  æœ¨ã®é«˜ã•ï¼ˆ=$\\log n$ï¼‰åˆ†call stack/stack/queueãŒä¼¸ã³ã‚‹ã‹ã‚‰    Morris traversalã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯æ™‚é–“è¨ˆç®—é‡$O(n)$ï¼Œç©ºé–“è¨ˆç®—é‡ã‚’$O(1)$ã§æœ¨ã‚’æ§‹æˆã™ã‚‹é ‚ç‚¹ã‚’é€šã‚ŠãŒã‘é †ã§å…¨æ¢ç´¢ã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼\nã€Œå·¦éƒ¨åˆ†æœ¨ã®å·¦ç«¯ã®è‘‰ãƒãƒ¼ãƒ‰ã«åˆ°é”ã™ã‚‹ã¾ã§ã«é–“ã«ï¼Œå·¦éƒ¨åˆ†æœ¨ã®å³ç«¯è‘‰ãƒãƒ¼ãƒ‰ã‹ã‚‰é€šã‚ŠãŒã‘é †ã§ç›´å¾Œã®é ‚ç‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ï¼ˆå³ã®å­ä¾›ã¨ã—ã¦ï¼‰å¼µã‚ŠãªãŒã‚‰æœ¨ã‚’é™ã‚Šã¦ã„ã£ã¦ï¼Œé™ã‚Šãã‚Œãªããªã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã²ãŸã™ã‚‰å³ã®å­ä¾›ã‚’ãŸã©ã£ã¦ã„ãã¨ï¼Œé€šã‚ŠãŒã‘é †ã«ãªã£ã¦ã‚‹ã€ã¨ã„ã†ã‚‚ã®ï¼\n   Morris Traversalã®æ¦‚è¦   æ¬¡ã«ç¤ºã™å…·ä½“ä¾‹ã§å‹•ä½œã‚’è¿½ã£ã¦ã„ãï¼\n   ã¾ãšé ‚ç‚¹0ã‹ã‚‰èµ°æŸ»ã‚’å§‹ã‚ã‚‹ï¼0ã«ã¯å·¦éƒ¨åˆ†æœ¨ãŒã‚ã‚‹ã®ã§ï¼Œ0ã®å·¦éƒ¨åˆ†æœ¨ã®å³ç«¯è‘‰ã‚’è¨ˆç®—ã™ã‚‹ã¨ä»Šå›ã¯é ‚ç‚¹9ï¼9ã®å³ã®å­ä¾›ã¨ã—ã¦0ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å¼µã£ã¦ãŠãï¼ã“ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å¾Œã§ãŸã©ã‚‹ã“ã¨ã§è¡ŒããŒã‘é †ã‚’é”æˆã™ã‚‹ï¼\n   0ã®å·¦éƒ¨åˆ†æœ¨ã¸é™ã‚Šã¦ã„ãï¼Œé™ã‚Šç«‹ã£ãŸé ‚ç‚¹ã‚’æ ¹ã¨ã—ãŸæœ¨ã®å·¦éƒ¨åˆ†æœ¨ãŒå­˜åœ¨ã™ã‚‹ã‚‹é™ã‚ŠåŒã˜ã‚ˆã†ã«ã€Œå·¦éƒ¨åˆ†æœ¨ã®å³ç«¯è‘‰ã‚’è¨ˆç®—ã—ã¦ï¼Œãã‚Œã®å³ã®å­ä¾›ã¨ã—ã¦æ ¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å¼µã‚‹ã€ã“ã¨ã‚’ç¹°ã‚Šè¿”ã™ï¼\n          å·¦éƒ¨åˆ†æ©ŸãŒå­˜åœ¨ã—ãªã„ï¼Œã¤ã¾ã‚Šå·¦ç«¯ã®è‘‰ã¾ã§é™ã‚ŠãŸã‚‰ï¼Œãã“ãŒè¡ŒããŒã‘é †ã®ä¸€ç•ªæœ€åˆã®é ‚ç‚¹ãªã®ã§å‡¦ç†ã‚’ã™ã‚‹ï¼ä»Šå›ã¯é ‚ç‚¹7ãŒãã‚Œï¼é ‚ç‚¹7ã‚’å‡¦ç†ã—ãŸã‚‰ï¼Œã•ã£ãå¼µã£ãŸ7ã®å³å­ãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ã£ã¦é·ç§»ã™ã‚‹ï¼ã“ã®ãƒã‚¤ãƒ³ã‚¿ã¯è¡ŒããŒã‘é †ã«ãŠã‘ã‚‹å·¦éƒ¨åˆ†æœŸã®å³ç«¯è‘‰ã¨ãã®ç›´å¾Œã®é ‚ç‚¹ã‚’çµã‚“ã§ã„ã‚‹ã®ã§æ­£ã—ãè¡ŒããŒã‘é †ã«é·ç§»ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼ä»Šå›ã®ä¾‹ã ã¨3ã¸èµ¤ã„ãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ã£ã¦é·ç§»ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼ã“ã®ã¨ãï¼Œé·ç§»ã—ãªãŒã‚‰èµ¤ã„ãƒã‚¤ãƒ³ã‚¿ã‚’å‰¥ãŒã™ï¼Œå…·ä½“çš„ã«ã¯7ã®å³å­ãƒã‚¤ãƒ³ã‚¿ã«Noneã‚’ã‚»ãƒƒãƒˆã™ã‚‹ï¼ã“ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã¯ã€Œãƒã‚¤ãƒ³ã‚¿ã‚’å¼µã‚ŠãªãŒã‚‰é·ç§»ã—ã¦ä¸è¦ã«ãªã£ãŸã‚‰ã™ãå‰¥ãŒã™ã€ã¨ã„ã†æŒ™å‹•ã«ãªã£ã¦ã„ã‚‹ï¼å…¨éƒ¨å¼µã£ã¦ã‹ã‚‰å‰¥ãŒã™ã®ã§ã¯ãªã„ã¨ã„ã†ç‚¹ã«æ³¨æ„ï¼\n   å³å­ãƒã‚¤ãƒ³ã‚¿ã§æ¬¡ã¸è¡Œãæ¬¡ã¸è¡Œãï¼\n   å·¦å­ãƒã‚¤ãƒ³ã‚¿ãŒã‚ã‚‹ãªã‚‰ï¼Œå·¦éƒ¨åˆ†æœ¨ãŒå­˜åœ¨ã™ã‚‹ã®ã§ï¼Œå·¦éƒ¨åˆ†æœŸã®å³ç«¯è‘‰é ‚ç‚¹ã‚’è¦‹ã¤ã‘ã¦è¡ŒããŒã‘é †ã«ãªã‚‹ãŸã‚ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å¼µã‚‹ä½œæ¥­ï¼ˆé ‚ç‚¹0/1/3ã§ã‚„ã£ã¦ããŸã®ã¨åŒã˜ã“ã¨ï¼‰ã‚’ã‚„ã‚‹ï¼\n   å·¦å­ãƒã‚¤ãƒ³ã‚¿ãŒãªã„ã¨ã„ã†ã“ã¨ã¯å·¦éƒ¨åˆ†æœ¨ãŒå­˜åœ¨ã—ãªã„ã®ã§ï¼Œå³å­ãƒã‚¤ãƒ³ã‚¿ã‚’ãŸã©ã‚‹ï¼\n                            ã“ã‚Œã‚’å®Ÿè£…ã™ã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ï¼\ndef morris(root): curr = root while curr is not None: if curr.left is not None: # å·¦éƒ¨åˆ†æœ¨ãŒå­˜åœ¨ã™ã‚‹ã®ã§ï¼Œå·¦éƒ¨åˆ†æœŸã®å³ç«¯è‘‰ãƒãƒ¼ãƒ‰ã‚’æ¢ã—ã«è¡Œã prev = curr.left while prev.right is not None and prev.right is not curr: prev = prev.right if prev.right is None: prev.right = curr # å³å­ãƒã‚¤ãƒ³ã‚¿ã§è¡ŒããŒã‘é †ç›´å¾Œã®é ‚ç‚¹ã‚’ç™»éŒ²ï¼ˆèµ¤çŸ¢å°ï¼‰ curr = curr.left # å·¦éƒ¨åˆ†æœ¨ã¸é™ã‚Šã¦ã„ã else: # ã™ã§ã«èµ¤çŸ¢å°ãŒå¼µã£ã¦ã‚ã‚‹ã¨ã„ã†ã“ã¨ã¯å·¦éƒ¨åˆ†æœ¨ã¯è¦‹çµ‚ã‚ã£ãŸã¨ã„ã†ã“ã¨ã«ãªã‚‹ prev.right = None # èµ¤çŸ¢å°ã‚’å‰¥ãŒã™ process(curr) curr = curr.right # å·¦éƒ¨åˆ†æœ¨ã‚’è¦‹çµ‚ã‚ã£ãŸã®ã§å³éƒ¨åˆ†æœ¨ã¸é™ã‚Šã¦ã„ã else: # curr.left is None process(curr) curr = curr.right # å·¦éƒ¨åˆ†æœ¨ãŒå­˜åœ¨ã—ãªã„ã®ã§å³éƒ¨åˆ†æœ¨ã¸é™ã‚Šã¦ã„ã ã‚„ã‚„è¤‡é›‘ï¼ã“ã‚Œã‚’ä½•ã‚‚è¦‹ãšã«æ›¸ã‘ã¨è¦æ±‚ã•ã‚Œã‚‹ã¨ã—ã‚“ã©ã„ï¼\nç·´ç¿’å•é¡Œ  https://leetcode.com/problems/sum-of-left-leaves/  # Morris traversalï¼šç©ºé–“è¨ˆç®—é‡O(1)ã§å…¨é ‚ç‚¹ã‚’in-orderã§æ¢ç´¢ã™ã‚‹ï¼ã‚¤ãƒ¡ãƒ¼ã‚¸ã¨ã—ã¦ã¯å·¦éƒ¨åˆ†æœ¨ã®å³ç«¯ã‹ã‚‰æ ¹ã¸ã®ä¸€æ™‚çš„ãªãƒã‚¤ãƒ³ã‚¿ã‚’ä½œã‚ŠãªãŒã‚‰æœ¨ã‚’ä¸‹ã«é™ã‚Šã¦ã„ãï¼Œè‘‰ãƒãƒ¼ãƒ‰ã«åˆ°é”ã—ãŸã‚‰ãã“ã‹ã‚‰å³ã¸å³ã¸é€²ã‚“ã§ã„ãã¨in-orderã«ãªã£ã¦ã„ã‚‹ï¼å³ã¸å³ã¸é€²ã‚€é€”ä¸­ã§ä¸€æ™‚çš„ã«å¼µã£ãŸãƒã‚¤ãƒ³ã‚¿ã‚’æ¶ˆã—ãªãŒã‚‰é€²ã‚€ï¼ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumOfLeftLeaves(self, root: TreeNode) -\u0026gt; int: ans = 0 while root is not None: if root.left is not None: prev = root.left while prev.right is not None and prev.right is not root: prev = prev.right if prev.right is None: # in-orderé †ã§rootã®ç›´å‰ã®ãƒãƒ¼ãƒ‰ãŒprevã«ãªã£ã¦ã„ã‚‹ prev.right = root # ä¸€æ™‚çš„ãªãƒªãƒ³ã‚¯ã‚’å¼µã‚‹ root = root.left else: prev.right = None # ã“ã“ã§ä¸€æ™‚çš„ã«å¼µã£ãŸãƒªãƒ³ã‚¯ã‚’æ¶ˆã—ã¦ã‚‹ if prev is root.left and prev.left is None: ans += prev.val root = root.right else: # ã“ã“ã«å…¥ã‚Šè¾¼ã‚€æ™‚ç‚¹ã§rootã¯å·¦ç«¯ã®è‘‰ãƒãƒ¼ãƒ‰ root = root.right return ans ","date":1646914791,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1646914791,"objectID":"9cf5d397e4a1c03d8986b4d734c7bb75","permalink":"/ja/post/morris-traversal/","publishdate":"2022-03-10T21:19:51+09:00","relpermalink":"/ja/post/morris-traversal/","section":"post","summary":"äºŒåˆ†æœ¨ä¸Šã®æ¢ç´¢ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹äºŒåˆ†æœ¨ã‚’è€ƒãˆã‚‹ï¼ class: TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ã‚ã‚‹äºŒåˆ†æœ¨rootãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼Œãã®æœ¨ã‚’æ§‹æˆã™ã‚‹é ‚ç‚¹","tags":[],"title":"Morris Traversal","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ å¤§å°é–¢ä¿‚ãŒã‚ã‚‹ä½ç½®ã‚’å¢ƒã«é€†è»¢ã™ã‚‹æ•´æ•°é…åˆ—ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ãƒ”ãƒ¼ã‚¯ã¨ãªã‚‹è¦ç´ ã‚’æ±‚ã‚ã‚ˆï¼\nè§£æ³• ã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ã«è½ã¨ã—è¾¼ã‚€ï¼\n# ã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ def binary_search(arr): def is_ok(mid): return True # æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹åˆ¤å®šã—ã¦boolå€¤ã‚’è¿”ã™ ng = XXX # çµ¶å¯¾ã«æ¡ä»¶ã‚’æº€ãŸã•ãªã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ok = YYY # çµ¶å¯¾ã«æ¡ä»¶ã‚’æº€ãŸã™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ while 1 \u0026lt; abs(ng - ok): mid = (ok + ng) \u0026gt;\u0026gt; 1 if is_ok(mid): ok = mid else: ng = mid return ok ã‚ã‚‹ä½ç½®ä»¥é™ã§æˆå¦ãŒä¸€è²«ã™ã‚‹æ¡ä»¶ã‚’is_ok(mid)ã§æ›¸ã‘ã‚‹ã¨ç°¡å˜ã«è§£ã‘ã‚‹ï¼ä»Šå›ã®å•é¡Œã§ã¯ï¼Œé ‚ç‚¹ã¨ãªã‚‹ä½ç½®ä»¥é™ã§é™é †ã«ãªã‚‹ã®ã§æ¡ä»¶ã¯\n arr[mid] \u0026lt; arr[mid+1]  ãªãŠï¼Œmid+1ãŒã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ãªã„ã‚ˆã†ã«ãã“ã ã‘æ¡ä»¶åˆ†å²ã—ã¦ãŠãã“ã¨ã«æ³¨æ„ï¼\nclass Solution: def peakIndexInMountainArray(self, arr: List[int]) -\u0026gt; int: def is_ok(mid): if mid == len(arr) - 1: return True return arr[mid] \u0026gt; arr[mid + 1] ng = -1 ok = len(arr) while 1 \u0026lt; abs(ng - ok): mid = (ng + ok) \u0026gt;\u0026gt; 1 if is_ok(mid): ok = mid else: ng = mid return ok å‡ºå…¸  https://leetcode.com/problems/peak-index-in-a-mountain-array/  ","date":1646888937,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1646888937,"objectID":"9e6de2d96857300472649de9dcd54d63","permalink":"/ja/post/peak-index-in-a-mountain-array/","publishdate":"2022-03-10T14:08:57+09:00","relpermalink":"/ja/post/peak-index-in-a-mountain-array/","section":"post","summary":"å•é¡Œ å¤§å°é–¢ä¿‚ãŒã‚ã‚‹ä½ç½®ã‚’å¢ƒã«é€†è»¢ã™ã‚‹æ•´æ•°é…åˆ—ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ãƒ”ãƒ¼ã‚¯ã¨ãªã‚‹è¦ç´ ã‚’æ±‚ã‚ã‚ˆï¼ è§£æ³• ã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ã«è½ã¨ã—è¾¼ã‚€ï¼ # ã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ def binary_search(arr):","tags":[],"title":"Peak Index in a Mountain Array","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹é€£çµãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼\n# Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ä¸ãˆã‚‰ã‚ŒãŸé€£çµãƒªã‚¹ãƒˆãŒå›åˆ†ã«ãªã£ã¦ã„ã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼\nè§£æ³•  å›åˆ†ã«ãªã£ã¦ã„ã‚‹ã‹ã‚’çŸ¥ã‚‹ãŸã‚ã«ã¯ã¨ã‚Šã‚ãˆãšçœŸã‚“ä¸­ãŒã»ã—ã„ã®ã§ï¼ŒğŸ°ã¨ğŸ¢ãŒä½¿ãˆã‚‹  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def isPalindrome(self, head: Optional[ListNode]) -\u0026gt; bool: if head is None: return None faster = head slower = head while faster is not None and faster.next is not None: faster = faster.next.next slower = slower.next stack = [] while slower is not None: stack.append(slower.val) slower = slower.next current = head while len(stack) != 0: if stack.pop() != current.val: return False current = current.next return True å‡ºå…¸  https://leetcode.com/problems/palindrome-linked-list/  ","date":1645530637,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1645530637,"objectID":"df764ca73c9dc558b71bfac06e0fe25f","permalink":"/ja/post/palindrome-linked-list/","publishdate":"2022-02-22T20:50:37+09:00","relpermalink":"/ja/post/palindrome-linked-list/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹é€£çµãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ # Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ä¸ãˆã‚‰ã‚ŒãŸé€£çµãƒªã‚¹ãƒˆãŒå›åˆ†ã«ãªã£ã¦ã„ã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼ è§£æ³• å›åˆ†","tags":[],"title":"Palindrome Linked List","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹é€£çµãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼ŒçœŸã‚“ä¸­ã®å€¤ã¯ãªã«ã‹è¨ˆç®—ã™ã‚‹é–¢æ•°ã‚’æ›¸ã‘ï¼\n# Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ä¾‹\nhead = [1] -\u0026gt; [2] -\u0026gt; [3] -\u0026gt; [4] -\u0026gt; [5], ans = [3] -\u0026gt; [4] -\u0026gt; [5] head = [1] -\u0026gt; [2] -\u0026gt; [3] -\u0026gt; [4] -\u0026gt; [5] -\u0026gt; [6], ans = [4] -\u0026gt; [5] -\u0026gt; [6] è§£æ³•  ğŸ°ã¨ğŸ¢ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯  äºŒå€ã®é€Ÿåº¦ã§å‹•ãğŸ°ã‚’ç«¯ã¾ã§èµ°ã‚‰ã›ã‚‹ã¨ğŸ¢ã¯çœŸã‚“ä¸­ãã‚‰ã„ã«ã¾ã ã„ã‚‹   whileã®ãƒ«ãƒ¼ãƒ—ã®æ¡ä»¶ã¯ï¼Œãƒ«ãƒ¼ãƒ—å†…éƒ¨ã®å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãªã„æ¡ä»¶ã‚’è€ƒãˆã‚Œã°è‰¯ã„ï¼  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def middleNode(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: if head == None: return [] faster = head slower = head while faster is not None and faster.next is not None: faster = faster.next.next slower = slower.next return slower å‡ºå…¸  https://leetcode.com/problems/middle-of-the-linked-list/  ","date":1645529830,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1645529830,"objectID":"c93aa224b0787a0e5a1436604ac99f22","permalink":"/ja/post/middle-of-the-linked-list/","publishdate":"2022-02-22T20:37:10+09:00","relpermalink":"/ja/post/middle-of-the-linked-list/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹é€£çµãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼ŒçœŸã‚“ä¸­ã®å€¤ã¯ãªã«ã‹è¨ˆç®—ã™ã‚‹é–¢æ•°ã‚’æ›¸ã‘ï¼ # Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ä¾‹ head = [1] -\u0026gt; [2] -\u0026gt;","tags":[],"title":"Middle of the Linked List","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹é€£çµãƒªã‚¹ãƒˆã«å¯¾ã—ã¦ï¼ŒæŒ‡å®šã•ã‚ŒãŸè¦ç´ ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°ã‚’æ›¸ã‘ï¼\n# Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next é–¢æ•°ã®å¼•æ•°ã¨è¿”ã‚Šå€¤ã¯æ¬¡ã®é€šã‚Šï¼\ndef removeElements(self, head: Optional[ListNode], val: int) -\u0026gt; Optional[ListNode]: pass ä¾‹ï¼š\nhead = [1] -\u0026gt; [2] -\u0026gt; [6] -\u0026gt; [3] -\u0026gt; [4] -\u0026gt; [5] -\u0026gt; [6] val = 6 ans = [1] -\u0026gt; [2] -\u0026gt; [3] -\u0026gt; [4] -\u0026gt; [5] -\u0026gt; [6] è§£æ³•  å˜é€£çµãƒªã‚¹ãƒˆã¯ã€Œ1ã¤æ¬¡ã€ãŒè¿½ãˆã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€   ã¤ã¾ã‚ŠcurrãŒã‚ã‚Œã°curr.nextãŒå–ã‚Œã‚‹ï¼ˆå½“ãŸã‚Šå‰ï¼‰ ãã®ä»£ã‚ã‚Š1ã¤å‰ãŒå–ã‚Œãªã„ã®ã§ï¼Œè¿½è·¡ã—ãŸã„ãªã‚‰ãã‚Œç”¨ã®å¤‰æ•°ã‚’ç”¨æ„ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹   å˜é€£çµãƒªã‚¹ãƒˆã§ã®è¦ç´ ã®å‰Šé™¤ã¯ï¼Œã€Œcurrã‚’å‰Šé™¤ã—ãŸã„ãªã‚‰ï¼Œprevã®æ¬¡ã‚’ï¼ˆcurrã‚’é£›ã°ã—ã¦ï¼‰curr.nextã«ã™ã‚‹ã€ã§å®Ÿç¾ã•ã‚Œã‚‹ 1ã¤å‰ã‚’è¿½è·¡ã—ãŸã„ã®ã§prevã‚’è€ƒãˆã‚‹ãŒï¼Œheadã®1ã¤å‰ã¯ã©ã†ã—ã‚ˆã†ã‹ï¼Œã¨ãªã‚Šï¼Œdummy_headã‚’ç”¨æ„ã™ã‚Œã°ã„ã„ã˜ã‚ƒãªã„ã‹ï¼Œã¨è‡³ã‚‹ï¼  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeElements(self, head: Optional[ListNode], val: int) -\u0026gt; Optional[ListNode]: if head is None: return None dummy_head = ListNode(val=-1, next=head) prev = dummy_head curr = head while curr is not None: if curr.val == val: prev.next = curr.next curr = curr.next else: curr = curr.next prev = prev.next return dummy_head.next å‡ºå…¸  https://leetcode.com/problems/remove-linked-list-elements/  ","date":1645529212,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1645529212,"objectID":"36a5b8cb10d358ea221bb67a64a54b3b","permalink":"/ja/post/remove-linked-list-elements/","publishdate":"2022-02-22T20:26:52+09:00","relpermalink":"/ja/post/remove-linked-list-elements/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹é€£çµãƒªã‚¹ãƒˆã«å¯¾ã—ã¦ï¼ŒæŒ‡å®šã•ã‚ŒãŸè¦ç´ ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°ã‚’æ›¸ã‘ï¼ # Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next é–¢æ•°ã®å¼•æ•°ã¨è¿”ã‚Šå€¤ã¯æ¬¡ã®é€š","tags":[],"title":"Remove Linked List Elements","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ é…åˆ—numsã¨æ•´æ•°targetãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼numsã‚’æ˜‡é †ã«æ•´åˆ—ã—ãŸã¨ãã«nums[i] == targetã‚’æº€ãŸã™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹iã‚’ã™ã¹ã¦æ±‚ã‚ã‚ˆï¼\nnums = [1, 2, 5, 2, 3], target = 2 -\u0026gt; sorted nums = [1, 2, 2, 3, 5] -\u0026gt; ans = [1, 2] è§£æ³•1 è¨€ã‚ã‚ŒãŸã¨ãŠã‚Šã«ã‚½ãƒ¼ãƒˆã—ã¦ã‹ã‚‰ä½ç½®ã‚’æ¢ã™ï¼ã‚½ãƒ¼ãƒˆã«æ™‚é–“ãŒã‹ã‹ã£ã¦$O(n \\log n)$\nclass Solution: def targetIndices(self, nums: List[int], target: int) -\u0026gt; List[int]: nums.sort() ans = [] for i, num in enumerate(nums): if num == target: ans.append(i) return ans è§£æ³•2 æ•´åˆ—å¾Œã®é…åˆ—ã«ç½®ã„ã¦ï¼Œtargetã¨ç­‰ã—ã„è¦ç´ ã®ä½ç½®ã‚’æ±ºå®šã™ã‚‹ã®ã«ï¼Œtargetã‚ˆã‚Šå¤§ãã„è¦ç´ ãŒæ•´åˆ—ã•ã‚Œã¦ã„ã‚‹å¿…è¦ã¯ãªã„ï¼ã€Œtargetã‚ˆã‚Šå°ã•ã„å€¤ãŒä½•å€‹ã‚ã‚‹ã®ã‹ã€ã¨ã€Œtargetã¨ç­‰ã—ã„å€¤ãŒä½•å€‹ã‚ã‚‹ã®ã‹ã€ã§ç­”ãˆã¯æ±‚ã¾ã‚‹ï¼\nnumsã‚’ç«¯ã‹ã‚‰ä¸€èˆã‚ã™ã‚Œã°ååˆ†ã§$O(n)$\nclass Solution: def targetIndices(self, nums: List[int], target: int) -\u0026gt; List[int]: cnt = 0 less = 0 for num in nums: if num == target: cnt += 1 elif num \u0026lt; target: less += 1 ans = [] for i in range(cnt): ans.append(less + i) return ans å‡ºå…¸  https://leetcode.com/problems/find-target-indices-after-sorting-array/  ","date":1644481389,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1644481389,"objectID":"d6b9d1b9a0b216cfbfc61590161e0637","permalink":"/ja/post/find-target-indices-after-sorting-array/","publishdate":"2022-02-10T17:23:09+09:00","relpermalink":"/ja/post/find-target-indices-after-sorting-array/","section":"post","summary":"å•é¡Œ é…åˆ—numsã¨æ•´æ•°targetãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼numsã‚’æ˜‡é †ã«æ•´åˆ—ã—ãŸã¨ãã«nums[i] == targetã‚’æº€ãŸã™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹iã‚’ã™ã¹ã¦æ±‚ã‚","tags":[],"title":"Find Target Indices After Sorting Array","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ happy numberã‚’æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã™ã‚‹\n å„æ¡ã®äºŒä¹—å’Œã‚’å–ã‚‹æ“ä½œã‚’ç¹°ã‚Šè¿”ã—ãŸã¨ãã«ç¹°ã‚Šè¿”ã—åŒã˜æ•°å­—ãŒç™»å ´ã™ã‚‹ã“ã¨ãªã1ã§çµ‚ã‚ã‚‹  ä¸ãˆã‚‰ã‚ŒãŸæ­£ã®æ•´æ•°nãŒhappy numberã§ã‚ã‚‹ã‹ã©ã†ã‹åˆ¤å®šã›ã‚ˆï¼\nn = 19 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 -\u0026gt; 19 is happy number! è§£æ³• ã€Œå„æ¡ã®äºŒä¹—å’Œã‚’å–ã‚‹æ“ä½œã€ã§ã®å…¥å‡ºåŠ›ã®é–¢ä¿‚ã¯éš£æ¥ãƒªã‚¹ãƒˆã®ã‚ˆã†ã«è¡¨ç¾ã§ãã¦ï¼Œãã®ãƒªã‚¹ãƒˆãŒå¾ªç’°ã‚’å«ã‚€ã®ã‹ã‚’åˆ¤å®šã™ã‚Œã°è‰¯ã„ï¼\n1ã¯å„æ¡ã®äºŒä¹—å’Œã‚’å–ã£ã¦ã‚‚1ã«æˆ»ã‚‹ã“ã¨ã«æ³¨æ„ï¼\nclass Solution: def isHappy(self, n: int) -\u0026gt; bool: def calc_next(n): total = 0 while 0 \u0026lt; n: n, d = divmod(n, 10) total += d * d return total slower = n faster = calc_next(n) # ãƒ«ãƒ¼ãƒ—ã®æ¡ä»¶ã‚’ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«fasterã‚’1ã¤é€²ã‚ã¦ãŠã while slower != faster and faster != 1: slower = calc_next(slower) faster = calc_next(calc_next(faster))ã€€return faster == 1 å‡ºå…¸  https://leetcode.com/problems/happy-number/  ","date":1644480598,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1644480598,"objectID":"000145572c340c0798dff0d68c8a578d","permalink":"/ja/post/happy-number/","publishdate":"2022-02-10T17:09:58+09:00","relpermalink":"/ja/post/happy-number/","section":"post","summary":"å•é¡Œ happy numberã‚’æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã™ã‚‹ å„æ¡ã®äºŒä¹—å’Œã‚’å–ã‚‹æ“ä½œã‚’ç¹°ã‚Šè¿”ã—ãŸã¨ãã«ç¹°ã‚Šè¿”ã—åŒã˜æ•°å­—ãŒç™»å ´ã™ã‚‹ã“ã¨ãªã1ã§çµ‚ã‚ã‚‹ ä¸ãˆã‚‰ã‚ŒãŸæ­£ã®æ•´æ•°","tags":[],"title":"Happy Number","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚ŒãŸéš£æ¥ãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®ãƒªã‚¹ãƒˆãŒå¾ªç’°ã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆ\n# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None è§£æ³• ã†ã•ãã¨ã‹ã‚ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ï¼\nclass Solution: def hasCycle(self, head: Optional[ListNode]) -\u0026gt; bool: if head is None: return False faster = head slower = head while faster.next is not None and faster.next.next is not None: faster = faster.next.next # ã†ã•ãã¯äºŒæ­©é€²ã‚€ slower = slower.next # ã‹ã‚ã¯ä¸€æ­©é€²ã‚€ if faster is slower: return True # å¾ªç’°ã—ã¦ã„ã‚Œã°ã©ã“ã‹ã§å¿…ãšè¿½ã„ã¤ã return False å‡ºå…¸  https://leetcode.com/problems/linked-list-cycle/  ","date":1644480392,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1644480392,"objectID":"78a62d02863418085a119863b9e36578","permalink":"/ja/post/linked-list-cycle/","publishdate":"2022-02-10T17:06:32+09:00","relpermalink":"/ja/post/linked-list-cycle/","section":"post","summary":"å•é¡Œ æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚ŒãŸéš£æ¥ãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®ãƒªã‚¹ãƒˆãŒå¾ªç’°ã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆ # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None è§£æ³• ã†ã•ãã¨ã‹ã‚ãƒ†ã‚¯","tags":[],"title":"Linked List Cycle","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ–‡å­—åˆ—wordãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼æ¯éŸ³ï¼ˆaï¼Œeï¼Œiï¼Œoï¼Œuï¼‰é£²ã¿ã‹ã‚‰ãªã‚‹é€£ç¶šã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã®å€‹æ•°ã‚’æ•°ãˆä¸Šã’ã‚ˆï¼\nword = \u0026quot;aeiouu\u0026quot; -\u0026gt; ans = 2 (\u0026quot;aeiou\u0026quot;, \u0026quot;aeiouu\u0026quot;) è§£æ³• ã—ã‚ƒãã¨ã‚Šæ³•ï¼æ•°ãˆä¸Šã’å¯¾è±¡ã®éƒ¨åˆ†åˆ—ã¯é€£ç¶šã—ãŸéƒ¨åˆ†åˆ—ã«ãªã‚‹ã®ã§ï¼Œä¸¡ç«¯ã‚’ç®¡ç†ã—ãªãŒã‚‰æ•°ãˆã‚‹ï¼\nclass Solution: def countVowelSubstrings(self, word: str) -\u0026gt; int: freq = {\u0026#39;a\u0026#39;: 0, \u0026#39;e\u0026#39;: 0, \u0026#39;i\u0026#39;: 0, \u0026#39;o\u0026#39;: 0, \u0026#39;u\u0026#39;: 0} left = 0 head = 0 vowel_kind = 0 ans = 0 N = len(word) for right in range(N): if word[right] in freq: v = word[right] if freq[v] == 0: vowel_kind += 1 freq[v] += 1 while vowel_kind == 5: h = word[head] freq[h] -= 1 if freq[h] == 0: vowel_kind -= 1 head += 1 ans += (head - left) else: freq = {\u0026#39;a\u0026#39;: 0, \u0026#39;e\u0026#39;: 0, \u0026#39;i\u0026#39;: 0, \u0026#39;o\u0026#39;: 0, \u0026#39;u\u0026#39;: 0} left = right + 1 head = right + 1 vowel_kind = 0 return ans rightã‚’å³ã«å‹§ã‚ãªãŒã‚‰ï¼Œ\n å­éŸ³ã«ã¶ã¤ã‹ã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ æ¯éŸ³ã«ã¶ã¤ã‹ã£ãŸã‚‰  è¦³æ¸¬ã—ãŸæ¯éŸ³ã‚’é »åº¦è¡¨ã«è¿½åŠ  5ç¨®ã®æ¯éŸ³ã‚’è¦³æ¸¬æ¸ˆã¿ãªã‚‰æ•°ãˆä¸Šã’é–‹å§‹  ã€Œè¦³æ¸¬æ¸ˆã¿æ¯éŸ³ç¨®ãŒ5ã€ã‚’æº€ãŸã•ãªããªã‚‹ã¾ã§headã‚’å³ã«å‹•ã‹ã™ï¼ˆå‹•ã‹ã›ã‚‹ã ã‘æ•°ãˆä¸Šã’å¯¾è±¡ã®éƒ¨åˆ†åˆ—ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã«ï¼‰ headã‚’å‹•ã‹ã›ãªããªã£ãŸã¨ã“ã‚ã§éƒ¨åˆ†åˆ—ã®æ•°ã‚’æ•°ãˆã¦è¨˜éŒ²      å‡ºå…¸  https://leetcode.com/problems/count-vowel-substrings-of-a-string/  ","date":1643886078,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643886078,"objectID":"e76dbd91579288e327c15b82e4503005","permalink":"/ja/post/count-vowel-substrings-of-a-string/","publishdate":"2022-02-03T20:01:18+09:00","relpermalink":"/ja/post/count-vowel-substrings-of-a-string/","section":"post","summary":"å•é¡Œ æ–‡å­—åˆ—wordãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼æ¯éŸ³ï¼ˆaï¼Œeï¼Œiï¼Œoï¼Œuï¼‰é£²ã¿ã‹ã‚‰ãªã‚‹é€£ç¶šã—ãŸéƒ¨åˆ†æ–‡å­—åˆ—ã®å€‹æ•°ã‚’æ•°ãˆä¸Šã’ã‚ˆï¼ word = \u0026quot;aeiouu\u0026quot; -\u0026gt; ans = 2 (\u0026quot;aeiou\u0026quot;, \u0026quot;aeiouu\u0026quot;) è§£æ³• ã—ã‚ƒãã¨ã‚Š","tags":[],"title":"Count Vowel Substrings of a String","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ–‡å­—åˆ—sãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼åŒç¨®ã®æ–‡å­—ãŒé€£ç¶šã™ã‚‹éƒ¨åˆ†ã®ã†ã¡ï¼Œé•·ã•ãŒ3ä»¥ä¸Šã®ç®‡æ‰€ã‚’ã™ã¹ã¦å–ã‚Šå‡ºã›ï¼\ns = \u0026quot;abbxxxxzyy\u0026quot; -\u0026gt; [[3, 6]] (\u0026quot;xxxx\u0026quot;) è§£æ³• ã—ã‚ƒãã¨ã‚Šæ³•ï¼ä¼¸ã°ã›ã‚‹ã¨ã“ã‚ã¾ã§rightã‚’ä¼¸ã°ã—ã¦ï¼Œæ¡ä»¶ã‚’æº€ãŸã•ãªããªã£ãŸã‚‰leftã‚’right+1ã¾ã§ä¸€æ°—ã«æ›´æ–°ã™ã‚‹ï¼\nclass Solution: def largeGroupPositions(self, s: str) -\u0026gt; List[List[int]]: ans = [] if len(s) == 1: return ans left = 0 for right in range(1, len(s)+1, 1): if right == len(s) or s[left] != s[right]: if right - left \u0026gt;= 3: ans.append([left, right-1]) left = right return ans å‡ºå…¸  https://leetcode.com/problems/positions-of-large-groups/  ","date":1643885812,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643885812,"objectID":"fdefc7b17336bf402d00cf39c7d6e2d4","permalink":"/ja/post/position-of-large-groups/","publishdate":"2022-02-03T19:56:52+09:00","relpermalink":"/ja/post/position-of-large-groups/","section":"post","summary":"å•é¡Œ æ–‡å­—åˆ—sãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼åŒç¨®ã®æ–‡å­—ãŒé€£ç¶šã™ã‚‹éƒ¨åˆ†ã®ã†ã¡ï¼Œé•·ã•ãŒ3ä»¥ä¸Šã®ç®‡æ‰€ã‚’ã™ã¹ã¦å–ã‚Šå‡ºã›ï¼ s = \u0026quot;abbxxxxzyy\u0026quot; -\u0026gt; [[3, 6]] (\u0026quot;xxxx\u0026quot;) è§£æ³• ã—ã‚ƒãã¨ã‚Šæ³•ï¼ä¼¸ã°ã›ã‚‹ã¨ã“ã‚","tags":[],"title":"Position of Large Groups","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ–‡å­—åˆ—sã¨æ–‡å­—cãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼æ¬¡ã®ã‚ˆã†ãªæ•´æ•°é…åˆ—answerã‚’è¿”ã›\n len(answer) == len(s) answer[i]ã¯ä½ç½®iã‹ã‚‰æœ€ã‚‚è¿‘ã„cã¾ã§ã®è·é›¢ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å·®ã®çµ¶å¯¾å€¤ï¼‰  s = \u0026quot;loveleetcode\u0026quot;, c = \u0026quot;e\u0026quot; -\u0026gt; [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] è§£æ³• å„iã«ã¤ã„ã¦ï¼Œå·¦å³ã‚’è¦‹ã¦è¿‘ã„cã‚’æ¢ã›ã°è‰¯ã„ã®ã ãŒï¼Œã“ã‚Œã‚’ãã®ã¾ã¾æ›¸ãã®ã§ã¯ãªãï¼Œ\n å„iã®å·¦å´ã‚’ã¾ãšè¦‹ã‚‹ æ¬¡ã«å„iã®å³å´ã‚’è¦‹ã‚‹  ã¨æ›¸ãã¨ã‚ˆã„ï¼\n \u0026quot;l o v e l e e t c o d e\u0026quot; (c = \u0026quot;e\u0026quot;) -\u0026gt;) inf inf inf 0 1 0 0 1 2 3 4 0 3 2 1 0 1 0 0 4 3 2 1 0 (\u0026lt;- ------------------------------------------------ -\u0026gt; [ 3 2 1 0 1 0 0 1 2 2 1 0] (min) class Solution: def shortestToChar(self, s: str, c: str) -\u0026gt; List[int]: N = len(s) ans = [] prev = float(\u0026#34;-inf\u0026#34;) for i in range(0, N, 1): if s[i] == c: prev = i ans.append(i - prev) prev = float(\u0026#34;+inf\u0026#34;) for i in range(N-1, -1, -1): if s[i] == c: prev = i ans[i] = min(ans[i], prev - i) return ans å‡ºå…¸  https://leetcode.com/problems/shortest-distance-to-a-character/  ","date":1643880624,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643880624,"objectID":"c9447eace9970c6fa47e41f9f2ec1a88","permalink":"/ja/post/shortest-distance-to-a-character/","publishdate":"2022-02-03T18:30:24+09:00","relpermalink":"/ja/post/shortest-distance-to-a-character/","section":"post","summary":"å•é¡Œ æ–‡å­—åˆ—sã¨æ–‡å­—cãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼æ¬¡ã®ã‚ˆã†ãªæ•´æ•°é…åˆ—answerã‚’è¿”ã› len(answer) == len(s) answer[i]ã¯ä½ç½®iã‹ã‚‰æœ€ã‚‚è¿‘ã„cã¾ã§ã®è·é›¢ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹","tags":[],"title":"Shortest Distance to a Character","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ 2æ–‡s1ï¼Œs2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ç‰‡æ–¹ã®æ–‡ã«ä¸€åº¦ã ã‘ç™»å ´ã™ã‚‹å˜èªã®ãƒªã‚¹ãƒˆã‚’è¿”ã™é–¢æ•°ã‚’å®Ÿè£…ã›ã‚ˆï¼\ns1 = \u0026quot;this apple is sweet\u0026quot; s2 = \u0026quot;this apple is sour\u0026quot; -\u0026gt; [\u0026quot;sweet\u0026quot;,\u0026quot;sour\u0026quot;] è§£æ³• ç‰‡æ–¹ã«ä¸€åº¦ã ã‘ç™»å ´ã™ã‚‹å˜èªã¯å…¨ä½“ã§ã‚‚ä¸€åº¦ã ã‘ã—ã‹ç™»å ´ã—ãªã„ï¼\nclass Solution: def uncommonFromSentences(self, s1: str, s2: str) -\u0026gt; List[str]: s = s1 + \u0026#34; \u0026#34; + s2 freq = Counter(s.split()) ans = [] for k, v in freq.items(): if v == 1: ans.append(k) return ans å‡ºå…¸  https://leetcode.com/problems/uncommon-words-from-two-sentences/  ","date":1643879749,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643879749,"objectID":"85fce1b45c5768d9969726a49846a1ee","permalink":"/ja/post/uncommon-words-from-two-sentences/","publishdate":"2022-02-03T18:15:49+09:00","relpermalink":"/ja/post/uncommon-words-from-two-sentences/","section":"post","summary":"å•é¡Œ 2æ–‡s1ï¼Œs2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ç‰‡æ–¹ã®æ–‡ã«ä¸€åº¦ã ã‘ç™»å ´ã™ã‚‹å˜èªã®ãƒªã‚¹ãƒˆã‚’è¿”ã™é–¢æ•°ã‚’å®Ÿè£…ã›ã‚ˆï¼ s1 = \u0026quot;this apple is sweet\u0026quot; s2 = \u0026quot;this apple is sour\u0026quot; -\u0026gt; [\u0026quot;sweet\u0026quot;,\u0026quot;sour\u0026quot;] è§£æ³• ç‰‡æ–¹ã«ä¸€åº¦ã ã‘ç™»","tags":[],"title":"Uncommon Words From Two Sentences","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ–‡å­—åˆ—ã‚’æ ¼ç´ã™ã‚‹é…åˆ—words1ï¼Œwords2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã©ã¡ã‚‰ã«ã‚‚ä¸€åº¦ã ã‘ç™»å ´ã™ã‚‹æ–‡å­—åˆ—ã®å€‹æ•°ã‚’æ±‚ã‚ã‚ˆï¼\nwords1 = [\u0026quot;leetcode\u0026quot;,\u0026quot; is\u0026quot;, \u0026quot;amazing\u0026quot;, \u0026quot;as\u0026quot;, \u0026quot;is\u0026quot;] words2 = [\u0026quot;amazing\u0026quot;, \u0026quot;leetcode\u0026quot;, \u0026quot;is\u0026quot;] -\u0026gt; 2 (\u0026quot;leetcode\u0026quot;, \u0026quot;amazing\u0026quot;) è§£æ³• words1ã§ä¸€åº¦ã—ã‹ç™»å ´ã—ãªã„æ–‡å­—åˆ—ãŒç¢ºã‹ã«words2ã§ã‚‚ä¸€åº¦ã—ã‹ç™»å ´ã—ãªã„ã‹ã‚’ç¢ºèªã™ã‚Œã°ã„ã„ï¼\nclass Solution: def countWords(self, words1: List[str], words2: List[str]) -\u0026gt; int: freq = Counter(words1) for word in words2: if freq[word] \u0026lt;= 1: freq[word] -= 1 return sum(1 for v in freq.values() if v == 0) å‡ºå…¸  https://leetcode.com/problems/count-common-words-with-one-occurrence/  ","date":1643879192,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643879192,"objectID":"bfc53949d797cdea1c36c059a4e9f3fc","permalink":"/ja/post/count-common-words-with-one-occurrence/","publishdate":"2022-02-03T18:06:32+09:00","relpermalink":"/ja/post/count-common-words-with-one-occurrence/","section":"post","summary":"å•é¡Œ æ–‡å­—åˆ—ã‚’æ ¼ç´ã™ã‚‹é…åˆ—words1ï¼Œwords2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã©ã¡ã‚‰ã«ã‚‚ä¸€åº¦ã ã‘ç™»å ´ã™ã‚‹æ–‡å­—åˆ—ã®å€‹æ•°ã‚’æ±‚ã‚ã‚ˆï¼ words1 = [\u0026quot;leetcode\u0026quot;,\u0026quot; is\u0026quot;, \u0026quot;amazing\u0026quot;, \u0026quot;as\u0026quot;, \u0026quot;is\u0026quot;] words2 = [\u0026quot;amazing\u0026quot;, \u0026quot;leetcode\u0026quot;, \u0026quot;is\u0026quot;] -\u0026gt; 2","tags":[],"title":"Count Common Words With One Occurrence","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ•´æ•°é…åˆ—timeãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼time[i]ã¯iç•ªç›®ã®æ­Œã®é•·ã•ã‚’è¡¨ã—ã¦ã„ã‚‹ï¼ç•°ãªã‚‹æ­ŒåŒå£«ã®çµ„ã¿åˆã‚ã›ã§ï¼Œãã®é•·ã•ã®åˆè¨ˆãŒ60ã§å‰²ã‚Šåˆ‡ã‚Œã‚‹ã‚ˆã†ãªãƒšã‚¢ã®æ•°ã‚’æ±‚ã‚ã‚ˆï¼\ntimes = [30, 20, 150, 100, 40] -\u0026gt; ans = 3 (30 + 150, 20 + 100, 20 + 40) è§£æ³• 2Sumå•é¡Œã®ã²ã­ã£ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ç›¸æ–¹ãŒã„ã‚‹ã‹ã‚’ãƒ¡ãƒ¢ã£ã¦ãŠã‘ã°äºŒé‡ãƒ«ãƒ¼ãƒ—ã‚’å›é¿ã—ã¦$O(n)$ã§æ¸ˆã‚€ï¼\nclass Solution: def numPairsDivisibleBy60(self, time: List[int]) -\u0026gt; int: memo = [0 for _ in range(60)] ans = 0 for t in time: ans += memo[(60 - t % 60) % 60] memo[t % 60] += 1 return ans å‡ºå…¸  https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/  ","date":1643878339,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643878339,"objectID":"0c093417a1b678aa87363febce4a55cb","permalink":"/ja/post/pairs-of-songs-with-total-duration-divisible-by-60/","publishdate":"2022-02-03T17:52:19+09:00","relpermalink":"/ja/post/pairs-of-songs-with-total-duration-divisible-by-60/","section":"post","summary":"å•é¡Œ æ•´æ•°é…åˆ—timeãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼time[i]ã¯iç•ªç›®ã®æ­Œã®é•·ã•ã‚’è¡¨ã—ã¦ã„ã‚‹ï¼ç•°ãªã‚‹æ­ŒåŒå£«ã®çµ„ã¿åˆã‚ã›ã§ï¼Œãã®é•·ã•ã®åˆè¨ˆãŒ60ã§å‰²ã‚Šåˆ‡ã‚Œã‚‹","tags":[],"title":"Pairs of Songs With Total Duration Divisible by 60","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼numsã‚’ä»¥ä¸‹ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ã«å·¦å³ã«2åˆ†å‰²ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ï¼\n å·¦éƒ¨åˆ†åˆ—ã®ã©ã®è¦ç´ ã‚‚ï¼Œå³éƒ¨åˆ†åˆ—ã®è¦ç´ ä»¥ä¸‹ã§ã‚ã‚‹ å·¦å³ã®éƒ¨åˆ†åˆ—ã¯ç©ºã§ã¯ãªã„  ã“ã®ã¨ãï¼Œå·¦éƒ¨åˆ†åˆ—ã®é•·ã•ã‚’æ±‚ã‚ã‚ˆï¼\nnums = [5, 0, 3, 8, 6] -\u0026gt; ans = 3, [5, 0, 3] + [8, 6] è§£æ³• å·¦éƒ¨åˆ†åˆ—ã®æœ€å¤§å€¤ \u0026lt;= å³éƒ¨åˆ†åˆ—ã®æœ€å°å€¤ã¨ã„ã†æ¡ä»¶ã‚’æº€ãŸã™iã‚’æ±‚ã‚ã‚‹ï¼\nå·¦æ–¹å‘ã®æœ€å¤§å€¤ã¨å³æ–¹å‘ã®æœ€å°å€¤ã‚’åˆ¥ã€…ã«è¨ˆç®—ã—ã¦æœ€å¾Œã«iã‚’è¦‹ã¤ã‘ã‚‹ã¨ã„ã†ãµã†ã«è€ƒãˆã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ï¼\n# Time: O(N), Space: O(N) class Solution: def partitionDisjoint(self, A: List[int]) -\u0026gt; int: N = len(A) max_on_left = [None for _ in range(N)] max_on_left[0] = A[0] for i in range(1, N, 1): max_on_left[i] = max(max_on_left[i-1], A[i]) min_on_right = [None for _ in range(N)] min_on_right[N-1] = A[N-1] for i in range(N-2, -1, -1): min_on_right[i] = min(min_on_right[i+1], A[i]) for i in range(1, N, 1): if max_on_left[i-1] \u0026lt;= min_on_right[i]: return i max_on_leftã¯å˜èª¿å¢—åŠ ãªé…åˆ—ã§ï¼Œå¿…è¦ãªã®ã¯ç›´è¿‘ã®æœ€å¤§å€¤ã ã‘ãªã®ã§é…åˆ—ã˜ã‚ƒãªãã¦ã‚‚è‰¯ã„ï¼\n# Time: O(N), Space: O(N) class Solution: def partitionDisjoint(self, A: List[int]) -\u0026gt; int: N = len(A) min_on_right = [None for _ in range(N)] min_on_right[N-1] = A[N-1] for i in range(N-2, -1, -1): min_on_right[i] = min(min_on_right[i+1], A[i]) current_max = A[0] for i in range(1, N, 1): current_max = max(current_max, A[i-1]) if current_max\u0026lt;= min_on_right[i]: return i æ›´ã«ç©ºé–“è¨ˆç®—é‡ã‚’æ¸›ã‚‰ã™ã“ã¨ãŒã§ãã‚‹ï¼å¢ƒç•Œã‚’å·¦ã‹ã‚‰å³ã¸ç§»ã—ã¦ã„ãã¨ãï¼Œå·¦å´ã®ãã®æ™‚ç‚¹ã§ã®æœ€å¤§å€¤ã‚ˆã‚Šå°ã•ã„å€¤ã«é­é‡ã—ãŸã‚‰ï¼Œãã“ã¯å¿…ãšå·¦å´ã«å…¥ã‚‹ã“ã¨ãŒç¢ºå®šã—ï¼ŒåŒæ™‚ã«å·¦å´éƒ¨åˆ†åˆ—ã®é•·ã•ãŒæš«å®šã§æ±ºã¾ã‚‹ï¼\n# Time: O(N), Space: O(1) class Solution: def partitionDisjoint(self, A: List[int]) -\u0026gt; int: N = len(A) current_max = A[0] possible_max = A[0] length = 1 for i in range(1, N, 1): if A[i] \u0026lt; current_max: length = i + 1 current_max = possible_max else: possible_max = max(possible_max, A[i]) return length å‡ºå…¸  https://leetcode.com/problems/partition-array-into-disjoint-intervals/  ","date":1643875818,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643875818,"objectID":"1773c285f52528c8df55879d7f09d49f","permalink":"/ja/post/partition-array-into-disjoint-intervals/","publishdate":"2022-02-03T17:10:18+09:00","relpermalink":"/ja/post/partition-array-into-disjoint-intervals/","section":"post","summary":"å•é¡Œ æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼numsã‚’ä»¥ä¸‹ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ã«å·¦å³ã«2åˆ†å‰²ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ï¼ å·¦éƒ¨åˆ†åˆ—ã®ã©ã®è¦ç´ ã‚‚ï¼Œå³éƒ¨åˆ†åˆ—ã®è¦ç´ ä»¥ä¸‹ã§","tags":[],"title":"Partition Array Into Disjoint Intervals","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼nums[i]ã®ã€Œç¶ºéº—ã•ã€ã‚’æ¬¡ã®ã‚ˆã†ã«å®šã‚ã‚‹ï¼\n 0 \u0026lt;= j \u0026lt; iï¼Œi \u0026lt; k \u0026lt;= nums.length - 1ã‚’æº€ãŸã™ã™ã¹ã¦ã®jï¼Œkã«ã¤ã„ã¦ï¼Œnums[j] \u0026lt; nums[i] \u0026lt; nums[k]ã‚’æº€ãŸã™ã¨ã2ç‚¹ ä¸Šè¨˜ã‚’æº€ãŸã•ãªã„ã¨ãï¼Œnums[i - 1] \u0026lt; nums[i] \u0026lt; nums[i + 1]ã‚’æº€ãŸã™ã¨1ç‚¹ ã•ã‚‰ã«ä¸Šè¨˜ã‚’æº€ãŸã•ãªã„ã¨ãï¼Œ0ç‚¹  ã™ã¹ã¦ã®iã«ã¤ã„ã¦ç¶ºéº—ã•ã®åˆè¨ˆã‚’æ±‚ã‚ã‚ˆï¼\nnums = [1, 2, 3] -\u0026gt; ans = 2 nums = [2, 4, 6, 4] -\u0026gt; ans = 1 è§£æ³• 1ã¤ç›®ã®æ¡ä»¶ã«ã¤ã„ã¦ã¯ï¼Œè¦ã™ã‚‹ã«ã€Œmax(nums[:i])\u0026lt; nums[i] \u0026lt; min(nums[i+1:])ã€ï¼ã“ã®ã¾ã¾æ›¸ã„ã¦ã—ã¾ã†ã¨$O(n^2)$ã«ãªã£ã¦ã—ã¾ã†ï¼iãŒã¡ã‚‡ã£ã¨ãšã‚ŒãŸã ã‘ã§i-1ã¾ã§ã®æœ€å¤§å€¤æœ€å°å€¤ã®çµæœãŒç„¡é§„ã«ãªã‚‰ãªã„ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ï¼\nä¸€å®šæ–¹å‘ã®æœ€å¤§æœ€å°ã‚’äº‹å‰ã«è¨ˆç®—ã—ã¦ãç³»ã®å•é¡Œã¯çµæ§‹ã‚ã‚‹ï¼\n max_on_left[i]ï¼šnums[:i]ã®æœ€å¤§å€¤ min_on_right[i]ï¼šnums[i+1:]ã®æœ€å°å€¤  class Solution: def sumOfBeauties(self, nums: List[int]) -\u0026gt; int: N = len(nums) max_on_left = [None for _ in range(N)] x = float(\u0026#34;-inf\u0026#34;) for i in range(0, N, 1): max_on_left[i] = x x = max(x, nums[i]) min_on_right = [None for _ in range(N)] x = float(\u0026#34;+inf\u0026#34;) for i in range(N-1, -1, -1): min_on_right[i] = x x = min(x, nums[i]) score = 0 for i in range(1, N-1, 1): if max_on_left[i] \u0026lt; nums[i] \u0026lt; min_on_right[i]: score += 2 elif nums[i-1] \u0026lt; nums[i] \u0026lt; nums[i+1]: score += 1 return score å‡ºå…¸  https://leetcode.com/problems/sum-of-beauty-in-the-array/  ","date":1643874888,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643874888,"objectID":"03692beac5a6c640e687974cac3289c8","permalink":"/ja/post/sum-of-beauty-in-the-array/","publishdate":"2022-02-03T16:54:48+09:00","relpermalink":"/ja/post/sum-of-beauty-in-the-array/","section":"post","summary":"å•é¡Œ æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼nums[i]ã®ã€Œç¶ºéº—ã•ã€ã‚’æ¬¡ã®ã‚ˆã†ã«å®šã‚ã‚‹ï¼ 0 \u0026lt;= j \u0026lt; iï¼Œi \u0026lt; k \u0026lt;= nums.length - 1ã‚’æº€ãŸã™ã™ã¹ã¦ã®jï¼Œkã«ã¤ã„ã¦ï¼Œn","tags":[],"title":"Sum of Beauty in the Array","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ 0ã¨1ã®ã¿ã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹æ–‡å­—åˆ—ã‚’æ ¼ç´ã™ã‚‹é…åˆ—strsã¨æ•´æ•°mï¼ŒnãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼strsã‹ã‚‰ã„ãã¤ã‹ã®æ–‡å­—åˆ—ã‚’å–ã‚Šå‡ºã—ã¦ï¼Œæ¬¡ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãªæ–‡å­—åˆ—ã®é›†åˆXã‚’ä½œã‚ŠãŸã„ï¼\n Xã«å«ã¾ã‚Œã‚‹æ–‡å­—åˆ—ã«ã¤ã„ã¦ï¼Œ0ã®å€‹æ•°ã¨1ã®å€‹æ•°ãŒãã‚Œãã‚Œæœ€å¤§ã§ã‚‚må€‹ï¼Œnå€‹ã§ã‚ã‚‹  Xã®æœ€å¤§ã®ã‚µã‚¤ã‚ºã¯ã„ãã¤ã‹\nç­”ãˆ  ãƒŠãƒƒãƒ—ã‚¶ãƒƒã‚¯å•é¡Œ  class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -\u0026gt; int: # dp[i][j][k]: 1, 2, ..., iç•ªç›®ã¾ã§ã®æ–‡å­—åˆ—ã‚’å¯¾è±¡ã«0ãŒæœ€å¤§ã§jå€‹ï¼Œ1ãŒæœ€å¤§ã§iå€‹å­˜åœ¨ã™ã‚‹ã‚ˆã†ãªéƒ¨åˆ†é›†åˆã‚’å–ã£ãŸã¨ãã®è¦ç´ æ•°ã®æœ€å¤§å€¤ # æ›´æ–°å¼ã®ç«‹ã¦æ–¹ï¼šdp[i][j][k]ã‚’ä¸€ã¤å‰ã®çŠ¶æ…‹ã‹ã‚‰æ›´æ–°ã™ã‚‹ã“ã¨ã§æ±‚ã‚ã‚‹ã¨è€ƒãˆã‚‹ï¼ä»Šå›ã¯iç•ªç›®ã®strã‚’å…¥ã‚Œã‚‹ã‹å…¥ã‚Œãªã„ã‹ã®2ã¤ã®çŠ¶æ…‹ã‹ã‚‰é·ç§»ã—ã¦ãã‚‹ã®ã§ # dp[i][j][k] = max(å…¥ã‚Œã‚‹å ´åˆ, å…¥ã‚Œãªã„å ´åˆ)ã«ãªã‚‹ï¼å…¥ã‚Œãªã„å ´åˆã¯å‰ã¨åŒã˜ã«ãªã‚‹ã®ã§ # dp[i][j][k] = max(å…¥ã‚Œã‚‹å ´åˆ, dp[i-1][j][k])ï¼å…¥ã‚Œã‚‹å ´åˆã‚’è€ƒãˆã‚‹ã¨ï¼Œiç•ªç›®ã®strã«0ãŒzeroså€‹ï¼Œ1ãŒoneså€‹å«ã¾ã‚Œã¦ã„ã‚‹ã®ã§ï¼Œ # iç•ªç›®ã®strã‚’æ¡ç”¨ã—ã¦dp[i][j][k]ã«è‡³ã‚‹ã¨ã„ã†ã“ã¨ã¯ãã®å‰ã¯dp[i-1][j-zeros][k-ones]ã§ã‚ã‚‹ã¯ãšãªã®ã§ # dp[i][j][k] = max(dp[i-1][j-zeros][k-ones], dp[i-1][j][k])ï¼ã“ã“ã§ï¼Œj-zerosã¨k-onesãŒã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å€¤ã¨ã—ã¦æ­£å½“ãªå€¤ã«ãªã‚‹ãŸã‚ã«ã¯0ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ # j-zeros \u0026gt;= 0 and k-ones \u0026gt;= 0ã‚’æ¡ä»¶ã«åˆ†å²ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼elseã®æ–¹ã¯ãã‚‚ãã‚‚0ã‚’zeroså€‹ï¼Œ1ã‚’oneså€‹è¿½åŠ ã—ã¦dp[i][j][k]ã«åˆ°é”ã™ã‚‹ã“ã¨ãŒã§ããªã„ï¼ˆãã®å‰çŠ¶æ…‹ãŒå­˜åœ¨ã—ã¦ãªã„ï¼‰ã®ã§ # iç•ªç›®ã®strã‚’å«ã‚€ã“ã¨ãŒã§ããšãã®ã¾ã¾ã«ãªã‚‹ï¼ # ----------------------------- # if 0 \u0026lt;= j - zeros and 0 \u0026lt;= k - ones: # dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1) # else: # dp[i][j][k] = dp[i - 1][j][k] l = len(strs) dp = [[[0 for _ in range(n + 1)] for _ in range(m + 1)] for _ in range(l + 1)] def count01(s): zeros, ones = 0, 0 for c in s: if c == \u0026#39;0\u0026#39;: zeros += 1 elif c == \u0026#39;1\u0026#39;: ones += 1 return (zeros, ones) for i in range(1, l + 1, 1): s = strs[i - 1] zeros, ones = count01(s) for j in range(0, m + 1, 1): for k in range(0, n + 1, 1): if 0 \u0026lt;= j - zeros and 0 \u0026lt;= k - ones: dp[i][j][k] = max( dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1) else: dp[i][j][k] = dp[i - 1][j][k] return dp[l][m][n] å‡ºå…¸ https://leetcode.com/problems/ones-and-zeroes/\n","date":1643790824,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643790824,"objectID":"f8253c81dca34c69a9b2589c92b3c1a1","permalink":"/ja/post/ones-and-zeros/","publishdate":"2022-02-02T17:33:44+09:00","relpermalink":"/ja/post/ones-and-zeros/","section":"post","summary":"å•é¡Œ 0ã¨1ã®ã¿ã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹æ–‡å­—åˆ—ã‚’æ ¼ç´ã™ã‚‹é…åˆ—strsã¨æ•´æ•°mï¼ŒnãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼strsã‹ã‚‰ã„ãã¤ã‹ã®æ–‡å­—åˆ—ã‚’å–ã‚Šå‡ºã—ã¦ï¼Œæ¬¡ã®æ¡ä»¶ã‚’æº€ãŸã™","tags":[],"title":"Ones and Zeros","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ1  æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼numsã¯1ã¤ã®ã‚ã‚‹æ•´æ•°$x$ã‚’é™¤ã„ã¦ã™ã¹ã¦ã®æ•´æ•°ãŒ2å€‹ãšã¤æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ï¼$x$ã‚’æ±‚ã‚ã‚ˆï¼ https://leetcode.com/problems/single-number/  ç­”ãˆ  xoræ¼”ç®—ã‚’ä½¿ã†  åŒã˜æ•´æ•°åŒå£«ã®xorã¯0ã«ãªã‚‹ã“ã¨ã‚’åˆ©ç”¨ã™ã‚‹ a ^ a == 0   numsã‚’å…¨éƒ¨xorã™ã‚Œã°1ã¤ã—ã‹ãªã„è¦ç´ ãŒæ®‹ã‚‹  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: ans = nums[0] for num in nums[1:]: ans ^= num return ans å•é¡Œ2  æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼numsã¯2ã¤ã®ã‚ã‚‹æ•´æ•°$x$ï¼Œ$y$ã‚’é™¤ã„ã¦ã™ã¹ã¦ã®æ•´æ•°ãŒ2å€‹ãšã¤æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ï¼$x$ï¼Œ$y$ã‚’æ±‚ã‚ã‚ˆï¼ https://leetcode.com/problems/single-number-iii/  ç­”ãˆ1  setã‚’ä½¿ã† æ™‚é–“è¨ˆç®—é‡$O(n)$ ç©ºé–“è¨ˆç®—é‡$O(n)$  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; List[int]: s = set() for num in nums: if num in s: s.remove(num) continue s.add(num) return list(s) ç­”ãˆ2   xorã‚’ä½¿ã†\n  1ã¤ç›®ã®å•é¡Œã¨åŒã˜ã‚ˆã†ã«è€ƒãˆã‚‹ã¨ï¼Œnumsã®è¦ç´ å…¨éƒ¨ã®xorã‚’å–ã£ãŸçµæœPã¯xã¨yã®é‡ã­åˆã‚ã›ã«ãªã£ã¦ã„ã‚‹ã®ã§åˆ†è§£ã™ã‚‹å¿…è¦ãŒã‚ã‚‹\n xorã®ç‰¹å¾´ã‹ã‚‰ï¼Œä¸€æ–¹ãŒã‚ã‹ã‚Œã°è‰¯ã„    Pã‚’2é€²æ•°è¡¨è¨˜ã—ãŸã¨ãã«1ã«ãªã£ã¦ã„ã‚‹æ¡ã«æ³¨ç›®ã™ã‚‹ã¨ï¼Œãã“ã«æ¡ãŒç«‹ã¤ã¨ã„ã†ã“ã¨ã¯ï¼Œxï¼Œyã®ã©ã£ã¡ã‹ã«ã‚‚ãã®ä½ç½®ã®æ¡ãŒç«‹ã£ã¦ã„ãŸã¯ãšï¼ˆã˜ã‚ƒãªã„ã¨xorã—ãŸçµæœã«æ®‹ã‚‰ãªã„ï¼‰\n  æ™‚é–“è¨ˆç®—é‡$O(n)$\n  ç©ºé–“è¨ˆç®—é‡$O(1)$\n  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; List[int]: xor1, xor2, i = 0, 0, 0 # å…¨éƒ¨ã®xorã‚’å–ã‚‹ for num in nums: xor1 ^= num # 1ãŒç«‹ã£ã¦ã‚‹æœ€ä¸‹ä½æ¡ã‚’å–ã‚‹ï¼ˆãƒ›ãƒ³ãƒˆã¯ã©ã“ã®æ¡ã§ã‚‚ã„ã„ï¼‰ for d in range(32): if xor1 \u0026amp; 1 \u0026lt;\u0026lt; d: i = d break for num in nums: if num \u0026amp; 1 \u0026lt;\u0026lt; i: xor2 ^= num return [xor1 ^ xor2, xor2] ","date":1643790063,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643790063,"objectID":"ca311951e0eebd57ff0b29265b362439","permalink":"/ja/post/single-number/","publishdate":"2022-02-02T17:21:03+09:00","relpermalink":"/ja/post/single-number/","section":"post","summary":"å•é¡Œ1 æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼numsã¯1ã¤ã®ã‚ã‚‹æ•´æ•°$x$ã‚’é™¤ã„ã¦ã™ã¹ã¦ã®æ•´æ•°ãŒ2å€‹ãšã¤æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ï¼$x$ã‚’æ±‚ã‚ã‚ˆï¼ https://leetcode.com/problems/single-number/ ç­”ãˆ xor","tags":[],"title":"Single Number","type":"post"},{"authors":[],"categories":[],"content":"contain duplicate 1 æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼2å€‹ä»¥ä¸ŠåŒã˜è¦ç´ ãŒnumsã«å«ã¾ã‚Œã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼\nnums = [1, 2, 3, 1] -\u0026gt; True nums = [1, 2, 3, 4] -\u0026gt; False ç­”ãˆ  ã‚½ãƒ¼ãƒˆã—ã¦å‰ã‹ã‚‰è¦‹ã¦ã„ãï¼ æ™‚é–“è¨ˆç®—é‡$O(n)$  class Solution: def containsDuplicate(self, nums: List[int]) -\u0026gt; bool: nums.sort() for i in range(len(nums) - 1): if nums[i] == nums[i+1]: return True return False contain duplicate 2 æ•´æ•°é…åˆ—numsï¼Œæ•´æ•°kãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ç•°ãªã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹iï¼Œjã«ã¤ã„ã¦ï¼Œ\n nums[i] == nums[j]ã‹ã¤abs(i - j) \u0026lt;= k  ã‚’æº€ãŸã™ã‚ˆã†ãª(i, j)ãŒå­˜åœ¨ã™ã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼\nnums = [1, 2, 3, 1], k = 3 -\u0026gt; True (i = 0, j = 3) nums = [1, 2, 3, 1, 2, 3], k = 2 -\u0026gt; False $O(n^2)$ãªç­”ãˆ  (i, j)ã®çµ„ã¿åˆã‚ã›ã‚’å…¨é€šã‚Šèª¿ã¹ã‚‹  # TLE: O(n^2) class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -\u0026gt; bool: for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] == nums[j] and j - i \u0026lt;= k: return True return False $O(n)$ãªç­”ãˆ  æœ€å¾Œã«numã¨ãªã‚‹ä½ç½®iã‚’è¦šãˆã¦ãŠã‘ã°åˆ¤å®šå¯èƒ½  class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -\u0026gt; bool: memo = dict() # {num: idx} for i, num in enumerate(nums): if num in memo: if i - memo[num] \u0026lt;= k: return True memo[num] = i return False contain duplicate 3 æ•´æ•°é…åˆ—numsï¼Œæ•´æ•°kï¼ŒtãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ç•°ãªã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹iï¼Œjã«ã¤ã„ã¦ï¼Œ\n abs(nums[i] - nums[j]) \u0026lt;= tã‹ã¤abs(i - j) \u0026lt;= k  ã‚’æº€ãŸã™ã‚ˆã†ãª(i, j)ãŒå­˜åœ¨ã™ã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼\nnums = [1, 2, 3, 1], k = 3, t = 0 -\u0026gt; True (i = 0, j = 3) nums = [1, 5, 9, 1, 5, 9], k = 2, t = 3 -\u0026gt; False $O(n^2)$ãªç­”ãˆ  (i, j)ã®çµ„ã¿åˆã‚ã›ã‚’å…¨é€šã‚Šèª¿ã¹ã‚‹  # TLE: O(n^2) class Solution: def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -\u0026gt; bool: for i in range(len(nums)): for j in range(i + 1, len(nums)): if abs(nums[i] - nums[j]) \u0026lt;= t and abs(i - j) \u0026lt;= k: return True return False $O(n)$ãªç­”ãˆ  ã‚„ã‚„é›£ã—ã„ ãƒã‚±ãƒƒãƒˆã‚½ãƒ¼ãƒˆã‹ã‚‰ç™ºæƒ³ ï¼ˆé›‘ã«è¨€ã†ã¨ï¼‰numsã®æ•°å­—ã‚’MIN_NUM (= -2^31)ã‹ã‚‰ã®è·é›¢ã§å–ã‚Šç›´ã—ãŸä¸Šã§ï¼Œå¹…tã§ãƒã‚±ãƒ„ã‚’ç”¨æ„ã™ã‚‹ã¨ï¼ŒåŒã˜ãƒã‚±ãƒ„ã«å±ã™ã‚‹æ•°å­—ã¯å·®ãŒtä»¥å†…  class Solution: def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -\u0026gt; bool: if k \u0026lt; 1 or t \u0026lt; 0: return False buckets = dict() # {remapped num: original num} MIN_NUM = -(1 \u0026lt;\u0026lt; 31) for i, num in enumerate(nums): remapped = num - MIN_NUM bucket = remapped // (t + 1) if bucket in buckets or (bucket + 1 in buckets and buckets[bucket + 1] - remapped \u0026lt;= t) or (bucket - 1 in buckets and remapped - buckets[bucket - 1] \u0026lt;= t): return True if len(buckets) \u0026gt;= k: # ä½ç½®ãŒé ã™ãã‚‹æ•°å­—ã®bucketã¯ä¸è¦ãªã®ã§ã§æ¶ˆã™ last_bucket = (nums[i - k] - MIN_NUM) // (t + 1) del buckets[last_bucket] buckets[bucket] = remapped return False ","date":1643788178,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1643788178,"objectID":"c0542c0d0195482bb4d7ecf015f6f264","permalink":"/ja/post/contains-duplicate-1-2-3/","publishdate":"2022-02-02T16:49:38+09:00","relpermalink":"/ja/post/contains-duplicate-1-2-3/","section":"post","summary":"contain duplicate 1 æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼2å€‹ä»¥ä¸ŠåŒã˜è¦ç´ ãŒnumsã«å«ã¾ã‚Œã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼ nums = [1, 2, 3, 1] -\u0026gt; True nums = [1, 2, 3, 4] -\u0026gt; False ç­”ãˆ ã‚½ãƒ¼ãƒˆã—ã¦å‰ã‹ã‚‰è¦‹","tags":[],"title":"Contains Duplicate","type":"post"},{"authors":[],"categories":[],"content":"æœ‰å‘ã‚°ãƒ©ãƒ•ã«ãŠã‘ã‚‹å¼·é€£çµæˆåˆ†åˆ†è§£   å¼·é€£çµï¼šä»»æ„ã®2é ‚ç‚¹å¯¾$(u, v)$ã«ã¤ã„ã¦ï¼Œ$u$ã‹ã‚‰$v$ã«è‡³ã‚‹ãƒ‘ã‚¹ã¨$v$ã‹ã‚‰$u$ã«è‡³ã‚‹ãƒ‘ã‚¹ã®åŒæ–¹ãŒå­˜åœ¨ã™ã‚‹\n  å¼·é€£çµæˆåˆ†ï¼šäº’ã„ã«å¼·é€£çµã§ã‚ã‚‹é ‚ç‚¹ã‹ã‚‰ãªã‚‹é ‚ç‚¹é›†åˆ\n  å¼·é€£çµæˆåˆ†ã‚’è¨ˆç®—ã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ \n 2å›ã®DFSã‚’è¡Œã†  ã€1ã€‘DFSã‚’è¡Œã£ã¦ï¼Œé ‚ç‚¹ã®å¸°ã‚ŠãŒã‘é †ã‚’æ±‚ã‚ã‚‹ ã€2ã€‘å¸°ã‚ŠãŒã‘é †ä¸Šä½ã‹ã‚‰ï¼Œå…ƒã®ã‚°ãƒ©ãƒ•ã®è¾ºã®å‘ãã‚’é€†è»¢ã•ã›ãŸã‚°ãƒ©ãƒ•ä¸Šã§DFS      ä¾‹é¡Œ  https://atcoder.jp/contests/typical90/tasks/typical90_u  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int N, M; bool has_visited[1 \u0026lt;\u0026lt; 18]; vector\u0026lt;int\u0026gt; G[1 \u0026lt;\u0026lt; 18]; vector\u0026lt;int\u0026gt; RG[1 \u0026lt;\u0026lt; 18]; vector\u0026lt;int\u0026gt; post_order; long long cnt = 0; void DFS(int node) { has_visited[node] = true; for (int neighbor : G[node]) { if (!has_visited[neighbor]) DFS(neighbor); } post_order.push_back(node); } void RDFS(int node) { has_visited[node] = true; cnt += 1; for (int neighbor : RG[node]) { if (!has_visited[neighbor]) RDFS(neighbor); } } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for (int i = 1; i \u0026lt;= M; i++) { int A, B; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; G[A].push_back(B); RG[B].push_back(A); } for (int i = 1; i \u0026lt;= N; i++) has_visited[i] = false; for (int node = 1; node \u0026lt;= N; node++) { if (!has_visited[node]) DFS(node); } reverse(post_order.begin(), post_order.end()); long long ans = 0; for (int i = 1; i \u0026lt;= N; i++) has_visited[i] = false; for (int node : post_order) { if (has_visited[node]) continue; cnt = 0; RDFS(node); ans += cnt * (cnt - 1LL) / 2LL; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":1638501943,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1638501943,"objectID":"73c688f0a952f600e86fd54bf4afddac","permalink":"/ja/post/strongly-connected-components-in-directed-graph/","publishdate":"2021-12-03T12:25:43+09:00","relpermalink":"/ja/post/strongly-connected-components-in-directed-graph/","section":"post","summary":"æœ‰å‘ã‚°ãƒ©ãƒ•ã«ãŠã‘ã‚‹å¼·é€£çµæˆåˆ†åˆ†è§£ å¼·é€£çµï¼šä»»æ„ã®2é ‚ç‚¹å¯¾$(u, v)$ã«ã¤ã„ã¦ï¼Œ$u$ã‹ã‚‰$v$ã«è‡³ã‚‹ãƒ‘ã‚¹ã¨$v$ã‹ã‚‰$u$ã«è‡³ã‚‹ãƒ‘ã‚¹ã®åŒæ–¹ãŒ","tags":[],"title":"Strongly Connected Components in Directed Graph","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ1 æ•´æ•°é…åˆ—nums1ï¼Œnums2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼nums1ã¯nums2ã®éƒ¨åˆ†é…åˆ—ã§ã‚ã‚‹ï¼nums2ã«ã¯åŒã˜æ•´æ•°ãŒè¤‡æ•°å›ç™»å ´ã™ã‚‹ã“ã¨ãŒãªã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹ï¼ã“ã“ã§æ•´æ•°é…åˆ—numsã®å„è¦ç´ nums[i]ã«å¯¾ã—ã¦ã€Œæ¬¡ã«å¤§ãã„å€¤ã€ã‚’æ¬¡ã®ã‚ˆã†ã«å®šã‚ã‚‹ï¼\n nums[i+1:]ã§æœ€åˆã«nums[i]ã‚ˆã‚Šå¤§ãã„å€¤  nums1ã«å«ã¾ã‚Œã‚‹è¦ç´ ã«ã¤ã„ã¦ï¼Œnums2ã«ãŠã‘ã‚‹å„è¦ç´ ã®ã€Œæ¬¡ã«å¤§ãã„å€¤ã€ã‚’æ±‚ã‚ã‚ˆï¼\nnums1 = [4, 1, 2] nums2 = [1, 3, 4, 2] -\u0026gt; ans = [-1, 3, -1] nums1[0] (= 4) ... nums2ã«ãŠã‘ã‚‹ã€Œ4ã®æ¬¡ã«å¤§ãã„å€¤ã€ã¯å­˜åœ¨ã—ãªã„ã®ã§ -1 nums1[1] (= 1) ... nums2ã«ãŠã‘ã‚‹ã€Œ1ã®æ¬¡ã«å¤§ãã„å€¤ã€ã¯ 3 (= nums2[1]) nums1[2] (= 2) ... nums2ã«ãŠã‘ã‚‹ã€Œ2ã®æ¬¡ã«å¤§ãã„å€¤ã€ã¯å­˜åœ¨ã—ãªã„ã®ã§ -1 ç­”ãˆ Blute-Force nums1ã®å„è¦ç´ ã«ã¤ã„ã¦ï¼Œæ¯å›ã€Œæ¬¡ã«å¤§ãã„å€¤ã€ã‚’$O(n)$ã§è¨ˆç®—ã™ã‚‹ï¼å…¨ä½“ã¨ã—ã¦ã¯æ™‚é–“è¨ˆç®—é‡ãŒ$O(n^2)$\nclass Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: ans = [] for num in nums1: # O(n) idx = nums2.index(num) next_greater = -1 for candidate in nums2[idx+1:]: # O(n) if num \u0026lt; candidate: next_greater = candidate break ans.append(next_greater) return ans stackã‚’ä½¿ã† ã€Œnums2[i]ã®æ¬¡ã«å¤§ãã„å€¤ã€å€™è£œã¯ï¼Œç¢ºã‹ã«nums2[i+1:]ã«å«ã¾ã‚Œã‚‹ãŒã“ã‚Œã¯ç„¡é§„ãŒå¤šã„ï¼\nã€Œnums2[i]ã®æ¬¡ã«å¤§ãã„å€¤ã€ã®å€™è£œã¯ã€Œnums2[i+1]ã®æ¬¡ã«å¤§ãã„å€¤ï¼Œnums2[i+2]ã®æ¬¡ã«å¤§ãã„å€¤\u0026hellip;ã€ã§ã‚ã‚‹ï¼\nã“ã‚Œã¯ã¤ã¾ã‚Šï¼Œnums2[i]ã®æ¬¡ã«å¤§ãã„å€¤ã‚’æ±‚ã‚ã‚‹å•é¡ŒãŒnums2[i+j](j = 1, 2, ...)ã¨ã„ã†éƒ¨åˆ†å•é¡Œã®è²ã‚’ä½¿ã£ã¦è§£ã‘ã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚‹ï¼\n[..., 5, 2, 1, 6] ^ 5ã®æ¬¡ã«å¤§ãã„å€¤ = max(2ã®æ¬¡ã«å¤§ãã„å€¤, 1ã®æ¬¡ã«å¤§ãã„å€¤, 6ã®æ¬¡ã«å¤§ãã„å€¤) ã“ã‚Œã‚’stackã§å®Ÿè£…ã™ã‚‹ï¼\nclass Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: next_greater = dict() # nums2ã¯é‡è¤‡è¦ç´ ãŒå­˜åœ¨ã—ãªã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹ for num in nums2: next_greater[num] = -1 stack = [] for i in range(len(nums2)-1, -1, -1): # å¾Œã‚ã‹ã‚‰éƒ¨åˆ†å•é¡Œã‚’è§£ã„ã¦ã„ã while len(stack) != 0 and stack[-1] \u0026lt;= nums2[i]: # nums2[i]ä»¥ä¸‹ã®ç­”ãˆå€™è£œã¯ç­”ãˆã«ãªã‚Šãˆãªã„ stack.pop() if len(stack) != 0: next_greater[nums2[i]] = stack[-1] stack.append(nums2[i]) ans = [next_greater[num] for num in nums1] return ans å•é¡Œ2 æ•´æ•°ã‚’è¦ç´ ã¨ã™ã‚‹å¾ªç’°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ãªãŠnums[-1]ã®æ¬¡ã®è¦ç´ ã¯nums[0]ã§ã‚ã‚‹ã¨ã™ã‚‹ï¼\nã“ã“ã§æ•´æ•°é…åˆ—numsã®å„è¦ç´ nums[i]ã«å¯¾ã—ã¦ã€Œæ¬¡ã«å¤§ãã„å€¤ã€ã‚’æ¬¡ã®ã‚ˆã†ã«å®šã‚ã‚‹ï¼\n nums[i+1:]ã§æœ€åˆã«nums[i]ã‚ˆã‚Šå¤§ãã„å€¤  å¾ªç’°é…åˆ—numsã®å„è¦ç´ ã«ã¤ã„ã¦ã€Œæ¬¡ã«å¤§ãã„å€¤ã€ã‚’æ±‚ã‚ã‚ˆï¼\nç­”ãˆ Blute-Force å¾ªç’°é…åˆ—ã¯å…ƒã®é…åˆ—ã®2å€ã®é•·ã•ã«ã‚³ãƒ”ãƒ¼ã—ã¦ãŠã‘ã°æ™®é€šã®é…åˆ—ã¨ã—ã¦æ‰±ãˆã‚‹ï¼ã‚ã¨ã¯çœŸé¢ç›®ã«å„è¦ç´ ã«ã¤ã„ã¦æ¬¡ã«å¤§ãã„å€¤ã‚’$O(n)$ã§è¨ˆç®—ã™ã‚Œã°ã„ã„ï¼å…¨ä½“ã¨ã—ã¦ã¯$O(n^2)$ï¼\nclass Solution: def nextGreaterElements(self, nums: List[int]) -\u0026gt; List[int]: ret = [-1 for _ in range(len(nums))] doubled = nums + nums for i in range(len(nums)): # O(n) for j in range(i + 1, i + len(nums)): # O(n) if nums[i] \u0026lt; doubled[j]: ret[i] = doubled[j] break return ret numsã®é•·ã•ã®å‰°ä½™ã§å®Ÿè£…ã—ã¦ã‚‚ã„ã„ï¼\nclass Solution: def nextGreaterElements(self, nums: List[int]) -\u0026gt; List[int]: ret = [-1 for _ in range(len(nums))] for i in range(len(nums)): # O(n) for j in range(1, len(nums)): # O(n) if nums[i] \u0026lt; nums[(i + j) % len(nums)]: ret[i] = nums[(i + j) % len(nums)] break return ret stackã‚’ä½¿ã† å•é¡Œ1ã¨åŒã˜ç™ºæƒ³ï¼ãŸã ã—å¾ªç’°é…åˆ—ãªã®ã§2å›é…åˆ—ã‚’èˆã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼\nclass Solution: def nextGreaterElements(self, nums: List[int]) -\u0026gt; List[int]: ret = [-1 for _ in range(len(nums))] filled = [False for _ in range(len(nums))] stack = [] # nums[i]ã®æ¬¡ã«å¤§ãã„å€¤ã®å€™è£œï¼ˆnums[i+?]ã®æ¬¡ã«å¤§ãã„å€¤ï¼‰ã‚’ãƒ¡ãƒ¢ for i in range(len(nums) - 1, -1, -1): # å¾Œã‚ã‹ã‚‰ãƒ«ãƒ¼ãƒ— while len(stack) != 0 and stack[-1] \u0026lt;= nums[i]: stack.pop() # nums[i]ä»¥ä¸‹ãªã®ã§stack[-1]ã¯ç­”ãˆã«ãªã‚‰ãªã„ if len(stack) != 0: ret[i] = stack[-1] filled[i] = True stack.append(nums[i]) # nums[i]ã¯nums[i-1]ä»¥é™ã®ã€Œæ¬¡ã«å¤§ãã„å€¤ã€ã®å€™è£œ # ã‚µã‚¤ã‚¯ãƒ«ã«ãªã£ã¦ã„ã‚‹ã®ã§2å‘¨ã—ã¦ãŠã‘ã°ååˆ† for i in range(len(nums) - 1, -1, -1): if not filled[i]: while len(stack) != 0 and stack[-1] \u0026lt;= nums[i]: stack.pop() if len(stack) != 0: ret[i] = stack[-1] filled[i] = True return ret å•é¡Œ3 æ•´æ•°xãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼xã¨å„æ¡ã®æ•°å­—ã®é›†åˆãŒåŒã˜ã§xã®æ¬¡ã«å¤§ãã„æ•´æ•°ã‚’æ±‚ã‚ã‚ˆï¼å­˜åœ¨ã—ãªã‘ã‚Œã°-1ã‚’è¿”ã›ï¼\nç­”ãˆ å°ã•ã„æ¡ã‹ã‚‰è¦‹ã¦ã„ãï¼å°ã•ã„æ¡ã«å‘ã‹ã£ã¦é™é †ã«ãªã£ã¦ã„ã‚‹éƒ¨åˆ†ã‚’èª¿ã¹ã¦ï¼Œé™é †ãŒå´©ã‚Œã‚‹ç®‡æ‰€ã‚’ç‰¹å®šã™ã‚‹ï¼é™é †ã«ãªã£ã¦ã„ã‚‹æ¡ã®ã†ã¡ï¼Œé™é †ãŒå´©ã‚Œã‚‹æ¡ã®æ•°å­—ã®æ¬¡ã«å¤§ãã„æ•°å­—ã‚’äº¤æ›ã—ã¦æ˜‡é †ã«ä¸¦ã¹ã‚‹ï¼\nclass Solution: def nextGreaterElement(self, n: int) -\u0026gt; int: digits = list(str(n)) i = len(digits) - 1 # é™é †ã«ãªã£ã¦ã„ã‚‹éƒ¨åˆ†ã‚’æ¢ã™ while 0 \u0026lt;= i - 1 and digits[i-1] \u0026gt;= digits[i]: i -= 1 if i == 0: # å…¨éƒ¨é™é † -\u0026gt; æ¬¡ã«å¤§ãã„å€¤ã¯å­˜åœ¨ã—ãªã„ return -1 j = i while j \u0026lt; len(digits) - 1 and digits[i-1] \u0026lt; digits[j+1]: j += 1 digits[i-1], digits[j] = digits[j], digits[i-1] digits[i:] = digits[i:][::-1] ret = int(\u0026#34;\u0026#34;.join(digits)) return ret if ret \u0026lt; 1 \u0026lt;\u0026lt; 31 else -1 å•é¡Œ4 iæ—¥ã®æ°—æ¸©ãŒtemperatures[i]ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªæ•´æ•°é…åˆ—temperaturesãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼å„æ—¥ä»˜ã«å¯¾ã—ã¦ï¼Œãã®æ—¥ã‚ˆã‚Šæš–ã‹ã„æ—¥ãŒä½•æ—¥å¾Œä¼¼åˆã£ãŸã®ã‹ã‚’è¨ˆç®—ã›ã‚ˆï¼\nç­”ãˆ ã€Œæ¬¡ã«å¤§ãã„å€¤ã€ç³»ã®å•é¡Œãã®ã‚‚ã®ï¼\nclass Solution: def dailyTemperatures(self, temperatures: List[int]) -\u0026gt; List[int]: ans = [0 for _ in range(len(temperatures))] stack = [] for i in range(len(temperatures)-1, -1, -1): while len(stack) != 0 and stack[-1][0] \u0026lt;= temperatures[i]: stack.pop() if len(stack) != 0: ans[i] = stack[-1][1] - i stack.append((temperatures[i], i)) return ans refs  https://leetcode.com/problems/next-greater-element-i/ https://leetcode.com/problems/next-greater-element-ii/ https://leetcode.com/problems/next-greater-element-iii/  ","date":1635062702,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1635062702,"objectID":"3dee51475f323dc6999dfad07410c9aa","permalink":"/ja/post/next-greater-element-series/","publishdate":"2021-10-24T17:05:02+09:00","relpermalink":"/ja/post/next-greater-element-series/","section":"post","summary":"å•é¡Œ1 æ•´æ•°é…åˆ—nums1ï¼Œnums2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼nums1ã¯nums2ã®éƒ¨åˆ†é…åˆ—ã§ã‚ã‚‹ï¼nums2ã«ã¯åŒã˜æ•´æ•°ãŒè¤‡æ•°å›ç™»å ´ã™ã‚‹ã“ã¨ãŒãªã„ã“","tags":[],"title":"Next Greater Element Series","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã“ã§ï¼Œæ¬¡ã«æŒ™ã’ã‚‹æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãª2è¦ç´ ã®å·®ã®æœ€å¤§å€¤ï¼ˆnums[j] - nums[i]ï¼‰ã‚’æ±‚ã‚ã‚ˆï¼å­˜åœ¨ã—ãªã‘ã‚Œã°-1ã‚’è¿”ã›ï¼\n 0 \u0026lt;= i \u0026lt; j \u0026lt; len(nums) nums[i] \u0026lt; nums[j]  è§£æ³•1 (i, j)ã®çµ„ã¿åˆã‚ã›ã‚’å‰é€šã‚Šèª¿ã¹ä¸Šã’ã‚‹ã¨$O(n^2)$ï¼\nè§£æ³•2 numsã‚’å·¦ã‹ã‚‰èˆã‚ãªãŒã‚‰ï¼Œmin_sofarã§ãã®ä½ç½®ã¾ã§ã®æœ€å°å€¤ã‚’ä¿å­˜ã—ã¦ãŠã‘ã°$O(n)$ã§æ±‚ã‚ãŸã„ç­”ãˆãŒæ±‚ã¾ã‚‹ï¼\nclass Solution: def maximumDifference(self, nums: List[int]) -\u0026gt; int: ans = -1 min_sofar = float(\u0026#34;inf\u0026#34;) for num in nums: min_sofar = min(min_sofar, num) if min_sofar \u0026lt; num: ans = max(ans, num - min_sofar) return ans è§£æ³•3 Functionalã«è€ƒãˆã‚‹ï¼\nnums: [7, 1, 5, 4] min_sofar: [7, 1, 1, 1] diff: [0, 0, 4, 3] # element-wise diff diffã®maxãŒç­”ãˆï¼ãŸã ï¼Œnums = [9, 4, 3, 2]ã®ã‚ˆã†ãªå ´åˆã¯è¿”ã™ã¹ãã¯-1ãªã®ã§ãã®å‡¦ç†ã®ãŸã‚ã«diffã®0ã‚’å¼¾ã„ã¦ã‹ã‚‰-1ã‚’è¿½åŠ ã—ãŸä¸Šã§maxã‚’å–ã‚‹ã¨è‰¯ã„\nclass Solution: def maximumDifference(self, nums: List[int]) -\u0026gt; int: import itertools min_scan = itertools.accumulate( nums, min, initial=float(\u0026#34;+inf\u0026#34;) ) min_scan = list(min_scan)[1:] zipped = zip(nums, min_scan) mapped = map(lambda _: _[0] - _[1], zipped) filtered = filter(lambda _: _ != 0, mapped) import functools fold_left = lambda func, acc, xs: functools.reduce(func, xs, acc) ans = fold_left(max, -1, filtered) return ans ref  https://leetcode.com/problems/maximum-difference-between-increasing-elements/  ","date":1635058286,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1635058286,"objectID":"3dce66f845bd898ba8999a794203ccb2","permalink":"/ja/post/maximum-difference-between-increasing-elements/","publishdate":"2021-10-24T15:51:26+09:00","relpermalink":"/ja/post/maximum-difference-between-increasing-elements/","section":"post","summary":"å•é¡Œ æ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã“ã§ï¼Œæ¬¡ã«æŒ™ã’ã‚‹æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãª2è¦ç´ ã®å·®ã®æœ€å¤§å€¤ï¼ˆnums[j] - nums[i]ï¼‰ã‚’æ±‚ã‚ã‚ˆï¼å­˜åœ¨ã—ãª","tags":[],"title":"Maximum Difference Between Increasing Elements","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ•´æ•°é…åˆ—numsã¨æ•´æ•°kãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼å¹…kã®çª“ã‚’numsä¸Šã§å·¦ã‹ã‚‰å³ã¸å‹•ã‹ã—ãªãŒã‚‰ï¼Œãã®çª“ã®ä¸­ã®æœ€å¤§å€¤ã‚’è¨ˆç®—ã—ã¦è¿”ã›ï¼\nä¾‹ï¼š\nå…¥åŠ›: nums = [1,3,-1,-3,5,3,6,7], k = 3 å‡ºåŠ›: [3,3,5,5,6,7] window | max --------------------------------- [1 3 -1] -3 5 3 6 7 | 3 1 [3 -1 -3] 5 3 6 7 | 3 1 3 [-1 -3 5] 3 6 7 | 5 1 3 -1 [-3 5 3] 6 7 | 5 1 3 -1 -3 [5 3 6] 7 | 6 1 3 -1 -3 5 [3 6 7] | 7 ç­”ãˆ  ç·å½“ã‚Šã§ã‚„ã‚‹ãªã‚‰$O(nk)$  class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[int]: ans = [] for i in range(0, len(nums) - k + 1): ans.append(max(nums[i:i+k])) return ans  monotonic queueã‚’ä½¿ã†ã¨$O(n)$ã§è¨ˆç®—ã§ãã‚‹ï¼  monotonic queueï¼šè¦ç´ ãŒå˜èª¿ï¼ˆå¢—åŠ ï½œæ¸›å°‘ï¼‰ãªã‚­ãƒ¥ãƒ¼ ä½œã‚ŠãªãŒã‚‰ä½¿ã†æ„Ÿã˜  numsã®iç•ªç›®ã¾ã§ã‚’push()ã—ã¦max_num()ã™ã‚‹ã¨max(nums[:i+1])ãŒ$O(1)$ã§å–ã‚Œã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸   æ­£ç›´ã¾ã ä½¿ã„æ–¹ãƒ»ä½¿ã„æ‰€ã¯ç†è§£ã—ã¦ã„ãªã„\u0026hellip;    class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[int]: class MonoQueue: def __init__(self): self.queue = collections.deque() # queueã¯å˜èª¿æ¸›å°‘ def push(self, val): leftside = 0 # numsã«ãŠã„ã¦ï¼Œvalã®å·¦å´ã«ä½•å€‹ã®æ•°å­—ãŒã‚ã‚‹ã‹ï¼ while len(self.queue) != 0 and self.queue[-1][0] \u0026lt; val: leftside += self.queue[-1][1] + 1 self.queue.pop() self.queue.append([val, leftside]) def max_num(self): return self.queue[0][0] def pop(self): if 0 \u0026lt; self.queue[0][1]: self.queue[0][1] -= 1 else: self.queue.popleft() ans = [] mq = MonoQueue() for i in range(0, k - 1): mq.push(nums[i]) for i in range(k - 1, len(nums)): mq.push(nums[i]) ans.append(mq.max_num()) mq.pop() return ans Ref  https://leetcode.com/problems/sliding-window-maximum/  ","date":1633784174,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1633784174,"objectID":"43a9f2697d32d0b00f6e5a9c68a5e255","permalink":"/ja/post/sliding-window-maximum/","publishdate":"2021-10-09T21:56:14+09:00","relpermalink":"/ja/post/sliding-window-maximum/","section":"post","summary":"å•é¡Œ æ•´æ•°é…åˆ—numsã¨æ•´æ•°kãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼å¹…kã®çª“ã‚’numsä¸Šã§å·¦ã‹ã‚‰å³ã¸å‹•ã‹ã—ãªãŒã‚‰ï¼Œãã®çª“ã®ä¸­ã®æœ€å¤§å€¤ã‚’è¨ˆç®—ã—ã¦è¿”ã›ï¼ ä¾‹ï¼š å…¥åŠ›: nums = [1,3,-1,-3,5,3,6,7], k","tags":[],"title":"Sliding Window Maximum","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ç´ å› æ•°ãŒ$2$ï¼Œ$3$ï¼Œ$5$ã®ã¿ã‹ã‚‰ãªã‚‹åˆæˆæ•°ã‚’ã€Œugly numberã€ã¨å‘¼ã¶ã“ã¨ã«ã™ã‚‹ï¼$n$ç•ªç›®ã®ugly numberã‚’è¨ˆç®—ã›ã‚ˆï¼\nè§£æ³• ãªã‚“ã¨ãªãugly numberã‚’æ›¸ãå‡ºã—ã¦ã¿ã‚‹ã¨ï¼Œ\n1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ... ã‚ã‚‹ugly numberã¯ãã‚Œä»¥å‰ã®ugly numberã®ã©ã‚Œã‹ã«$2$ï¼Œ$3$ï¼Œ$5$ã®ã©ã‚Œã‹ã‚’ä¹—ã˜ã¦å¾—ã‚‰ã‚Œã‚‹æœ€å°ã®æ•°ã«ãªã£ã¦ã„ã‚‹ï¼\nclass Solution: def nthUglyNumber(self, n: int) -\u0026gt; int: uglies = [1] ptr2 = 0 ptr3 = 0 ptr5 = 0 while 1 \u0026lt; n: ugly2 = 2 * uglies[ptr2] ugly3 = 3 * uglies[ptr3] ugly5 = 5 * uglies[ptr5] ugly = min(ugly2, ugly3, ugly5) if ugly == ugly2: ptr2 += 1 if ugly == ugly3: ptr3 += 1 if ugly == ugly5: ptr5 += 1 uglies.append(ugly) n -= 1 return uglies[-1] Ref  https://leetcode.com/problems/ugly-number-ii/  ","date":1633499153,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1633499153,"objectID":"5586b237e5d3fa11226cd064e7a3af43","permalink":"/ja/post/ugly-number-2/","publishdate":"2021-10-06T14:45:53+09:00","relpermalink":"/ja/post/ugly-number-2/","section":"post","summary":"å•é¡Œ ç´ å› æ•°ãŒ$2$ï¼Œ$3$ï¼Œ$5$ã®ã¿ã‹ã‚‰ãªã‚‹åˆæˆæ•°ã‚’ã€Œugly numberã€ã¨å‘¼ã¶ã“ã¨ã«ã™ã‚‹ï¼$n$ç•ªç›®ã®ugly numberã‚’è¨ˆç®—ã›ã‚ˆï¼","tags":[],"title":"Ugly Number 2","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ $k$å€‹ã®å˜é€£çµãƒªã‚¹ãƒˆlistsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼é€£çµãƒªã‚¹ãƒˆã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹ï¼å„ãƒªã‚¹ãƒˆã¯æ˜‡é †ã«æ•´åˆ—ã•ã‚Œã¦ã„ã‚‹ï¼\nclass ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ã™ã¹ã¦ã®ãƒªã‚¹ãƒˆã‚’çµ±åˆã—ãŸä¸Šã§æ˜‡é †ã«æ•´åˆ—ã—ãŸé€£çµãƒªã‚¹ãƒˆã‚’è¿”ã›ï¼\nä¾‹ï¼š\nInput: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-\u0026gt;4-\u0026gt;5, 1-\u0026gt;3-\u0026gt;4, 2-\u0026gt;6 ] merging them into one sorted list: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6 è§£æ³•1 ãªã‚“ã«ã‚‚è€ƒãˆãšã«ï¼Œå…¨ãƒãƒ¼ãƒ‰ã‚’ä¸€æ—¦èˆã‚ã¦å€¤ã‚’å›åã—ã¦ã‚½ãƒ¼ãƒˆã™ã‚‹ï¼ãƒãƒ¼ã‚¸çµæœã®é€£çµãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã‚‹ãƒãƒ¼ãƒ‰æ•°ã‚’$N$ã¨ã—ã¦ï¼Œæ™‚é–“è¨ˆç®—é‡ã¯ã‚½ãƒ¼ãƒˆãŒãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã«ãªã£ã¦$O(N \\log N)$ï¼\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeKLists(self, lists: List[ListNode]) -\u0026gt; ListNode: vals = [] for node in lists: while node is not None: vals.append(node.val) node = node.next vals.sort() head = ListNode() ptr = head for val in vals: ptr.next = ListNode(val=val) ptr = ptr.next return head.next è§£æ³•2 å„é€£çµãƒªã‚¹ãƒˆã®å…ˆé ­ã‹ã‚‰ä¸€ç•ªå°ã•ã„ã‚„ã¤ã‚’é¸ã‚“ã§æ–°ã—ã„ãƒªã‚¹ãƒˆã‚’ä½œã£ã¦ã„ãï¼$n$ã‚’å„ãƒªã‚¹ãƒˆã®å¹³å‡é•·ã¨ã—ã¦æ™‚é–“è¨ˆç®—é‡ã¯$O(kn)$ï¼å„ãƒªã‚¹ãƒˆã‹ã‚‰æœ€å°ã®è¦ç´ ã‚’è¦‹ã¤ã‘ã‚‹ã®ã«ç‰¹ã«å·¥å¤«ã‚’ã—ãªã‘ã‚Œã°$O(n)$ã‹ã‹ã‚‹ï¼\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -\u0026gt; Optional[ListNode]: ret = ListNode() ptr = ret current = [] for node in lists: if node is None: continue current.append(node) while len(current) != 0: min_node = ListNode(val=float(\u0026#34;inf\u0026#34;)) min_idx = -1 for idx, node in enumerate(current): if node.val \u0026lt; min_node.val: min_node = node min_idx = idx ptr.next = min_node ptr = ptr.next current = current[:min_idx] + current[min_idx + 1:] if min_node.next is not None: current.append(min_node.next) return ret.next è§£æ³•3 è§£æ³•2ã‚’æ”¹è‰¯ã™ã‚‹ï¼ã€Œå„ãƒªã‚¹ãƒˆã‹ã‚‰æœ€å°ã®è¦ç´ ã‚’è¦‹ã¤ã‘ã‚‹ã€ã‚’Priority Queueã‚’ä½¿ã£ã¦$O(1)$ã«ã§ãã‚‹ï¼ä¸€æ–¹ã§Priority Queueã¸ã®è¦ç´ ã®è¿½åŠ ãŒ$O(\\log k)$ã‹ã‹ã‚‹ã®ã§ï¼Œå…¨ä½“ã®æ™‚é–“è¨ˆç®—é‡ã¯$O(n \\log k)$ï¼\n Wrapperã‚¯ãƒ©ã‚¹ã‚’ä½œã£ã¦ListNodeã«æ¼”ç®—å­\u0026lt;ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹å®Ÿè£…  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -\u0026gt; Optional[ListNode]: class Wrapper: def __init__(self, node): self.node = node def __lt__(self, other): return self.node.val \u0026lt; other.node.val ret = ListNode() ptr = ret from queue import PriorityQueue pq = PriorityQueue() for node in lists: if node is None: continue pq.put(Wrapper(node)) while not pq.empty(): min_node = pq.get().node ptr.next = min_node ptr = ptr.next if min_node.next is not None: pq.put(Wrapper(min_node.next)) return ret.next  ã©ã®ãƒªã‚¹ãƒˆã‹ã‚‰æœ€å°å€¤ã®ãƒãƒ¼ãƒ‰ãŒå–ã‚ŒãŸã‹ã‚’listsä¸Šã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ã—ã¦ä¿æŒã—ã¦ãŠãå®Ÿè£…  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -\u0026gt; Optional[ListNode]: ret = ListNode() ptr = ret current = [] for idx, node in enumerate(lists): if node is None: continue current.append((node.val, idx)) heapq.heapify(current) while len(current) != 0: min_val, min_idx = heapq.heappop(current) ptr.next = ListNode(val=min_val) ptr = ptr.next if lists[min_idx].next is not None: heapq.heappush(current, (lists[min_idx].next.val, min_idx)) lists[min_idx] = lists[min_idx].next return ret.next è§£æ³•4 ã€Œ$k$å€‹ã®ãƒªã‚¹ãƒˆã®ãƒãƒ¼ã‚¸ã€ã‚’ã€Œ2å€‹ã®ãƒªã‚¹ãƒˆã®ãƒãƒ¼ã‚¸ï¼Œã‚’$k-1$å›ã€ã¨è€ƒãˆã¦è§£ãã“ã¨ã‚‚è€ƒãˆã‚‰ã‚Œã‚‹ï¼ä¸€ã¤å‰ã®çµ±åˆçµæœã«æ¬¡ã®ãƒªã‚¹ãƒˆã‚’é‡ã­ã¦çµ±åˆã•ã›ã¦ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸ï¼å„ãƒªã‚¹ãƒˆã®å¹³å‡é•·ã‚’$n$ã¨ã—ã¦ï¼Œå…¨ä½“ã®æ™‚é–“è¨ˆç®—é‡ã¯$O(nk^2)$ï¼\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -\u0026gt; Optional[ListNode]: def merge_two_lists(list1, list2): dummy = ListNode(val=-1, next=None) current = dummy while list1 is not None and list2 is not None: if list1.val \u0026lt; list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1 is not None: current.next = list1 else: current.next = list2 return dummy.next head = ListNode(val=-1) for i in range(len(lists)): head.next = merge_two_lists(head.next, lists[i]) return head.next è§£æ³•5 è§£æ³•4ã‚’æ”¹è‰¯ã™ã‚‹ï¼è§£æ³•4ã§ã¯ï¼Œæœ€åˆã®æ–¹ã«ãƒãƒ¼ã‚¸ã•ã‚ŒãŸé ‚ç‚¹ã‚’ä½•å›ã‚‚å‚ç…§ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼ã“ã“ãŒç„¡é§„ï¼ãã“ã§ï¼Œåˆ†å‰²çµ±æ²»æ³•ï¼2å€‹ãšã¤ï¼Œ4å€‹ãšã¤ï¼Œ8å€‹ãšã¤\u0026hellip;ãƒãƒ¼ã‚¸ã—ã¦ã„ã‘ã°ã„ã„ï¼\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -\u0026gt; Optional[ListNode]: def merge_two_lists(list1, list2): dummy = ListNode(val=-1, next=None) current = dummy while list1 is not None and list2 is not None: if list1.val \u0026lt; list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1 is not None: current.next = list1 else: current.next = list2 return dummy.next N = len(lists) interval = 1 if N == 0: return None while interval \u0026lt; N: for i in range(0, N - interval, interval * 2): lists[i] = merge_two_lists(lists[i], lists[i + interval]) interval *= 2 return lists[0] Ref  https://leetcode.com/problems/merge-k-sorted-lists/  ","date":1633497382,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1633497382,"objectID":"14abd5d3b148816cb6a325071300a0cd","permalink":"/ja/post/merge-k-sorted-list/","publishdate":"2021-10-06T14:16:22+09:00","relpermalink":"/ja/post/merge-k-sorted-list/","section":"post","summary":"å•é¡Œ $k$å€‹ã®å˜é€£çµãƒªã‚¹ãƒˆlistsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼é€£çµãƒªã‚¹ãƒˆã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹ï¼å„ãƒªã‚¹ãƒˆã¯æ˜‡é †ã«æ•´åˆ—ã•ã‚Œã¦ã„ã‚‹ï¼ class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next","tags":[],"title":"Merge $k$ Sorted List","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ 1ï¼Œ2ï¼Œ3 ã®ã¿ã‚’è¦ç´ ã¨ã—ã¦å«ã‚€æ•´æ•°é…åˆ— nums ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼nums ã‚’æ˜‡é †ã«æ•´åˆ—ã•ã›ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’æ›¸ããªã•ã„ï¼\nç­”ãˆ å„è¦ç´ ãŒå…¥ã‚‹ã¹ãä½ç½®ã®æœ«ç«¯ã‚’è¿½è·¡ã—ãªãŒã‚‰æ•´åˆ—ã•ã›ã‚‹ï¼\n oneï¼šæ•´åˆ—å¾Œã® nums ã«ç¾ã‚Œã‚‹é€£ç¶šã™ã‚‹ 1 ã®ã†ã¡ã®å³ç«¯ã®ä½ç½® twoï¼šæ•´åˆ—å¾Œã® nums ã«ç¾ã‚Œã‚‹é€£ç¶šã™ã‚‹ 2 ã®ã†ã¡ã®å³ç«¯ã®ä½ç½® threeï¼šæ•´åˆ—å¾Œã® nums ã«ç¾ã‚Œã‚‹é€£ç¶šã™ã‚‹ 3 ã®ã†ã¡ã®å³ç«¯ã®ä½ç½®  class Solution: def sortColors(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; one = 0 two = 0 three = len(nums) - 1 while two \u0026lt;= three: if nums[two] == 1: nums[one], nums[two] = nums[two], nums[one] one += 1 two += 1 elif nums[two] == 2: two += 1 else: nums[two], nums[three] = nums[three], nums[two] three -= 1 è¨ˆç®—é‡ã¯twoãŒnumsã‚’å·¦ç«¯ã‹ã‚‰å³ç«¯ã¾ã§å‹•ããƒ«ãƒ¼ãƒ—ãŒå›ã‚‹ã®ã§$O(n)$\nä¸€æ–¹ã§ï¼Œlist.sort()ã™ã‚Œã°ã„ã„ã¨ã„ã†è©±ã‚‚ã‚ã‚‹ï¼ã“ã®å ´åˆã¯å®Ÿéš›ã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ä¾å­˜ã™ã‚‹ãŒ$O(n \\log n)$ï¼\nref  https://leetcode.com/problems/sort-colors/  ","date":1633240494,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1633240494,"objectID":"af6e9a5d6a880da9c8bfac59fd50e1cd","permalink":"/ja/post/sort-colors/","publishdate":"2021-10-03T14:54:54+09:00","relpermalink":"/ja/post/sort-colors/","section":"post","summary":"å•é¡Œ 1ï¼Œ2ï¼Œ3 ã®ã¿ã‚’è¦ç´ ã¨ã—ã¦å«ã‚€æ•´æ•°é…åˆ— nums ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼nums ã‚’æ˜‡é †ã«æ•´åˆ—ã•ã›ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’æ›¸ããªã•ã„ï¼ ç­”ãˆ å„è¦ç´ ãŒå…¥ã‚‹ã¹ãä½ç½®ã®æœ«ç«¯","tags":[],"title":"Sort Colors","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ 2ã¤ã®æ–‡å­—åˆ—s1ï¼Œs2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼s1ã®é †åˆ—ãŒs2ã®éƒ¨åˆ†æ–‡å­—åˆ—ã¨ã—ã¦å«ã¾ã‚Œã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼\nè§£æ³•1  Blute-force s1ã®é †åˆ—ã‚’å…¨éƒ¨èª¿ã¹ä¸Šã’ã‚‹ æ™‚é–“è¨ˆç®—é‡ï¼š$O(l_1 !)$  ãŸã ã—$l_1$ã¯s1ã®é•·ã•    class Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: flag = False def permutation(s, sofar): nonlocal flag if len(s) == 0: if sofar in s2: flag = True return for i in range(len(s)): permutation(s[:i] + s[i+1:], sofar + s[i]) permutation(s1, \u0026#34;\u0026#34;) return flag è§£æ³•2  ã€Œs1ã®é †åˆ—ãŒs2ã®éƒ¨åˆ†æ–‡å­—åˆ—ã¨ã—ã¦å«ã¾ã‚Œã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼ã€ãªã®ã§ï¼Œå®Ÿéš›ã«s2ã«å«ã¾ã‚Œã‚‹é †åˆ—ãŒã©ã®é †åˆ—ãªã®ã‹ã¯ä¸è¦ è¦ã™ã‚‹ã«ã€Œs1ã¨åŒã˜æ–‡å­—ç¨®ãƒ»åŒã˜å€‹æ•°ã§æ§‹æˆã•ã‚Œã‚‹ã€s2ã®éƒ¨åˆ†æ–‡å­—åˆ—ãŒã‚ã‚‹ã‹ã‚’èª¿ã¹ã‚Œã°è‰¯ã„ s1ã‚’ã‚½ãƒ¼ãƒˆã—ãŸã®ã¨s2ã®éƒ¨åˆ†åˆ—ã‚’ã‚½ãƒ¼ãƒˆã—ãŸã®ãŒä¸€è‡´ã™ã‚Œã°ååˆ† æ™‚é–“è¨ˆç®—é‡ï¼š$O(l_1 \\log l_1 + (l_2 - l_1) l_1 \\log l_1)$  $l_1 \\log l_1$ï¼šs1ã®ã‚½ãƒ¼ãƒˆ $(l_2 - l_1) l_1 \\log l_1$ï¼šé•·ã•len(s1)ã®éƒ¨åˆ†åˆ—ãŒlen(s2) - len(s1)å€‹å­˜åœ¨ã—ã¦ãã‚Œãã‚Œã‚½ãƒ¼ãƒˆã•ã‚Œã‚‹    class Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: s1 = \u0026#34;\u0026#34;.join(sorted(s1)) for i in range(len(s2) - len(s1) + 1): if s1 == \u0026#34;\u0026#34;.join(sorted(s2[i:i+len(s1)])): return True return False è§£æ³•3  è§£æ³•2ã¨åŒã˜ç™ºæƒ³ã§åˆ¥ã®ã‚„ã‚Šæ–¹ ã€Œs1ã¨åŒã˜æ–‡å­—ç¨®ãŒåŒã˜å€‹æ•°å­˜åœ¨ã™ã‚‹ã‹ã€ã‚’è¾æ›¸ã®æ¯”è¼ƒã§å®Ÿç¾ æ™‚é–“è¨ˆç®—é‡ï¼š$O(l_1 + (l_2 - l_1) l_1 )$  $l_1$ï¼šs1ã«å«ã¾ã‚Œã‚‹æ–‡å­—ç¨®ãŒãã‚Œãã‚Œä½•å€‹å­˜åœ¨ã™ã‚‹ã‹ã®è¾æ›¸ã‚’ä½œã‚‹ $(l_2 - l_1) l_1$ï¼šlen(s2) - len(s1)å€‹ã®éƒ¨åˆ†æ–‡å­—åˆ—ã®ãã‚Œãã‚Œã«ã¤ã„ã¦è¾æ›¸ã‚’æ¯”è¼ƒ    class Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: if len(s1) \u0026gt; len(s2): return False # è¾æ›¸ä½œã‚‹ cnt1 = Counter(s1) for i in range(len(s2) - len(s1) + 1): # è¾æ›¸ä½œã‚‹ cnt2 = Counter() for j in range(len(s1)): if s2[i + j] in cnt2: cnt2[s2[i + j]] += 1 else: cnt2[s2[i + j]] = 1 # è¾æ›¸åŒå£«ã®æ¯”è¼ƒ if cnt1 == cnt2: return True return False è§£æ³•4  è§£æ³•3ã‚’è¾æ›¸ã˜ã‚ƒãªãã¦keyã‚’ä½ç½®ã§ä»£ç”¨ã—ãŸé…åˆ—ã§ã‚„ã‚‹  class Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: if len(s1) \u0026gt; len(s2): return False cnt1 = [0 for _ in range(26)] for ch in s1: cnt1[ord(ch) - ord(\u0026#39;a\u0026#39;)] += 1 for i in range(len(s2) - len(s1) + 1): cnt2 = [0 for _ in range(26)] for ch in s2[i:i+len(s1)]: cnt2[ord(ch) - ord(\u0026#39;a\u0026#39;)] += 1 flag = True for i in range(26): if cnt1[i] != cnt2[i]: flag = False break if flag: return True return False è§£æ³•5  è§£æ³•4ã‚’æ”¹è‰¯ã™ã‚‹ len(s2) - len(s1)å€‹ã‚ã‚‹éƒ¨åˆ†æ–‡å­—åˆ—ã®ãã‚Œãã‚Œã«å¯¾ã—ã¦ï¼Œã‚¼ãƒ­ã‹ã‚‰è¾æ›¸ã‚’æ¯å›ä½œã‚‹ã®ã¯ç„¡é§„ã§ã¯ï¼Ÿ  ä¸€æ–‡å­—éƒ¨åˆ†æ–‡å­—åˆ—ãŒã‚ºãƒ¬ã‚‹ã¨ãã®è¾æ›¸ã¯ï¼Œéƒ¨åˆ†æ–‡å­—åˆ—ã‹ã‚‰æ¶ˆãˆã‚‹æ–‡å­—ãŒä½•ã§ï¼Œéƒ¨åˆ†æ–‡å­—åˆ—ã«æ–°ã—ãåŠ ã‚ã‚‹æ–‡å­—ãŒä½•ã‹ã‚’è¿½ãˆã°å·®åˆ†ã‚’æ›´æ–°ã™ã‚‹ã ã‘ã§ä½œã‚Œã‚‹   æ™‚é–“è¨ˆç®—é‡ï¼š$O(l_1 + (l_2 - l_1) * 26)$  class Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: if len(s1) \u0026gt; len(s2): return False cnt1 = [0 for _ in range(26)] cnt2 = [0 for _ in range(26)] for i in range(len(s1)): ch = s1[i] cnt1[ord(ch) - ord(\u0026#39;a\u0026#39;)] += 1 ch = s2[i] cnt2[ord(ch) - ord(\u0026#39;a\u0026#39;)] += 1 def match(cnt1, cnt2): for i in range(26): if cnt1[i] != cnt2[i]: return False return True for i in range(len(s2) - len(s1)): if match(cnt1, cnt2): return True left = s2[i] right = s2[i + len(s1)] cnt2[ord(left) - ord(\u0026#39;a\u0026#39;)] -= 1 cnt2[ord(right) - ord(\u0026#39;a\u0026#39;)] += 1 return match(cnt1, cnt2) è§£æ³•5  è§£æ³•4ã‚’æ”¹è‰¯ã™ã‚‹ match(cnt1, cnt2)ã‚’ã„ã„æ„Ÿã˜ã«ã—ãŸã„ å€‹æ•°ãŒä¸€è‡´ã™ã‚‹æ–‡å­—ç¨®ã®æ•°ãŒä¸€è‡´ã™ã‚‹ã‹ã‚’éƒ¨åˆ†æ–‡å­—åˆ—ã®å·®åˆ†ã‹ã‚‰è¨ˆç®—ã§ãã‚Œã°ï¼Œè¾æ›¸ã®ã™ã¹ã¦ã®è¦ç´ ã«ã¤ã„ã¦å€‹æ•°ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ«ãƒ¼ãƒ—ãŒæ¶ˆã›ãã†  å®šæ•°å€è¨ˆç®—é‡ãŒå‰Šæ¸›ã§ããã†    class Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: if len(s1) \u0026gt; len(s2): return False cnt1 = [0 for _ in range(26)] cnt2 = [0 for _ in range(26)] for i in range(len(s1)): ch = s1[i] cnt1[ord(ch) - ord(\u0026#39;a\u0026#39;)] += 1 ch = s2[i] cnt2[ord(ch) - ord(\u0026#39;a\u0026#39;)] += 1 matched = 0 # å€‹æ•°ãŒä¸€è‡´ã™ã‚‹æ–‡å­—ç¨®ã®æ•° for i in range(26): if cnt1[i] == cnt2[i]: matched += 1 for i in range(len(s2) - len(s1)): left = ord(s2[i]) - ord(\u0026#39;a\u0026#39;) right = ord(s2[i + len(s1)]) - ord(\u0026#39;a\u0026#39;) if matched == 26: return True cnt2[left] -= 1 # æ¬¡ã®iã§å·¦ç«¯ã®æ–‡å­—ã¯éƒ¨åˆ†æ–‡å­—åˆ—ã‹ã‚‰æ¶ˆãˆã‚‹ if cnt2[left] == cnt1[left]: matched += 1 # å·¦ç«¯ã®æ–‡å­—ãŒéƒ¨åˆ†æ–‡å­—åˆ—ã‹ã‚‰æ¶ˆãˆãŸçµæœï¼Œå€‹æ•°ãŒä¸€è‡´ã—ãŸæ–‡å­—ç¨®ãŒå¢—ãˆãŸ elif cnt2[left] + 1 == cnt1[left]: matched -= 1 # å·¦ç«¯ã®æ–‡å­—ãŒéƒ¨åˆ†æ–‡å­—åˆ—ã‹ã‚‰æ¶ˆãˆãŸçµæœï¼Œå€‹æ•°ãŒä¸€è‡´ã—ãŸæ–‡å­—ç¨®ãŒæ¸›ã£ãŸ cnt2[right] += 1 # æ¬¡ã®iã§å³ç«¯ã®æ–‡å­—ã¯éƒ¨åˆ†æ–‡å­—åˆ—ã«è¿½åŠ ã•ã‚Œã‚‹ if cnt2[right] == cnt1[right]: matched += 1 # å³ç«¯ã®æ–‡å­—ãŒéƒ¨åˆ†æ–‡å­—åˆ—ã«è¿½åŠ ã•ã‚ŒãŸçµæœï¼Œå€‹æ•°ãŒä¸€è‡´ã—ãŸæ–‡å­—ç¨®ãŒå¢—ãˆãŸ elif cnt2[right] - 1 == cnt1[right]: matched -= 1 # å³ç«¯ã®æ–‡å­—ãŒéƒ¨åˆ†æ–‡å­—åˆ—ã«è¿½åŠ ã•ã‚ŒãŸçµæœï¼Œå€‹æ•°ãŒä¸€è‡´ã—ãŸæ–‡å­—ç¨®ãŒæ¸›ã£ãŸ return matched == 26 ref https://leetcode.com/problems/permutation-in-string/\n","date":1630840371,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1630840371,"objectID":"a00d5564cfad515d66ee7b85229cb30c","permalink":"/ja/post/permutation-in-string/","publishdate":"2021-09-05T20:12:51+09:00","relpermalink":"/ja/post/permutation-in-string/","section":"post","summary":"å•é¡Œ 2ã¤ã®æ–‡å­—åˆ—s1ï¼Œs2ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼s1ã®é †åˆ—ãŒs2ã®éƒ¨åˆ†æ–‡å­—åˆ—ã¨ã—ã¦å«ã¾ã‚Œã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼ è§£æ³•1 Blute-force s1ã®é †åˆ—ã‚’å…¨éƒ¨èª¿ã¹ä¸Šã’ã‚‹ æ™‚é–“è¨ˆç®—é‡ï¼š","tags":[],"title":"Permutation in String","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ­£æ•´æ•°é…åˆ—numsã¨æ•´æ•°targetãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼numsã®é€£ç¶šã™ã‚‹éƒ¨åˆ†åˆ—ã®ã†ã¡ï¼Œãã®å’ŒãŒtargetä»¥ä¸Šã¨ãªã‚‹ã‚ˆã†ãªéƒ¨åˆ†åˆ—ã®æœ€å°ã®é•·ã•ã‚’æ±‚ã‚ã‚ˆï¼ãã®ã‚ˆã†ãªéƒ¨åˆ†åˆ—ãŒå­˜åœ¨ã—ãªã„ãªã‚‰ã°0ã‚’è¿”ã›ï¼\næ–¹é‡ å¸¸ã«è€ƒãˆã‚‹ã¹ãã¯\n ã¾ãšã¯brute-force ç„¡é§„ãªè¨ˆç®—ã¯ãªã„ã‹ï¼Ÿ  è§£æ³•1  brute-force è€ƒãˆã‚‰ã‚Œã‚‹ã™ã¹ã¦ã®éƒ¨åˆ†åˆ—ã‚’åˆ—æŒ™ã—ã¦ï¼Œãã‚Œãã‚Œã«ã¤ã„ã¦å’Œã‚’ã¨ã£ã¦targetä»¥ä¸Šã«ãªã‚‹ã‹ã‚’èª¿ã¹ã‚‹ æ™‚é–“è¨ˆç®—é‡ï¼š$O(n^3)$  $O(n^2)$å€‹ã®éƒ¨åˆ†åˆ—ãã‚Œãã‚Œã«å¯¾ã—ã¦ï¼Œ$O(n)$ã§å’Œã‚’å–ã‚‹   ç©ºé–“è¨ˆç®—é‡ï¼š$O(1)$  class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: ans = float(\u0026#34;inf\u0026#34;) for i in range(len(nums)): for j in range(i, len(nums)): s = 0 for num in nums[i:j+1]: s += num if target \u0026lt;= s: ans = min(ans, j - i + 1) return ans if ans != float(\u0026#34;inf\u0026#34;) else 0 è§£æ³•2  è§£æ³•1ã‚’æ”¹è‰¯ã™ã‚‹ éƒ¨åˆ†åˆ—ã®å’Œã‚’ç´¯ç©å’Œã‚’ä½¿ã£ã¦$O(1)$ã§æ±‚ã‚ã‚Œã°å…¨ä½“ã¯$O(n^2)$ã«è½ã¨ã›ã‚‹  ç´¯ç©å’Œï¼šaccum[0] = 0ï¼Œaccum[i] = accum[i-1] + nums[i]   æ™‚é–“è¨ˆç®—é‡ï¼š$O(n^2)$  $O(n^2)$å€‹ã®éƒ¨åˆ†åˆ—ãã‚Œãã‚Œã«å¯¾ã—ã¦ï¼Œ$O(1)$ã§å’Œã‚’å–ã‚‹   ç©ºé–“è¨ˆç®—é‡ï¼š$O(n)$  ç´¯ç©å’Œã®é…åˆ—    class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: ans = float(\u0026#34;inf\u0026#34;) accum = [0 for _ in range(len(nums) + 1)] for i in range(1, len(nums) + 1): accum[i] = accum[i-1] + nums[i-1] for i in range(len(nums)): for j in range(i, len(nums)): s = accum[j+1] - accum[i] if target \u0026lt;= s: ans = min(ans, j - i + 1) return ans if ans != float(\u0026#34;inf\u0026#34;) else 0 è§£æ³•3  è§£æ³•2ã‚’æ”¹è‰¯ã™ã‚‹ ç´¯ç©å’Œaccumã¯å˜èª¿ã«å¢—åŠ ã™ã‚‹é…åˆ— target = accum[j+1] - accum[i]ã ã‹ã‚‰accum[j+1] = target + accum[i] iã‚’å›ºå®šã—ãŸã¨ãã«j+1ã¯accumã«å¯¾ã™ã‚‹äºŒåˆ†æ¢ç´¢ã§$O(\\log n)$ã§æ±‚ã‚ã‚‰ã‚Œã‚‹ æ™‚é–“è¨ˆç®—é‡ï¼š$O(n \\log n)$  $O(n)$ã§å·¦ç«¯ãŒå›ã£ã¦ï¼Œ$O(\\log n)$ã§éƒ¨åˆ†å’ŒãŒtargetã‚’è¶…ãˆã‚‹å¢ƒç›®ãŒå–ã‚Œã‚‹   ç©ºé–“è¨ˆç®—é‡ï¼š$O(n)$  ç´¯ç©å’Œã®é…åˆ—    class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: ans = float(\u0026#34;inf\u0026#34;) accum = [0 for _ in range(len(nums) + 1)] for i in range(1, len(nums) + 1): accum[i] = accum[i-1] + nums[i-1] for i in range(len(nums) + 1): j = bisect_left(accum, accum[i] + target) if j != len(accum): ans = min(ans, j - i) return ans if ans != float(\u0026#34;inf\u0026#34;) else 0 è§£æ³•4  å°ºå–æ³•ã¨ã„ã†ãƒ†ã‚¯  è§£æ³•3ã®æ”¹è‰¯ï¼ˆaccumã‚’å…¨éƒ¨ä¿æŒã—ãªã„ï¼‰ã¨ã‚‚æ‰ãˆã‚‰ã‚Œã‚‹   å·¦ç«¯ã‚’å›ºå®šã—ãŸã¨ãã«ï¼Œãã®éƒ¨åˆ†åˆ—ã®å’ŒãŒtargetã‚’è¶…ãˆãŸæ™‚ç‚¹ã§å³ç«¯ã¯ãã‚Œä»¥ä¸Šä¼¸ã°ã—ã¦ã‚‚æ„å‘³ãªã„ æ™‚é–“è¨ˆç®—é‡ï¼š$O(n)$  $O(n)$ã§å·¦ç«¯ãŒå›ã£ã¦ãŠã—ã¾ã„   ç©ºé–“è¨ˆç®—é‡ï¼š$O(1)$  class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: ans = float(\u0026#34;inf\u0026#34;) left = 0 accum = 0 for right in range(len(nums)): accum += nums[right] while target \u0026lt;= accum: ans = min(ans, right - left + 1) accum -= nums[left] left += 1 return ans if ans != float(\u0026#34;inf\u0026#34;) else 0 ref https://leetcode.com/problems/minimum-size-subarray-sum/\n","date":1630422480,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1630422480,"objectID":"1635791c8c039adc27c255af5784c4fa","permalink":"/ja/post/minimum-size-subarray-sum/","publishdate":"2021-09-01T00:08:00+09:00","relpermalink":"/ja/post/minimum-size-subarray-sum/","section":"post","summary":"å•é¡Œ æ­£æ•´æ•°é…åˆ—numsã¨æ•´æ•°targetãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼numsã®é€£ç¶šã™ã‚‹éƒ¨åˆ†åˆ—ã®ã†ã¡ï¼Œãã®å’ŒãŒtargetä»¥ä¸Šã¨ãªã‚‹ã‚ˆã†ãªéƒ¨åˆ†åˆ—ã®æœ€å°ã®é•·ã•","tags":[],"title":"Minimum Size Subarray Sum","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸæ•´æ•°é…åˆ—arrã¨æ•´æ•°kï¼ŒxãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼arrå†…ã®xã«ã€Œè¿‘ã„ã€kå€‹ã®æ•´æ•°ã‚’ç…§æº–ã«æ ¼ç´ã—ãŸé…åˆ—ã‚’è¿”ã™é–¢æ•°ã‚’æ›¸ã‘ï¼\nã“ã“ã§ã€Œæ•´æ•°aãŒæ•´æ•°bã‚ˆã‚Šæ•´æ•°xã«è¿‘ã„ã€ã¨ã¯ï¼Œã€Œ|a - x| \u0026lt; |b - x|ã€ã‚‚ã—ãã¯ã€Œ|a - x| == |b - x|ã‹ã¤a \u0026lt; bã€ã¨ãªã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ï¼\nè§£æ³•1  è¨€ã‚ã‚ŒãŸã¨ãŠã‚Šã«ã‚½ãƒ¼ãƒˆã—ã¦å†’é ­kå€‹ã‚’è¿”ã™ï¼ æ™‚é–“è¨ˆç®—é‡ï¼š$O(n \\log n + k \\log k)$  $n$ï¼šarrã®é•·ã•ï¼Œ$k$ï¼šä¸ãˆã‚‰ã‚ŒãŸæ•´æ•°kï¼ˆä»¥ä¸‹ã‚‚åŒæ§˜ï¼‰   ç©ºé–“è¨ˆç®—é‡ï¼š$O(1)$  class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -\u0026gt; List[int]: arr = sorted(arr, key=lambda a: abs(a - x)) arr = arr[:k] arr = sorted(arr) return arr è§£æ³•2  é…åˆ—ãŒã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã®ã§ï¼Œæ±‚ã‚ã‚‹ç­”ãˆã¯arrã®é•·ã•kã®éƒ¨åˆ†é…åˆ—ã«ãªã‚‹ ã„ã‚ã‚†ã‚‹2 pointersã¨ã„ã†ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ï¼ˆï¼Ÿï¼‰  leftï¼Œrightã‚’ãã‚Œãã‚Œå·¦ç«¯ï¼Œå³ç«¯ã‹ã‚‰è©°ã‚ã¦ã„ã   æ™‚é–“è¨ˆç®—é‡ï¼š$O(n - k)$  ãƒã‚¤ãƒ³ã‚¿ã®ç§»å‹•å›æ•°åˆ†   ç©ºé–“è¨ˆç®—é‡ï¼š$O(1)$  class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -\u0026gt; List[int]: left = 0 right = len(arr) - 1 while k \u0026lt;= right - left: if x - arr[left] \u0026lt;= arr[right] - x: right -= 1 # rightã®ã»ã†ãŒxã‹ã‚‰é ã„ else: left += 1 return arr[left:right+1] è§£æ³•3  ç­”ãˆã¨ãªã‚‹éƒ¨åˆ†é…åˆ—ã®å³ç«¯ã®æ•´æ•°ã¯xä»¥ä¸Šã®å€¤ãªã¯ãšãªã®ã§ï¼Œrightã®ä½ç½®ã‚’ãã“ã‹ã‚‰å§‹ã‚ã¦ã‚‚æ§‹ã‚ãªã„ï¼  rightã®åˆæœŸå€¤ã‚’ã€Œarrå†…ã§åˆã‚ã¦xä»¥ä¸Šã«ãªã‚‹æœ€å°ã®ä½ç½®ã€ã‹ã‚‰åˆã‚ã¦è‰¯ã„   é ˜åŸŸã‚’åºƒã’ã¦ã„ãæ–¹å‘ã§ç­”ãˆã‚’æ±‚ã‚ã‚‹ æ™‚é–“è¨ˆç®—é‡ï¼š$O(log n + k)$ ç©ºé–“è¨ˆç®—é‡ï¼š$O(1)$  class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -\u0026gt; List[int]: right = bisect_left(arr, x) # rightã®åˆæœŸä½ç½® left = right - 1 while 0 \u0026lt; k: if len(arr) \u0026lt;= right or (0 \u0026lt;= left and x - arr[left] \u0026lt;= arr[right] - x): left -= 1 # leftã®æ–¹ãŒxã«è¿‘ã„ã®ã§å·¦ã«ä¼¸ã°ã™ else: right += 1 k -= 1 return arr[left + 1:right] è§£æ³•4  è§£æ³•3ã‚’æ”¹è‰¯ã™ã‚‹ rightã®åˆæœŸå€¤ã¯arr[0:len(arr) - k]ã®ã©ã“ã‹  rightã®åˆæœŸå€¤ã‚’æ±ºå®šã™ã‚‹ã¨ãã®ç„¡é§„ãªè¨ˆç®—ãŒæ¸›ã‚‹   æ™‚é–“è¨ˆç®—é‡ï¼š$O(log (n - k) + k)$ ç©ºé–“è¨ˆç®—é‡ï¼š$O(1)$  class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -\u0026gt; List[int]: right = bisect_left(arr[0:len(arr) - k], x) left = right - 1 while 0 \u0026lt; k: if len(arr) \u0026lt;= right or (0 \u0026lt;= left and x - arr[left] \u0026lt;= arr[right] - x): left -= 1 else: right += 1 k -= 1 return arr[left + 1:right] ref https://leetcode.com/problems/find-k-closest-elements/\n","date":1630408851,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1630408851,"objectID":"16f3e8d26d03d957770673b549e09219","permalink":"/ja/post/find-k-closest-elements/","publishdate":"2021-08-31T20:20:51+09:00","relpermalink":"/ja/post/find-k-closest-elements/","section":"post","summary":"å•é¡Œ æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸæ•´æ•°é…åˆ—arrã¨æ•´æ•°kï¼ŒxãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼arrå†…ã®xã«ã€Œè¿‘ã„ã€kå€‹ã®æ•´æ•°ã‚’ç…§æº–ã«æ ¼ç´ã—ãŸé…åˆ—ã‚’è¿”ã™é–¢æ•°ã‚’æ›¸ã‘ï¼ ã“ã“ã§ã€Œ","tags":[],"title":"Find $K$ Closest Elements","type":"post"},{"authors":[],"categories":[],"content":"Search a 2D Array æ˜‡é †ã«æ•´åˆ—ã•ã‚ŒãŸé…åˆ—numsã‹ã‚‰ä¸ãˆã‚‰ã‚ŒãŸtargetã‚’åŠ¹ç‡ã‚ˆãæ¢ã™ã«ã¯äºŒåˆ†æ¢ç´¢ãŒæœ‰åŠ¹ï¼numsã®é•·ã•ã‚’$N$ã¨ã—ã¦ï¼Œ$O(log N)$ã§è¦‹ã¤ã‘ã‚‰ã‚Œã‚‹ï¼\ndef binary_search(nums, target): left = 0 right = len(nums) - 1 while left \u0026lt;= right: mid = (left + right) // 2 if nums[mid] == target: return True elif nums[mid] \u0026lt; target: left = mid + 1 else: right = mid - 1 return False bisectã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚‚ã‚ã‚‹ï¼\nimport bisect nums = [1, 2, 5, 5, 5, 6, 9, 11] # targetä»¥ä¸Šã«ãªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™ bisect.bisect_left(nums, 5) # =\u0026gt; 2 # targetã‚ˆã‚Šå¤§ãããªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™ bisect.bisect(nums, 5) # =\u0026gt; 5 ã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ã¨ã„ã†ãƒã‚°ã‚‰ã›ãªã„å®Ÿè£…ã‚‚ã‚ã‚‹ï¼\n# targetä»¥ä¸Šã«ãªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™ def binary_search(nums, target): ng = -1 ok = len(nums) def is_ok(mid): return target \u0026lt;= nums[mid] while 1 \u0026lt; abs(ng - ok): mid = (ng + ok) // 2 if is_ok(mid): ok = mid else: ng = mid return ok Search a 2D Matrix 1 ref: https://leetcode.com/problems/search-a-2d-matrix/\nä¸€åˆ—ã®æ•´æ•°é…åˆ—ã¨è¦‹ãªã—ã¦äºŒåˆ†æ¢ç´¢ã§ãã‚‹ï¼\nclass Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: h = len(matrix) w = len(matrix[0]) low = 0 high = h * w - 1 while low \u0026lt;= high: mid = (low + high) // 2 num = matrix[mid // w][mid % w] # ã“ã“ãŒå¤§äº‹ if num == target: return True elif num \u0026lt; target: low = mid + 1 else: high = mid - 1 return False Search a 2D Matrix 2 ref: https://leetcode.com/problems/search-a-2d-matrix-ii/\nè§£æ³•1ï¼šå„åˆ—ï¼ˆor å„åˆ—ï¼‰ã«å¯¾ã—ã¦äºŒåˆ†æ¢ç´¢ å„åˆ—ï¼ˆor å„åˆ—ï¼‰ã«å¯¾ã—ã¦äºŒåˆ†æ¢ç´¢ã—ã¦ã„ãï¼ã©ã¡ã‚‰ã®æ–¹å‘ã«äºŒåˆ†æ¢ç´¢ã™ã‚‹ã‹ã¯ä¸ãˆã‚‰ã‚ŒãŸäºŒæ¬¡å…ƒé…åˆ—ã®ç¸¦æ¨ªã®å¤§ãã•ã‚’æ¯”ã¹ã¦æ±ºã‚ã‚Œã°ã„ã„ï¼æ™‚é–“è¨ˆç®—é‡ã¯$O(\\min(h \\log w, w \\log h))$\nclass Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: H = len(matrix) W = len(matrix[0]) for h in range(H): low = 0 high = W - 1 while low \u0026lt;= high: mid = (low + high) // 2 if matrix[h][mid] == target: return True elif matrix[h][mid] \u0026lt; target: low = mid + 1 else: high = mid - 1 return False è§£æ³•2ï¼šå³ä¸Šã‹ã‚‰å·¦ä¸‹ã«å‘ã‹ã£ã¦æ¢ç´¢ç¯„å›²ã‚’çµã‚‹ matrix[i][j]ã®è¦ç´ ãŒtargetã‚ˆã‚Šå°ã•ã„ãªã‚‰ï¼Œtargetã¯i+1è¡Œç›®ä»¥ä¸‹ã«ã‚ã‚‹ã¯ãšï¼ matrix[i][j]ã®è¦ç´ ãŒtargetã‚ˆã‚Šå¤§ãã„ãªã‚‰ï¼Œtargetã¯j-1åˆ—ç›®ä»¥å·¦ã«ã‚ã‚‹ã¯ãšï¼ æ™‚é–“è¨ˆç®—é‡ã¯ï¼Œæœ€æ‚ªã®å ´åˆå³ä¸Šã‹ã‚‰å·¦ä¸‹ã¾ã§ä¸‹orå·¦ã§åˆ°é”ã™ã‚‹ã¾ã§ãƒ«ãƒ¼ãƒ—ãŒå›ã‚‹ã®ã§$O(h + w)$\nclass Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: H = len(matrix) W = len(matrix[0]) # å³ä¸Š h = 0 w = W - 1 while h \u0026lt; H and 0 \u0026lt;= w: if matrix[h][w] == target: return True elif matrix[h][w] \u0026lt; target: h += 1 else: w -= 1 return False è§£æ³•3ï¼šäºŒåˆ†æ¢ç´¢ã£ã½ãæ¢ç´¢é ˜åŸŸã‚’ç‹­ã‚ã¦ã„ã matrix[i][j]ã®è¦ç´ ãŒtargetã‚ˆã‚Šå°ã•ã„ãªã‚‰ï¼Œé ˜åŸŸ(0, 0), (i, j)ï¼ˆ(i, j)ã‚’å³ä¸‹ç«¯ã¨ã™ã‚‹å·¦ä¸Šæ–¹å‘ã®é•·æ–¹å½¢é ˜åŸŸï¼‰ã¯å…¨éƒ¨targetã‚ˆã‚Šå°ã•ã„ã®ã§æ¢ç´¢ç¯„å›²ã‹ã‚‰é™¤å¤–ã§ãã‚‹ï¼ matrix[i][j]ã®è¦ç´ ãŒtargetã‚ˆã‚Šå¤§ãã„ãªã‚‰ï¼Œé ˜åŸŸ(i, j), (h, w)ï¼ˆ(i, j)ã‚’å·¦ä¸Šç«¯ã¨ã™ã‚‹å³ä¸‹æ–¹å‘ã®é•·æ–¹å½¢é ˜åŸŸï¼‰ã¯å…¨éƒ¨targetã‚ˆã‚Šå¤§ãã„ã®ã§æ¢ç´¢ç¯„å›²ã‹ã‚‰é™¤å¤–ã§ãã‚‹ï¼\næ™‚é–“è¨ˆç®—é‡ã®è€ƒå¯Ÿã¯ã‚„ã‚„è¤‡é›‘ï¼æ¼¸åŒ–å¼ã§è¨ˆç®—é‡ã‚’è¡¨ç¾ã§ãã¦ãã‚Œã‚’è§£ãã“ã¨ã§å¾—ã‚‰ã‚Œã‚‹ï¼çµæœã ã‘æ›¸ãã¨$O(h \\log (w/h))$ï¼ˆãŸã ã—$h \\lt w$ï¼‰\nclass Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: H = len(matrix) W = len(matrix[0]) def search_submatrix(top_row, left_col, bottom_row, right_col): if top_row \u0026gt; bottom_row or left_col \u0026gt; right_col: return False mid_row = (top_row + bottom_row) // 2 left = left_col right = right_col while left \u0026lt;= right: mid_col = (left + right) // 2 if matrix[mid_row][mid_col] == target: return True elif matrix[mid_row][mid_col] \u0026lt; target: left = mid_col + 1 else: right = mid_col - 1 upper_right = search_submatrix( top_row, left, mid_row - 1, right_col) lower_left = search_submatrix( mid_row + 1, left_col, bottom_row, right) return upper_right or lower_left return search_submatrix(0, 0, H - 1, W - 1) ","date":1630304613,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1630304613,"objectID":"3bbc4f06b7c11f3cdc12e29f1f2ea533","permalink":"/ja/post/search-a-2d-matrix/","publishdate":"2021-08-30T15:23:33+09:00","relpermalink":"/ja/post/search-a-2d-matrix/","section":"post","summary":"Search a 2D Array æ˜‡é †ã«æ•´åˆ—ã•ã‚ŒãŸé…åˆ—numsã‹ã‚‰ä¸ãˆã‚‰ã‚ŒãŸtargetã‚’åŠ¹ç‡ã‚ˆãæ¢ã™ã«ã¯äºŒåˆ†æ¢ç´¢ãŒæœ‰åŠ¹ï¼numsã®é•·ã•ã‚’$N$ã¨ã—ã¦ï¼Œ$O(log N","tags":[],"title":"Search a 2D Matrix","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ $N \\times N$ã®äºŒæ¬¡å…ƒé…åˆ—matrixãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼matrixã®å„è¡Œãƒ»å„åˆ—ã¯æ˜‡é †ã«æ•´åˆ—ã•ã‚Œã¦ã„ã‚‹ï¼matrixå†…ã®$k$ç•ªç›®ã«å°ã•ã„å€¤ã‚’å–å¾—ã›ã‚ˆï¼\nmin heapã‚’ä½¿ã† ã€Œ$k$ç•ªç›®ã«å°ã•ã„å€¤ã€ç³»ã ã¨heapãŒä½¿ãˆã‚‹ã“ã¨ãŒå¤šã„å°è±¡ï¼ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹è¡Œåˆ—ã‚’èˆã‚ãªãŒã‚‰å€™è£œã¨ãªã‚‹å€¤ã‚’æ¬¡ã€…ã«heapã«çªã£è¾¼ã‚“ã§ï¼Œå…ˆé ­ã‹ã‚‰$k$å€‹å–ã£ã¦ã„ã‘ã°ã„ã„ï¼heapã«çªã£è¾¼ã‚€ã®ã¨å…ˆé ­ã‚’å–ã‚‹ã®ã‚’åŒæ™‚ã«ã‚„ã‚‹ã®ã§ã‚„ã‚„æ··ä¹±ã™ã‚‹ã‹ã‚‚çŸ¥ã‚Œãªã„ï¼\nclass Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -\u0026gt; int: import heapq n = len(matrix) heap = [] for col in range(n): heapq.heappush(heap, (matrix[0][col], 0, col)) for _ in range(k - 1): (_, row, col) = heapq.heappop(heap) if row == n - 1: continue heapq.heappush(heap, (matrix[row+1][col], row+1, col)) return heap[0][0] äºŒåˆ†æ¢ç´¢ ã€Œæ˜‡é †ã€ã‹ã‚‰äºŒåˆ†æ¢ç´¢ãŒä½¿ãˆãã†ï¼\nclass Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -\u0026gt; int: low = matrix[0][0] high = matrix[-1][-1] + 1 while low \u0026lt; high: mid = (low + high) // 2 cnt = 0 j = len(matrix) - 1 for i in range(len(matrix)): while 0 \u0026lt;= j and mid \u0026lt; matrix[i][j]: j -= 1 cnt += (j + 1) if cnt \u0026lt; k: low = mid + 1 else: high = mid return low ã€Œ$k$ç•ªç›®ã«å°ã•ã„å€¤$x$ã‚’æ±‚ã‚ã‚ˆã€ã‚’ã€Œåˆã‚ã¦$x$ä»¥ä¸‹ã®æ•°å­—ãŒ$k$å€‹ä»¥ä¸Šã‚ã‚‹ã‚ˆã†ãª$x$ã‚’æ±‚ã‚ã‚ˆã€ã¨è¨€ã„æ›ãˆã¦ã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ã«è½ã¨ã—è¾¼ã‚€ï¼\nclass Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -\u0026gt; int: ng = matrix[0][0] - 1 ok = matrix[-1][-1] + 1 # ç„¡é§„ã®å¤šã„ is_ok() # def is_ok(mid): # cnt = 0 # for i in range(len(matrix)): # for j in range(len(matrix[0])): # if matrix[i][j] \u0026lt;= mid: # cnt += 1 # else: # break # return k \u0026lt;= cnt # æ”¹è‰¯ç‰ˆ def is_ok(mid): cnt = 0 j = len(matrix) - 1 for i in range(len(matrix)): while 0 \u0026lt;= j and mid \u0026lt; matrix[i][j]: j -= 1 cnt += (j + 1) return k \u0026lt;= cnt while 1 \u0026lt; abs(ok - ng): mid = (ok + ng) // 2 if is_ok(mid): ok = mid else: ng = mid return ok ref  https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/  ","date":1629776217,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1629776217,"objectID":"ccd623b894e1875a188eb1a8adb16bde","permalink":"/ja/post/k-th-smallest-element-in-a-sorted-matrix/","publishdate":"2021-08-24T12:36:57+09:00","relpermalink":"/ja/post/k-th-smallest-element-in-a-sorted-matrix/","section":"post","summary":"å•é¡Œ $N \\times N$ã®äºŒæ¬¡å…ƒé…åˆ—matrixãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼matrixã®å„è¡Œãƒ»å„åˆ—ã¯æ˜‡é †ã«æ•´åˆ—ã•ã‚Œã¦ã„ã‚‹ï¼matrixå†…ã®$k$ç•ªç›®ã«å°ã•ã„å€¤ã‚’å–å¾—","tags":[],"title":"$K$th Smallest Element in a Sorted Matrix","type":"post"},{"authors":[],"categories":[],"content":"1æ¬¡å…ƒã®åº§æ¨™åœ§ç¸®  ä¸ãˆã‚‰ã‚ŒãŸæ•°åˆ—ã‹ã‚‰ï¼Œãã®å¤§å°é–¢ä¿‚ã ã‘ã‚’è¡¨ã™ã‚ˆã†ã«å€¤ã‚’æŒ¯ã‚Šç›´ã™æ“ä½œ å…¥åŠ›ä¾‹ï¼š3, 3, 1, 6, 1 å‡ºåŠ›ä¾‹ï¼š1, 1, 0, 2, 0  è¾æ›¸ã‚’ä½¿ã†å®Ÿè£… ã‚½ãƒ¼ãƒˆã—ã¦ä½ç½®ã‚’è¾æ›¸ã«ä¿å­˜ã—ã¦ãŠã\nmap\u0026lt;int, int\u0026gt; zip; // åœ§ç¸®å‰ -\u0026gt; åœ§ç¸®å¾Œ map\u0026lt;int, int\u0026gt; unzip; // åœ§ç¸®å‰ \u0026lt;- åœ§ç¸®å¾Œ  sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end()); for (int i = 0; i \u0026lt; X.size(); i++) { zip[X[i]] = i; unzip[i] = X[i]; } äºŒåˆ†æ¢ç´¢ã‚’ä½¿ã†å®Ÿè£… ã‚½ãƒ¼ãƒˆã—ã¦ä½ç½®ã‚’ä¿å­˜ã—ã¦ãŠãï¼\nvector\u0026lt;int\u0026gt; vals = X; sort(vals.begin(), vals.end()); vals.erase(unique(vals.begin(), vals.end()), vals.end()); for (int i = 0; i \u0026lt; (int)X.size(); i++) { // å„è¦ç´ ã®ä½ç½®ã‚’äºŒåˆ†æ¢ç´¢ã§æ±‚ã‚ã¦ã‚‹  X[i] = lower_bound(vals.begin(), vals.end(), X[i]) - vals.begin(); } å•é¡Œ  https://atcoder.jp/contests/abc036/tasks/abc036_c  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;int\u0026gt; X(N, 0); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; X[i]; vector\u0026lt;int\u0026gt; vals(N); vals = X; sort(vals.begin(), vals.end()); vals.erase(unique(vals.begin(), vals.end()), vals.end()); for (int i = 0; i \u0026lt; (int)X.size(); i++) { X[i] = lower_bound(vals.begin(), vals.end(), X[i]) - vals.begin(); } for (int i = 0; i \u0026lt; N; i++) cout \u0026lt;\u0026lt; X[i] \u0026lt;\u0026lt; endl; return 0; }  https://atcoder.jp/contests/abc113/tasks/abc113_c  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;int\u0026gt; P(M, 0); vector\u0026lt;int\u0026gt; Y(M, 0); for (int i = 0; i \u0026lt; M; i++) { cin \u0026gt;\u0026gt; P[i] \u0026gt;\u0026gt; Y[i]; P[i] -= 1; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vals(N); for (int i = 0; i \u0026lt; M; i++) { vals[P[i]].push_back(Y[i]); } for (int p = 0; p \u0026lt; N; p++) { sort(vals[p].begin(), vals[p].end()); vals[p].erase(unique(vals[p].begin(), vals[p].end()), vals[p].end()); } for (int i = 0; i \u0026lt; M; i++) { int p = P[i]; printf(\u0026#34;%06d\u0026#34;, p + 1); int id = lower_bound(vals[p].begin(), vals[p].end(), Y[i]) - vals[p].begin(); printf(\u0026#34;%06d\\n\u0026#34;, id + 1); } return 0; } ","date":1628497850,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1628497850,"objectID":"4bff3209be0b00cf0110e2c3e4a79189","permalink":"/ja/post/one-dimention-coordinate-compression/","publishdate":"2021-08-09T17:30:50+09:00","relpermalink":"/ja/post/one-dimention-coordinate-compression/","section":"post","summary":"1æ¬¡å…ƒã®åº§æ¨™åœ§ç¸® ä¸ãˆã‚‰ã‚ŒãŸæ•°åˆ—ã‹ã‚‰ï¼Œãã®å¤§å°é–¢ä¿‚ã ã‘ã‚’è¡¨ã™ã‚ˆã†ã«å€¤ã‚’æŒ¯ã‚Šç›´ã™æ“ä½œ å…¥åŠ›ä¾‹ï¼š3, 3, 1, 6, 1 å‡ºåŠ›ä¾‹ï¼š1, 1, 0, 2, 0 è¾æ›¸ã‚’ä½¿ã†å®Ÿè£… ã‚½ãƒ¼ãƒˆ","tags":[],"title":"1æ¬¡å…ƒã®åº§æ¨™åœ§ç¸®","type":"post"},{"authors":[],"categories":[],"content":"Path Parameterï¼ŒQuery Parameterï¼ŒRequest Bodyã®ä½¿ã„åˆ†ã‘ï¼\nPath Parameter   ã‚ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’è­˜åˆ¥ã™ã‚‹ã®ã«å¿…è¦ãªæƒ…å ±\n  ä¾‹ï¼šGET posts/1ï¼š1æœ¬ç›®ã®ãƒ–ãƒ­ã‚°æŠ•ç¨¿\n  ä¾‹ï¼šGET users/1ï¼š1äººç›®ã®ãƒ¦ãƒ¼ã‚¶\n  Query Parameter   ã‚ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã«å¯¾ã™ã‚‹æ“ä½œã‚’é€šã˜ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ã®ã«å¿…è¦ãªæƒ…å ±\n ã€Œãƒªã‚½ãƒ¼ã‚¹ã«å¯¾ã™ã‚‹æ“ä½œã€ã¨ã¯ä¾‹ãˆã°ã‚½ãƒ¼ãƒˆã™ã‚‹ã¨ã‹æ¤œç´¢ã™ã‚‹ã¨ã‹ç¯„å›²ã‚’çµã‚‹ã¨ã‹ æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ã®æ¡ä»¶    ä¾‹ï¼šGET groups/2?sort=true\u0026amp;limit=20\n ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ã‚½ãƒ¼ãƒˆã—ã¦ä¸Šä½20ä»¶ã‚’å–å¾—    ä¾‹ï¼šhttps://www.google.com/search?q=google\n æ¤œç´¢ã‚¯ã‚¨ãƒª    Request Body  ã‚ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã«å¯¾ã™ã‚‹è¿½åŠ ãƒ»æ›´æ–°ã«å¿…è¦ãªæƒ…å ±  è¿½åŠ ãƒ»æ›´æ–°ã™ã‚‹å†…å®¹è‡ªä½“    ãƒ•ãƒ­ãƒ¼ãƒãƒ£ãƒ¼ãƒˆ if ãƒ‘ãƒ©ãƒ¡ã‚¿ãŒã€Œä¸€æ„ã«ãƒªã‚½ãƒ¼ã‚¹ã‚’ç‰¹å®šã™ã‚‹è­˜åˆ¥å­ã€: PathParameter elif ãƒ‘ãƒ©ãƒ¡ã‚¿ãŒã€Œãƒªã‚½ãƒ¼ã‚¹ã®ã‚½ãƒ¼ãƒˆãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ»æ¤œç´¢ãªã©ã®æ¡ä»¶ã€: QueryParameter elif ãƒ‘ãƒ©ãƒ¡ã‚¿ãŒã€Œãƒªã‚½ãƒ¼ã‚¹ã«å¯¾ã™ã‚‹è¿½åŠ ãƒ»æ›´æ–°ã®æƒ…å ±ã€: RequestBody èªè¨¼æƒ…å ±ã¨ã‹ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã ã¨ã©ã†ã™ã‚‹ã¿ãŸã„ãªè©±ã‚‚ã‚ã‚‹ãŒä»Šã¯ã¨ã‚Šã‚ãˆãšå‰²æ„›ï¼\nRefs  https://tools.ietf.org/html/rfc7231 https://qiita.com/sakuraya/items/6f1030279a747bcce648 https://qiita.com/Shokorep/items/b7697a146cbb1c3e9f0b  ","date":1627280462,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1627280462,"objectID":"b62d6c349326382009d72c64455b8c97","permalink":"/ja/post/path-parameter-query-parameter-request-body/","publishdate":"2021-07-26T15:21:02+09:00","relpermalink":"/ja/post/path-parameter-query-parameter-request-body/","section":"post","summary":"Path Parameterï¼ŒQuery Parameterï¼ŒRequest Bodyã®ä½¿ã„åˆ†ã‘ï¼ Path Parameter ã‚ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’è­˜åˆ¥ã™ã‚‹ã®ã«å¿…è¦ãªæƒ…å ± ä¾‹ï¼šGET po","tags":["API","REST"],"title":"Path Parameter, Query Parameter, Request Body","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ•´æ•°é…åˆ—numsãŒãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ãã“ã§ï¼Œ$i$ç•ªç›®ã®è¦ç´ ãŒnumsã®$i$ç•ªç›®ä»¥å¤–ã®è¦ç´ ã®ç©ã‹ã‚‰ãªã‚‹é…åˆ—answerã‚’è¿”ã™é–¢æ•°ã‚’æ›¸ã‘ï¼\nç­”ãˆ answer[i]ã‚’å®šç¾©ã©ãŠã‚Šã«è¨ˆç®—ã™ã‚‹ã¨å…¨ä½“ã§$O(n^2)$ï¼ã“ã‚Œã‚’å›é¿ã—ãŸã„ï¼answer[i]ã¨answer[i+1]ã®ãã‚Œãã‚Œã®å› æ•°ã¯å…±é€šã—ã¦ã„ã‚‹éƒ¨åˆ†ãŒå¤šã„ã®ã§ï¼Œç„¡é§„ãªè¨ˆç®—ã‚’ã—ã¦ã„ãã†ï¼ãã“ã§ç´¯ç©ç©ï¼ˆç´¯ç©å’Œã‹ã‚‰ã®é€ èªï¼‰ã‚’è€ƒãˆã¦ã¿ã‚‹ã¨ã†ã¾ãã„ããã†ï¼\nclass Solution: def productExceptSelf(self, nums: List[int]) -\u0026gt; List[int]: p = 1 n = len(nums) output = [] for i in range(n): output.append(p) p = p * nums[i] p = 1 for i in range(n-1, -1, -1): output[i] = output[i] * p p = p * nums[i] return output ","date":1625724718,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1625724718,"objectID":"18bda75a8332b314f1cf86193613290c","permalink":"/ja/post/product-of-array-expect-self/","publishdate":"2021-07-08T15:11:58+09:00","relpermalink":"/ja/post/product-of-array-expect-self/","section":"post","summary":"å•é¡Œ æ•´æ•°é…åˆ—numsãŒãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ãã“ã§ï¼Œ$i$ç•ªç›®ã®è¦ç´ ãŒnumsã®$i$ç•ªç›®ä»¥å¤–ã®è¦ç´ ã®ç©ã‹ã‚‰ãªã‚‹é…åˆ—answerã‚’è¿”ã™é–¢æ•°ã‚’æ›¸ã‘ï¼ ç­”","tags":[],"title":"Product of Array Expect Self","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸæ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼å„è¦ç´ ã®äºŒä¹—ã‹ã‚‰ãªã‚‹æ˜‡é †ã®æ•´æ•°é…åˆ—ã‚’æ±‚ã‚ã‚ˆ\nç­”ãˆ  $O(n \\log n)$ãªç­”ãˆ  absã‚’åŸºæº–ã«numsã‚’ã‚½ãƒ¼ãƒˆã—ã¦äºŒä¹—    class Solution: def sortedSquares(self, nums: List[int]) -\u0026gt; List[int]: nums = sorted(nums, key=lambda x: abs(x)) return list(map(lambda x: x**2, nums))  $O(n)$ãªç­”ãˆ  left/rightãƒã‚¤ãƒ³ã‚¿ã¨dequeã‚’ä½¿ã†  dequeï¼šä¸¡ç«¯ã¸ã®è¦ç´ ã®è¿½åŠ ãŒ$O(1)$ãªãƒ‡ãƒ¼ã‚¿æ§‹é€    ã€æ ¼è¨€ã€‘ã€Œæ˜‡é †ã€ã‚’è¦‹ãŸã‚‰binary searchã‹two pointer    class Solution: def sortedSquares(self, nums: List[int]) -\u0026gt; List[int]: ans = collections.deque() l, r = 0, len(nums) - 1 while l \u0026lt;= r: left, right = abs(nums[l]), abs(nums[r]) if right \u0026lt; left: ans.appendleft(left ** 2) l += 1 else: ans.appendleft(right ** 2) r -= 1 return list(ans) ","date":1625478469,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1625478469,"objectID":"40ffa2b80b7f9aff08b003afb4d47f54","permalink":"/ja/post/squares-of-a-sorted-array/","publishdate":"2021-07-05T18:47:49+09:00","relpermalink":"/ja/post/squares-of-a-sorted-array/","section":"post","summary":"å•é¡Œ æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸæ•´æ•°é…åˆ—numsãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼å„è¦ç´ ã®äºŒä¹—ã‹ã‚‰ãªã‚‹æ˜‡é †ã®æ•´æ•°é…åˆ—ã‚’æ±‚ã‚ã‚ˆ ç­”ãˆ $O(n \\log n)$ãªç­”ãˆ absã‚’åŸºæº–ã«numsã‚’ã‚½","tags":[],"title":"Squares of a Sorted Array","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ äºŒåˆ†æœ¨rootï¼ŒsubRootãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼subRootãŒrootã®éƒ¨åˆ†æœ¨ã§ã‚ã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼\nç­”ãˆ  å†å¸°çš„ã«è§£ã  æ ¹ã‹ã‚‰å†å¸°çš„ã«å€¤ãŒä¸€è‡´ã—ã¦ã„ã‚‹ã‹ã‚’ç¢ºèª isSubtree(root, subRoot): rootã‚’æ ¹ã¨ã—ã¦subRootã¨é‡ã­ã‚‹ check(s, t): sã‚’æ ¹ã¨ã™ã‚‹æœ¨ã¨tã‚’æ ¹ã¨ã™ã‚‹æœ¨ãŒé‡ãªã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹ è¨ˆç®—é‡  rootã®é ‚ç‚¹æ•°ã‚’$s$ï¼ŒsubRootã®é ‚ç‚¹æ•°ã‚’$t$ã¨ã™ã‚‹ã¨ï¼Œ$O(s \\times t)$      # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSubtree(self, root: TreeNode, subRoot: TreeNode) -\u0026gt; bool: def check(s, t): if s is not None and t is not None: return s.val == t.val and check(s.left, t.left) and check(s.right, t.right) return s is t if root is None: return False return check(root, subRoot) or self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)  merkle tree  æœ¨æ§‹é€ ã‚’ãƒãƒƒã‚·ãƒ¥é–¢æ•°ã§ã¾ã¨ã‚ã‚‹ ãƒãƒƒã‚·ãƒ¥é–¢æ•°ãŒè¡çªã—ãªã„é™ã‚Šæ­£è§£ è¨ˆç®—é‡  rootã®é ‚ç‚¹æ•°ã‚’$s$ï¼ŒsubRootã®é ‚ç‚¹æ•°ã‚’$t$ã¨ã™ã‚‹ã¨ï¼Œ$O(s + t)$      # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSubtree(self, root: TreeNode, subRoot: TreeNode) -\u0026gt; bool: from hashlib import sha256 def _hash(x): S = sha256() S.update(str.encode(x)) return S.hexdigest() def merkle(node): if node is None: return \u0026#34;\u0026#34; left_merkle = merkle(node.left) right_merkle = merkle(node.right) node.merkle = _hash(left_merkle + str(node.val) + right_merkle) return node.merkle merkle(root) merkle(subRoot) def dfs(node): if node is None: return False return node.merkle == subRoot.merkle or dfs(node.left) or dfs(node.right) return dfs(root) Ref  https://leetcode.com/problems/subtree-of-another-tree/  ","date":1625475424,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1625475424,"objectID":"ac8d1d4e916e61866a4d92e4d223d923","permalink":"/ja/post/subtree-of-another-tree/","publishdate":"2021-07-05T17:57:04+09:00","relpermalink":"/ja/post/subtree-of-another-tree/","section":"post","summary":"å•é¡Œ äºŒåˆ†æœ¨rootï¼ŒsubRootãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼subRootãŒrootã®éƒ¨åˆ†æœ¨ã§ã‚ã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼ ç­”ãˆ å†å¸°çš„ã«è§£ã æ ¹ã‹ã‚‰å†å¸°çš„ã«å€¤ãŒä¸€è‡´ã—","tags":[],"title":"Subtree of Another Tree","type":"post"},{"authors":[],"categories":[],"content":"ã€Œä¸ãˆã‚‰ã‚ŒãŸé…åˆ—ã«å¯¾ã—ã¦ï¼Œã‚ã‚‹ç¯„å›²ã«ã¤ã„ã¦ã®å¤§é‡ã®ã‚¯ã‚¨ãƒªã‚’å‡¦ç†ã—ã‚ã€ã¨ã„ã†ã¨ãã«ã¯ä»¥ä¸‹ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ãŒæœ‰åŠ¹ï¼åŸºæœ¬çš„ã«ã¯ã€Œå¤§é‡ã®ã‚¯ã‚¨ãƒªã€ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã«ï¼Œ$O(N)$ãã‚‰ã„ã®å‰å‡¦ç†ã‚’ã—ã¦ã‚¯ã‚¨ãƒªè‡ªä½“ã«ã¯$O(1)$ã§ç­”ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã¨ã„ã†ã®ãŒåŸºæœ¬æˆ¦ç•¥ï¼\n ç´¯ç©å’Œ Binary Index Tree Segment Tree  ç´¯ç©å’Œ ã€Œç´¯ç©å’Œã®å·®ã€ãŒã€Œç¯„å›²ã®å’Œã€ã«ãªã‚‹ã¨ã„ã†ã“ã¨ã‚’åˆ©ç”¨ï¼ç´¯ç©å’Œã®ä½œã‚Šæ–¹ã¯æ·»å­—ãŒç…©é›‘ã«ãªã‚Šã‚„ã™ã„ã®ã§ï¼Œæ¬¡ã®ã‚ˆã†ã«ä½œã‚‹ã¨æ±ºã‚ã¦ã—ã¾ã†ã¨æ¥½ï¼\né•·ã•Nã®æ•´æ•°é…åˆ—arrã®ç´¯ç©å’Œaccumã¯\n accum[0] = 0 accum[i+1] = accum[i] + arr[i]  ã“ã®ã¨ãï¼Œç¯„å›²[left, right)ã«ã¤ã„ã¦\n arr[left:right] = accum[right] - accum[left]    ç´¯ç©å’Œ   ã“ã“ã§æ„è­˜ã™ã¹ãã¯ï¼Œ\n accum[0] = 0 ç¯„å›²ã¯å³é–‹åŒºé–“  å•é¡Œä¸Šã§ç¯„å›²ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ãã¯å·¦å³é–‰åŒºé–“ã§ä¸ãˆã‚‰ã‚Œã‚‹ã“ã¨ãŒå¤šã„ã®ã§ï¼Œãã®æ™‚ã¯accumã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§1è¶³ã™ãªã‚Šã—ã¦å¯¾å¿œã™ã‚‹    ä¾‹é¡Œ1  é•·ã•$N$ã®æ•´æ•°åˆ—$A$ãŒã‚ã‚Šã¾ã™ï¼$A$ã®ç©ºã§ãªã„é€£ç¶šã™ã‚‹éƒ¨åˆ†åˆ—ã§ã‚ã£ã¦ï¼Œãã®ç·å’ŒãŒ$0$ã«ãªã‚‹ã‚‚ã®ã®å€‹æ•°ã‚’æ±‚ã‚ã¦ãã ã•ã„ï¼ãŸã ã—ï¼Œã“ã“ã§æ•°ãˆã‚‹ã®ã¯éƒ¨åˆ†åˆ—ã®å–ã‚Šå‡ºã—æ–¹ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ï¼ã¤ã¾ã‚Šï¼Œã‚ã‚‹$2$ã¤ã®éƒ¨åˆ†åˆ—ãŒåˆ—ã¨ã—ã¦åŒã˜ã§ã‚‚ï¼Œå–ã‚Šå‡ºã—ãŸä½ç½®ãŒç•°ãªã‚‹ãªã‚‰ã°ï¼Œãã‚Œã‚‰ã¯åˆ¥ã€…ã«æ•°ãˆã‚‹ã‚‚ã®ã¨ã—ã¾ã™ï¼\nfrom https://atcoder.jp/contests/agc023/tasks/agc023_a\n ç´¯ç©å’Œã‚’ã¨ã£ã¦ï¼Œé›†è¨ˆã™ã‚‹ï¼\nfrom collections import Counter N = int(input()) A = list(map(int, input().split(\u0026#34; \u0026#34;))) accum = [0 for _ in range(len(A) + 1)] for i in range(len(A)): accum[i+1] = accum[i] + A[i] freq = Counter(accum) ans = 0 for v in freq.values(): ans += v * (v - 1) / 2 print(ans) ä¾‹é¡Œ2  Given an integer array nums, handle multiple queries of the following type:\nCalculate the sum of the elements of nums between indices left and right inclusive where left \u0026lt;= right. Implement the NumArray class:\n NumArray(int[] nums) Initializes the object with the integer array nums. int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).  from https://leetcode.com/problems/range-sum-query-immutable/\n ã¾ã•ã—ãç´¯ç©å’Œã‚’ä½¿ã£ã¦ã»ã—ã„ã¨ã„ã†æ„å›³ãŒè¦‹ãˆã‚‹å•é¡Œï¼å•é¡Œæ–‡ä¸­ã§ã¯ç¯„å›²ãŒé–‰åŒºé–“ã§è¡Œã‚ã‚Œã¦ã„ã‚‹ã®ã§ï¼Œãã‚Œã«åˆã‚ã›ã¦sumRangeå†…ã§rightã®æ‰±ã„ã«æ³¨æ„ã™ã‚‹ï¼\nclass NumArray: def __init__(self, nums: List[int]): self.nums = nums accums = [0 for _ in range(len(nums) + 1)] for i in range(0, len(nums)): accums[i + 1] = accums[i] + nums[i] self.accums = accums def sumRange(self, left: int, right: int) -\u0026gt; int: return self.accums[right + 1] - self.accums[left] # Your NumArray object will be instantiated and called as such: # obj = NumArray(nums) # param_1 = obj.sumRange(left,right) äºŒæ¬¡å…ƒç´¯ç©å’Œ ã¤ã„ã§ãªã®ã§äºŒæ¬¡å…ƒé…åˆ—ã®ç´¯ç©å’Œã«ã¤ã„ã¦ã‚‚è¨˜è¼‰ã—ã¦ãŠãï¼\näºŒæ¬¡å…ƒé…åˆ—AãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼Œ[x1, x2) x [y1, y2)ã§ã‚ã‚‹é•·æ–¹å½¢ã®ç¯„å›²å†…ã®è¦ç´ ã®ç·å’Œã‚’æ±‚ã‚ã‚‹ã‚¯ã‚¨ãƒªã‚’è€ƒãˆã‚‹ï¼\nç´¯ç©å’Œaccumã¯\n accum[0][0] = 0 accum[i][j] = [0, i) x [0, j)ã®é•·æ–¹å½¢ç¯„å›²ã®ç·å’Œ  accum[i+1][j+1] = accum[i+1][j] + accum[i][j+1] - accum[i][j] + A[i][j]    ã“ã†ã™ã‚‹ã“ã¨ã§ï¼Œ[x1, x2) x [y1, y2)ã§ã‚ã‚‹é•·æ–¹å½¢ã®ç¯„å›²å†…ã®è¦ç´ ã®ç·å’Œã¯ï¼Œaccum[x2][y2] - accum[x1][y2] - accum[x2][y1] + accum[x1][y1]ã§æ±‚ã‚ã‚‰ã‚Œã‚‹ï¼\nä¾‹é¡Œ  Given a 2D matrix matrix, handle multiple queries of the following type:\nCalculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Implement the NumMatrix class:\nNumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\nfrom https://leetcode.com/problems/range-sum-query-2d-immutable/\n class NumMatrix: def __init__(self, matrix: List[List[int]]): self.matrix = matrix H = len(matrix) W = len(matrix[0]) accum = [[0 for _ in range(W + 1)] for _ in range(H + 1)] for h in range(0, H): for w in range(0, W): accum[h + 1][w + 1] = accum[h][w + 1] + accum[h + 1][w] - accum[h][w] + matrix[h][w] self.accum = accum def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -\u0026gt; int: row2 += 1 col2 += 1 return self.accum[row2][col2] - self.accum[row2][col1] - self.accum[row1][col2] + self.accum[row1][col1] # Your NumMatrix object will be instantiated and called as such: # obj = NumMatrix(matrix) # param_1 = obj.sumRegion(row1,col1,row2,col2) Segment Tree é…åˆ—ã‚’ã€ŒåŒºé–“ã€ã‚’å˜ä½ã«å®Œå…¨äºŒåˆ†æœ¨ã§ç®¡ç†ã™ã‚‹ï¼\n1-indexãªé…åˆ—ä¸Šã«å®Œå…¨äºŒåˆ†æœ¨ã‚’å®Ÿè£…ã™ã‚‹ï¼é ‚ç‚¹iã®å­ä¾›ã¯é ‚ç‚¹2*iï¼Œé ‚ç‚¹2*i + 1ï¼\n  ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨ã¯é…åˆ—ã§å®Ÿè£…ã™ã‚‹   updateã‚¯ã‚¨ãƒªã§ã¯ä¸Šã«ã•ã‹ã®ã¼ã£ã¦ã„ããªãŒã‚‰æœ¨ã‚’æ›´æ–°ã™ã‚‹ï¼\n  updateã‚¯ã‚¨ãƒªç³»   rangeã‚¯ã‚¨ãƒªã§ã¯ä¸‹ã‹ã‚‰è©²å½“ã™ã‚‹ç¯„å›²ã‚’æ‹¾ã£ã¦ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸ï¼\n  rangeã‚¯ã‚¨ãƒªç³»   ãªãŠï¼Œã‚¯ã‚¨ãƒªæ™‚ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯0-indexã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ï¼\nclass SegmentTree: def __init__(self, init_list, func, ele): \u0026#34;\u0026#34;\u0026#34; init_list: ç®¡ç†å¯¾è±¡ã®æ•´æ•°é…åˆ— func: åŒºé–“ã«å¯¾ã—ã¦å®Ÿè¡Œã™ã‚‹å‡¦ç†ï¼ˆmin/max/sum/productãªã©ï¼‰ ele: å˜ä½å…ƒ \u0026#34;\u0026#34;\u0026#34; n = len(init_list) self.func = func self.ele = ele self.num = 1 \u0026lt;\u0026lt; (n - 1).bit_length() self.tree = [ele for _ in range(2 * self.num)] for i in range(n): self.tree[i + self.num] = init_list[i] # set leaf for i in range(self.num - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos, val): \u0026#34;\u0026#34;\u0026#34; init_listã®posç•ªç›®ã®è¦ç´ ã‚’valã«æ›´æ–° note: posã¯0-origin \u0026#34;\u0026#34;\u0026#34; pos += self.num self.tree[pos] = val while 1 \u0026lt; pos: self.tree[pos \u0026gt;\u0026gt; 1] = self.func(self.tree[pos], self.tree[pos ^ 1]) pos \u0026gt;\u0026gt;= 1 def query(self, left, right): \u0026#34;\u0026#34;\u0026#34; init_listã®[left, right)ã«å¯¾ã—ã¦funcã—ãŸçµæœã‚’è¿”ã™ note: left, rightã¯0-origin \u0026#34;\u0026#34;\u0026#34; ret = self.ele left += self.num right += self.num while left \u0026lt; right: if left \u0026amp; 1: ret = self.func(ret, self.tree[left]) left += 1 if right \u0026amp; 1: ret = self.func(ret, self.tree[right - 1]) left \u0026gt;\u0026gt;= 1 right \u0026gt;\u0026gt;= 1 return ret lst = [5, 3, 7, 9, 1, 4, 6, 2] seg = SegmentTree(init_list=lst, func=min, ele=float(\u0026#34;+inf\u0026#34;)) print(seg.query(2, 5)) # =\u0026gt; 1 seg.update(2, 0) # lst[2] = 0 print(seg.query(2, 5)) # =\u0026gt; 0 ä¾‹é¡Œ  Given an integer array nums, handle multiple queries of the following types:\n Update the value of an element in nums. Calculate the sum of the elements of nums between indices left and right inclusive where left \u0026lt;= right. Implement the NumArray class:   NumArray(int[] nums) Initializes the object with the integer array nums. void update(int index, int val) Updates the value of nums[index] to be val. int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).  from https://leetcode.com/problems/range-sum-query-mutable/\n è¦ã™ã‚‹ã«func=sumãªã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨ã‚’å®Ÿè£…ã—ã‚ã¨ã„ã†å•é¡Œï¼\nclass NumArray: def __init__(self, nums: List[int]): n = len(nums) self.num = 1 \u0026lt;\u0026lt; (n - 1).bit_length() self.tree = [0 for _ in range(2 * self.num)] for i in range(n): self.tree[i + self.num] = nums[i] for i in range(self.num - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index: int, val: int) -\u0026gt; None: index += self.num self.tree[index] = val while 1 \u0026lt; index: self.tree[index \u0026gt;\u0026gt; 1] = self.tree[index] + self.tree[index ^ 1] index \u0026gt;\u0026gt;= 1 def sumRange(self, left: int, right: int) -\u0026gt; int: right += 1 ret = 0 left += self.num right += self.num while left \u0026lt; right: if left \u0026amp; 1: ret += self.tree[left] left += 1 if right \u0026amp; 1: ret += self.tree[right - 1] left \u0026gt;\u0026gt;= 1 right \u0026gt;\u0026gt;= 1 return ret # Your NumArray object will be instantiated and called as such: # obj = NumArray(nums) # obj.update(index,val) # param_2 = obj.sumRange(left,right) Binary Index Treeï¼ˆBITï¼‰ ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨ã‹ã‚‰æ©Ÿèƒ½ã‚’å‰Šãè½ã¨ã—ãŸæ„Ÿã˜ï¼\n  Binary Index Tree    BITã¯1-indexãªé…åˆ—ä¸Šã«ä½œã‚‹ updateã‚¯ã‚¨ãƒª  æ¬¡ã«æ›´æ–°ã™ã¹ãBITä¸Šã®ä½ç½®ã¯ï¼Œç¾åœ¨è¦‹ã¦ã„ã‚‹ä½ç½®ã«ãã®ä½ç½®ãŒç›¸å½“ã™ã‚‹åŒºé–“ã®é•·ã•ã‚’è¶³ã™ã¨å‡ºã¦ãã‚‹ BITä¸Šã®ä½ç½®posã«ã¤ã„ã¦ï¼Œposã®æ‹…å½“ã™ã‚‹ç¯„å›²ã®é•·ã•ã¯pos \u0026amp; -pos  posã®ãƒ“ãƒƒãƒˆåˆ—ã®1ãŒç«‹ã£ã¦ã‚‹ä¸€ç•ªå°ã•ã„æ¡ã‚’å–ã£ã¦ã‚‹     rangeã‚¯ã‚¨ãƒª  BITã«å¯¾ã™ã‚‹rangeã‚¯ã‚¨ãƒªã¯ã€Œ[0, idx)ã®ç¯„å›²ã®å’Œã€ã¨ã„ã†ã‚¯ã‚¨ãƒª  ã“ã‚Œã‚’2ã¤çµ„ã¿åˆã‚ã›ã‚Œã°ä»»æ„ã®ç¯„å›²ã®å’ŒãŒå–ã‚Œã‚‹ [idx0, idx1) = [0, idx1) - [0, idx0)   æ¬¡ã«è¶³ã™ã¹ãBITä¸Šã®ä½ç½®ã¯ï¼Œç¾åœ¨è¦‹ã¦ã„ã‚‹ä½ç½®ã«ãã®ä½ç½®ãŒç›¸å½“ã™ã‚‹åŒºé–“ã®é•·ã•ã‚’å¼•ãã¨å‡ºã¦ãã‚‹    class BIT: def __init__(self, n): self.size = n self.tree = [0 for _ in range(n + 1)] # 0ã§åˆæœŸåŒ– def add(self, pos, val): \u0026#34;\u0026#34;\u0026#34; ä½ç½®posã®è¦ç´ ã«valã‚’åŠ ãˆã‚‹ note: posã¯0-origin \u0026#34;\u0026#34;\u0026#34; while pos \u0026lt;= self.size: self.tree[pos] += val pos += (pos \u0026amp; -pos) def range(self, pos): \u0026#34;\u0026#34;\u0026#34; ç¯„å›²[0, pos)ã®å’Œã‚’è¿”ã™ note: posã¯0-origin \u0026#34;\u0026#34;\u0026#34; ret = 0 while 0 \u0026lt; pos: ret += self.tree[pos] pos -= (pos \u0026amp; -pos) Refs  https://qiita.com/drken/items/56a6b68edef8fc605821  ç´¯ç©å’Œ   https://atcoder.jp/contests/agc023/tasks/agc023_a https://leetcode.com/problems/range-sum-query-immutable/ https://leetcode.com/problems/range-sum-query-mutable/ https://leetcode.com/problems/range-sum-query-2d-immutable/ ğŸ”’ https://leetcode.com/problems/range-sum-query-2d-mutable/ https://www.slideshare.net/iwiwi/ss-3578491  ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨   https://qiita.com/takayg1/items/c811bd07c21923d7ec69  ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨ã®Pythonå®Ÿè£…   http://hos.ac/slides/20140319_bit.pdf  BIT   https://ikatakos.com/pot/programming_algorithm/data_structure/binary_indexed_tree  BIT    ","date":1624959257,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1624959257,"objectID":"674bd2b79bddcdc9f59ff176e0141a3c","permalink":"/ja/post/range-query/","publishdate":"2021-06-29T18:34:17+09:00","relpermalink":"/ja/post/range-query/","section":"post","summary":"ã€Œä¸ãˆã‚‰ã‚ŒãŸé…åˆ—ã«å¯¾ã—ã¦ï¼Œã‚ã‚‹ç¯„å›²ã«ã¤ã„ã¦ã®å¤§é‡ã®ã‚¯ã‚¨ãƒªã‚’å‡¦ç†ã—ã‚ã€ã¨ã„ã†ã¨ãã«ã¯ä»¥ä¸‹ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ãŒæœ‰åŠ¹ï¼åŸºæœ¬çš„ã«ã¯ã€Œå¤§é‡ã®ã‚¯ã‚¨ãƒªã€ã‚’å‡¦ç†ã™","tags":[],"title":"Range Query","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ 0ä»¥ä¸Šnumä»¥ä¸‹ã®æ•°å­—ã‚’2é€²æ•°ã§è¡¨è¨˜ã—ãŸã¨ãã®ï¼Œãƒ“ãƒƒãƒˆ1ã®å€‹æ•°ã‚’è¨ˆç®—ã—ï¼Œé•·ã•nums + 1ã®é…åˆ—ã«ã—ã¦è¿”ã›ï¼\nç­”ãˆ iã‚’2é€²æ•°è¡¨è¨˜ã—ãŸã¨ãã®1ã®å€‹æ•°ã‚’f[i]ã¨ã™ã‚‹ã¨ï¼Œ\n f[i] = f[i // 2] + i % 2  ãŒæˆç«‹ã™ã‚‹ï¼\ndef solve(num): table = [0 for _ in range(num + 1)] for i in range(1, num + 1): table[i] = table[i \u0026gt;\u0026gt; 1] + (i \u0026amp; 1) return table print(solve(5)) # =\u0026gt; [0, 1, 1, 2, 1, 2] pythonã®æ¨™æº–ã®ä¾¿åˆ©é–¢æ•°ã‚’ä½¿ã†ã¨ç°¡å˜ã ã‘ã©ã“ã‚Œã¯æ±‚ã‚ã‚‰ã‚Œã¦ã„ãªã•ãã†ï¼\ndef solve(num): return [bin(i).count(\u0026#39;1\u0026#39;) for i in range(num + 1)] print(solve(5)) # =\u0026gt; [0, 1, 1, 2, 1, 2] ","date":1624953114,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1624953114,"objectID":"a19760829a2a05c42b84831139f236d6","permalink":"/ja/post/counting-bits/","publishdate":"2021-06-29T16:51:54+09:00","relpermalink":"/ja/post/counting-bits/","section":"post","summary":"å•é¡Œ 0ä»¥ä¸Šnumä»¥ä¸‹ã®æ•°å­—ã‚’2é€²æ•°ã§è¡¨è¨˜ã—ãŸã¨ãã®ï¼Œãƒ“ãƒƒãƒˆ1ã®å€‹æ•°ã‚’è¨ˆç®—ã—ï¼Œé•·ã•nums + 1ã®é…åˆ—ã«ã—ã¦è¿”ã›ï¼ ç­”ãˆ iã‚’2é€²æ•°è¡¨è¨˜ã—ãŸã¨ãã®1","tags":[],"title":"Counting Bits","type":"post"},{"authors":[],"categories":[],"content":"Latencyã¨Throughtputã¨Bandwidthã®é•ã„ãŒã‚ˆãåˆ†ã‹ã‚‰ãªã‹ã£ãŸã®ã§èª¿ã¹ã¦ã¿ã¾ã—ãŸï¼\nLatency   Latency measures delay. Delay is simply the time taken for a data packet to reach its destination after being sent.\n ã‚ã‚‹ãƒ‘ã‚±ãƒƒãƒˆAã‚’åœ°ç‚¹Sã‹ã‚‰åœ°ç‚¹Tã¸é€ã£ãŸã¨ãã«ä½•ç§’ã‹ã‹ã‚‹ã‹    round-tripã§æ¸¬ã‚‹ã“ã¨ãŒå¤šã„\n ã€Œåœ°ç‚¹S -\u0026gt; åœ°ç‚¹T -\u0026gt; åœ°ç‚¹Sã€ã«ã‹ã‹ã‚‹æ™‚é–“    LatencyãŒå¤§ãã„ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¯æ‚ªã„\n Latencyå¤§ -\u0026gt; ä¸€ã¤ã®ãƒ‘ã‚±ãƒƒãƒˆã®ä¼é€ã«è¦ã™ã‚‹æ™‚é–“ãŒå¤§ãã„    Throughput   the amount of data able to be transmitted and received during a specific time period.\n ä¸€å®šã®æ™‚é–“å¹…ã§é€å—ä¿¡ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ã®é‡    throughput provides a practical measurement of the actual delivery of packets.\n ç†è«–å€¤ã§ã¯ãªãã¦å®Ÿæ¸¬å€¤    ã‚ˆãä½¿ã‚ã‚Œã‚‹å˜ä½ã¯bits per second = bps\n ã‚‚ã—ãã¯packets per second    throughtputãŒè½ã¡ã¦ã‚‹ã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å†…ã§ãƒ‘ã‚±ãƒ­ã‚¹ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„\n  Bandwidth   the amount of data that can be transmitted and received during a specific period of time.\n ä¸€å®šã®æ™‚é–“å¹…ã§é€å—ä¿¡ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ã®é‡    ã‚ˆãä½¿ã‚ã‚Œã‚‹å˜ä½ã¯bits per second = bps\n gigabit per second = Gbps megabit per second = Mbps    high bandwidth doesnâ€™t necessarily guarantee optimal network performance.\n bandwidthãŒå¤§ãã„ã“ã¨ãŒå³åº§ã«throughtputãŒå¤§ãã„ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã¨ã¯é™ã‚‰ãªã„ï¼    Bandwidth measures capacity, not speed.\n è»Šã§è¨€ã†ãªã‚‰ï¼Œã€Œã“ã®è»Šã¯æ™‚é€Ÿ500kmå‡ºã›ã¾ã™ã€ã¯bandwidth    ISPãŒå¸¯åŸŸã§ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®æ€§èƒ½ã‚’æ¨ã—ã¦ãã‚‹ã“ã¨ãŒã“ã®èª¤è§£ã‚’åºƒã‚ã¦ã—ã¾ã£ã¦ã„ã‚‹ã¨ã„ã†æŒ‡æ‘˜ï¼\n  bandwidthãŒå¤§ãã„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ãˆã‚‹ã¨ï¼Œä»»æ„ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å¤§ãã„ãƒ‡ãƒ¼ã‚¿ã‚’è»¢é€ã—ã‚ˆã†ã¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼Œã¨ã„ã†ã“ã¨ã§ã‚ã£ã¦ï¼Œãã®è»¢é€ãŒç¬æ™‚ã«çµ‚ã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã¯ãªã„ï¼\n  Throughput vs Latency  Throughtputã¨Latencyã¯ã‚³ã‚¤ãƒ³ã®è¡¨è£ã¿ãŸã„ãªã‚‚ã® LatencyãŒå¤§ãã‘ã‚Œã°Throughputã¯å°ã•ã„ ThroughputãŒå°ã•ã‘ã‚Œã°LatencyãŒå¤§ãã„ã ã‚ã†  Latency vs Bandwidth  Latencyã‚‚Bandwidthã‚‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®æ€§èƒ½ã‚’æ¸¬ã‚‹æŒ‡æ¨™ Latencyã¯åœŸç®¡ã®é•·ã•  åœŸç®¡ãŒé•·ã‘ã‚Œã°ãƒ‡ãƒ¼ã‚¿ãŒåœŸç®¡ã«å…¥ã£ã¦æŠœã‘ã‚‹ã¾ã§ã«å¿…è¦ãªæ™‚é–“ãŒé•·ããªã‚‹   Bandwidthã¯åœŸç®¡ã®ç›´å¾„  åœŸç®¡ã®ç›´å¾„ãŒå¤§ãããªã‚Œã°ä¸€åº¦ã«ã‚ˆã‚Šå¤šãã®ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Œã‚‹   ã—ã°ã—ã°ã€ŒBandwidthãŒã€‡ã€‡ã ã‹ã‚‰LatencyãŒâ–³â–³ã€  BandwidthãŒå¤§ãã„ã‹ã‚‰LatencyãŒå°ã•ã„ BandwidthãŒå°ã•ã„ã‹ã‚‰LatencyãŒå¤§ãã„    Bandwidth vs Throughput  Bandwidthã¯åœŸç®¡ã®ç›´å¾„ Throughtputã¯ãã®åœŸç®¡ã«æµã‚Œã¦ã„ã‚‹æ°´ã®é‡ bandwidth represents the theoretical measurement of the highest amount of data packets able to be transferred, and throughput represents the actual amount of packets successfully delivered. Bandwidthã¯ç†è«–å€¤ï¼ŒThroughtputã¯å®Ÿæ¸¬å€¤ï¼  refs  https://www.dnsstuff.com/latency-throughput-bandwidth  ","date":1623841599,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1623841599,"objectID":"8d299886a4c994477d439a1040a14008","permalink":"/ja/post/latency-vs-throughput-vs-bandwidth/","publishdate":"2021-06-16T20:06:39+09:00","relpermalink":"/ja/post/latency-vs-throughput-vs-bandwidth/","section":"post","summary":"Latencyã¨Throughtputã¨Bandwidthã®é•ã„ãŒã‚ˆãåˆ†ã‹ã‚‰ãªã‹ã£ãŸã®ã§èª¿ã¹ã¦ã¿ã¾ã—ãŸï¼ Latency Latency measures delay. Delay is simply the time taken for a data packet to reach its destination","tags":[],"title":"Latency vs Throughput vs Bandwidth","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ä¸€æ™‚å¤‰æ•°ã‚’ä½¿ç”¨ã—ãªã„ã§æ•°å­—ã®äº¤æ›ã‚’å®Ÿè£…ã›ã‚ˆï¼\nç­”ãˆ  å·®ã‚’ã†ã¾ãä½¿ã†ã‚„ã‚Šæ–¹  a = 10 b = 5 print(\u0026#34;a: {}, b: {}\u0026#34;.format(a, b)) a = a - b b = a + b a = b - a print(\u0026#34;a: {}, b: {}\u0026#34;.format(a, b))  xorã‚’ã†ã¾ãä½¿ã†ã‚„ã‚Šæ–¹  åŒã˜æ•°å­—åŒå£«ã®xorã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã‚‹ã“ã¨ã‚’åˆ©ç”¨ã™ã‚‹    a = 10 b = 5 print(\u0026#34;a: {}, b: {}\u0026#34;.format(a, b)) a = a ^ b b = a ^ b a = a ^ b print(\u0026#34;a: {}, b: {}\u0026#34;.format(a, b)) ","date":1622965949,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1622965949,"objectID":"d90c5a85dc8e4c76b22494c95a105443","permalink":"/ja/post/number-swapper/","publishdate":"2021-06-06T16:52:29+09:00","relpermalink":"/ja/post/number-swapper/","section":"post","summary":"å•é¡Œ ä¸€æ™‚å¤‰æ•°ã‚’ä½¿ç”¨ã—ãªã„ã§æ•°å­—ã®äº¤æ›ã‚’å®Ÿè£…ã›ã‚ˆï¼ ç­”ãˆ å·®ã‚’ã†ã¾ãä½¿ã†ã‚„ã‚Šæ–¹ a = 10 b = 5 print(\u0026#34;a: {}, b: {}\u0026#34;.format(a, b)) a = a - b b = a + b a = b - a print(\u0026#34;a: {}, b: {}\u0026#34;.format(a, b)) xor","tags":[],"title":"Number Swapper","type":"post"},{"authors":[],"categories":[],"content":"Find the Duplicate Number  https://leetcode.com/problems/find-the-duplicate-number/  è§£æ³•1 é…åˆ—ã‚’ã‚½ãƒ¼ãƒˆã—ã¦å‰ã‹ã‚‰é †ç•ªã«è¦ç´ ã‚’è¦‹ã¦ã„ãï¼åŒã˜è¦ç´ ãŒéš£ã‚Šåˆã£ã¦ã„ãŸã‚‰ãã‚Œã‚’è¿”ã™ï¼ã‚½ãƒ¼ãƒˆã«$O(n \\log n)$ã‹ã‹ã‚‹ï¼\nclass Solution: def findDuplicate(self, nums: List[int]) -\u0026gt; int: nums.sort() for i in range(1, len(nums)): if nums[i-1] == nums[i]: return nums[i] è§£æ³•2 setã‚’ä½¿ã£ã¦è¦‹ãŸã“ã¨ã‚ã‚‹è¦ç´ ã‚’ãƒ¡ãƒ¢ã—ã¦ãŠãï¼æ™‚é–“è¨ˆç®—é‡$O(n)$ï¼Œç©ºé–“è¨ˆç®—é‡$O(n)$ï¼\nclass Solution: def findDuplicate(self, nums: List[int]) -\u0026gt; int: seen = set() for num in nums: if num in seen: return num seen.add(num) è§£æ³•3 numsã®è¦ç´ ã‚’numsä¸Šã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã ã¨è€ƒãˆã‚‹ã¨ï¼Œé…åˆ—ã§é€£çµãƒªã‚¹ãƒˆã‚’ä½œã£ãŸã“ã¨ã«ãªã‚‹ï¼ã“ã®ã¨ãï¼Œãƒ€ãƒ–ã£ãŸè¦ç´ ã®ä½ç½®ã§é€£çµãƒªã‚¹ãƒˆãŒãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚‹ã“ã¨ã«ãªã‚‹ã®ã§ãã‚Œã‚’æ¤œå‡ºã™ã‚‹ï¼\nè¶³ã®é€Ÿã„ã†ã•ãğŸ°ã¨è¶³ã®é…ã„äº€ğŸ¢ã‚’èµ°ã‚‰ã›ã‚‹ã¨ã„ã†æœ‰åãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ãŒã‚ã‚‹ï¼\né…åˆ—ã®è¦ç´ ã‚’ä¸€åº¦ã¯è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã®ã§æ™‚é–“è¨ˆç®—é‡$O(n)$ï¼ä¸€æ–¹ã§ãƒã‚¤ãƒ³ã‚¿ã‚’è¿½ã„ã‹ã‘ã‚‹ã ã‘ãªã®ã§ç©ºé–“è¨ˆç®—é‡ã¯numsã®ã‚µã‚¤ã‚ºã«ä¾å­˜ã›ãš$O(1)$ï¼\nclass Solution: def findDuplicate(self, nums: List[int]) -\u0026gt; int: faster = nums[0] slower = nums[0] while True: faster = nums[nums[faster]] slower = nums[slower] if faster == slower: break slower = nums[0] while slower != faster: faster = nums[faster] slower = nums[slower] return slower ","date":1622964324,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1622964324,"objectID":"633b551692ca714c73f1337a690cb349","permalink":"/ja/post/find-the-duplicate-number/","publishdate":"2021-06-06T16:25:24+09:00","relpermalink":"/ja/post/find-the-duplicate-number/","section":"post","summary":"Find the Duplicate Number https://leetcode.com/problems/find-the-duplicate-number/ è§£æ³•1 é…åˆ—ã‚’ã‚½ãƒ¼ãƒˆã—ã¦å‰ã‹ã‚‰é †ç•ªã«è¦ç´ ã‚’è¦‹ã¦ã„ãï¼åŒã˜è¦ç´ ãŒéš£ã‚Šåˆã£ã¦ã„ãŸã‚‰ãã‚Œã‚’è¿”ã™ï¼ã‚½ãƒ¼ãƒˆã«$O(n \\log n)$ã‹ã‹ã‚‹ï¼ class Solution: def findDuplicate(self, nums:","tags":[],"title":"Find the Duplicate Number","type":"post"},{"authors":[],"categories":[],"content":"Missing Number  https://leetcode.com/problems/missing-number/  è§£æ³•1 ã‚½ãƒ¼ãƒˆã—ã¦é ­ã‹ã‚‰é †ç•ªã«è¦ç´ ã‚’è¦‹ã¦ã„ãï¼é…åˆ—ã®æ•´åˆ—ã§$O(n \\log n)$ã‹ã‹ã‚‹ï¼\nclass Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: nums.sort() if nums[-1] != len(nums): return len(nums) if nums[0] != 0: return 0 for i in range(1, len(nums)): expected = nums[i-1] + 1 if nums[i] != expected: return expected è§£æ³•2 setã‚’ä½¿ã†ï¼\nclass Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: s = set(nums) n = len(nums) + 1 for i in range(n): if i not in s: return i è§£æ³•3 é…åˆ—ã®è¦ç´ ã®é›†åˆã¨é…åˆ—ã®æ·»å­—ã®é›†åˆã®xorã‚’è€ƒãˆã‚‹ã¨ã‹ã£ã“ã‚ˆãè§£ã‘ã‚‹ï¼\nclass Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: missing = len(nums) for idx, num in enumerate(nums): missing ^= idx ^ num return missing è§£æ³•4 é…åˆ—ã®è¦ç´ ã®å’Œã‚’è€ƒãˆã‚‹ã¨æŠœã‘ã¦ã‚‹è¦ç´ åˆ†ã ã‘ä¸è¶³ã™ã‚‹ï¼\nclass Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: n = len(nums) allsum = (n * (n + 1)) // 2 return allsum - sum(nums) ","date":1622962735,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1622962735,"objectID":"51b4c0a69c7050663b06535d0715a7f9","permalink":"/ja/post/missing-number/","publishdate":"2021-06-06T15:58:55+09:00","relpermalink":"/ja/post/missing-number/","section":"post","summary":"Missing Number https://leetcode.com/problems/missing-number/ è§£æ³•1 ã‚½ãƒ¼ãƒˆã—ã¦é ­ã‹ã‚‰é †ç•ªã«è¦ç´ ã‚’è¦‹ã¦ã„ãï¼é…åˆ—ã®æ•´åˆ—ã§$O(n \\log n)$ã‹ã‹ã‚‹ï¼ class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: nums.sort() if nums[-1] != len(nums): return len(nums) if nums[0] != 0: return 0 for i in range(1, len(nums)): expected","tags":[],"title":"Missing Number","type":"post"},{"authors":[],"categories":[],"content":"ä¸­å¿ƒæ€§ã¨ã¯ ã‚°ãƒ©ãƒ•ç†è«–ã«ãŠã‘ã‚‹é ‚ç‚¹ã®ä¸­å¿ƒæ€§ã¨ã¯ï¼Œãã®é ‚ç‚¹ã®ã‚°ãƒ©ãƒ•ã®ãƒˆãƒãƒ­ã‚¸è¦³ç‚¹ã§ã®ã€Œé‡è¦åº¦ã€ï¼ãƒˆãƒãƒ­ã‚¸è¦³ç‚¹ã¨ã¯ï¼Œãã®ã‚°ãƒ©ãƒ•ã®é ‚ç‚¹ã‚„è¾ºã®æ„å‘³ã¨ã¯ç„¡é–¢ä¿‚ã§ï¼ŒãŸã ç´”ç²‹ã«ã‚°ãƒ©ãƒ•ã®å½¢ã«ã‚ˆã£ã¦ã®ã¿ä¾å­˜ã™ã‚‹ã¨ã„ã†æ„å‘³ï¼ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã®å½±éŸ¿åŠ›ã®ã‚ã‚‹äººç‰©ã¨ã‹ç–«ç—…ã®ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¹ãƒ—ãƒ¬ãƒƒãƒ€ãƒ¼ã‚’è¦‹ã¤ã‘ãŸã‚Šã™ã‚‹ãªã©ã®å¿œç”¨ãŒã§ãã‚‹ï¼ã“ã‚Œã‚‰ã®å¿œç”¨ã§ã¯ã€Œã‚°ãƒ©ãƒ•ä¸Šã®ãƒˆãƒãƒ­ã‚¸çš„ã«é‡è¦ãªé ‚ç‚¹ã¯ï¼Œæ„å‘³ã«ãŠã„ã¦ã‚‚ç‰¹åˆ¥ã§ã‚ã‚‹ã€ã¨ã„ã†å‰æã‚’ç½®ã„ã¦ã„ã¦ã„ã‚‹ï¼ã‚°ãƒ©ãƒ•ã®ã€Œä¸­å¿ƒã€ã®å®šç¾©ã¯æ§˜ã€…ã‚ã‚Šï¼Œãã‚Œã‚‰ã«å¯¾å¿œã—ã¦ã€Œä¸­å¿ƒã‚‰ã—ã•ã€ã®å®šç¾©ã‚‚æ§˜ã€…ã‚ã‚‹ï¼ä»£è¡¨çš„ãªä¸­å¿ƒæ€§æŒ‡æ¨™ã‚’å–ã‚Šä¸Šã’ã¦è¨˜è¼‰ã™ã‚‹ï¼\nä»¥ä¸‹ï¼Œã‚°ãƒ©ãƒ•ã®å›³ç¤ºã«ã¯ networkx / matplotlib ãªã©ã‚’ä½¿ã†ï¼\n# import libraries import networkx as nx import matplotlib.pyplot as plt import matplotlib.colors as mcolors # drawing function def draw(G, pos, measures, measure_name): normalized_measures = dict() s = sum(measures.values()) for key, value in measures.items(): normalized_measures[key] = value / s nodes = nx.draw_networkx_nodes(G, pos, cmap=plt.cm.plasma, node_size=list(value * 4000 for value in normalized_measures.values()), node_color=list(normalized_measures.values()), nodelist=normalized_measures.keys()) nodes.set_norm(mcolors.SymLogNorm(linthresh=0.01, linscale=1, base=10)) labels = nx.draw_networkx_labels(G, pos) edges = nx.draw_networkx_edges(G, pos) plt.title(measure_name) plt.colorbar(nodes) plt.axis(\u0026#34;off\u0026#34;) plt.show() # example graph G = nx.karate_club_graph() pos = nx.spring_layout(G, seed=42) # example directed graph # - this graph is same as one in https://en.wikipedia.org/wiki/PageRank DiG = nx.DiGraph() DiG.add_edges_from([(2, 3), (3, 2), (4, 1), (4, 2), (5, 2), (5, 4), (5, 6), (6, 2), (6, 5), (7, 2), (7, 5), (8, 2), (8, 5), (9, 2), (9, 5), (10, 5), (11, 5)]) dpos = {1: [0.1, 0.9], 2: [0.4, 0.8], 3: [0.8, 0.9], 4: [0.15, 0.55], 5: [0.5, 0.5], 6: [0.8, 0.5], 7: [0.22, 0.3], 8: [0.30, 0.27], 9: [0.38, 0.24], 10: [0.7, 0.3], 11: [0.75, 0.35]} Degree Centralityï¼šæ¬¡æ•°ä¸­å¿ƒæ€§ é ‚ç‚¹ã«ç”Ÿãˆã¦ã„ã‚‹è¾ºã®æœ¬æ•°ãŒå¤šã‘ã‚Œã°å¤šã„ã»ã©ãã®é ‚ç‚¹ã¯é‡è¦ã§ã‚ã‚‹ã¨ã„ã†ä¸­å¿ƒæ€§ï¼æœ‰å‘ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦ã¯å…¥æ¬¡æ•°ä¸­å¿ƒæ€§ã¨å‡ºæ¬¡æ•°ä¸­å¿ƒæ€§ãŒè¨ˆç®—ã§ãã‚‹ï¼\ndraw(G, pos, nx.degree_centrality(G), \u0026#34;Degree Centrality\u0026#34;)    Eigenvector Centralityï¼šå›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§ ã€Œé‡è¦ãªé ‚ç‚¹ã¨éš£æ¥ã—ã¦ã„ã‚‹é ‚ç‚¹ã»ã©é‡è¦ã€ã§ã‚ã‚‹ã¨ã™ã‚‹ä¸­å¿ƒæ€§ï¼é ‚ç‚¹$i$ã®å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§$x_i$ã¯\n$$ x_i = \\sum_{j}A_{ij}x_j $$\nãŸã ã—$A$ã¯ã‚°ãƒ©ãƒ•$G$ã®éš£æ¥è¡Œåˆ—è¡¨ç¾ï¼ã“ã‚Œã‚’å…¨é ‚ç‚¹ã«ã¤ã„ã¦ã¾ã¨ã‚ã¦æ›¸ãã¨\n$$ Ax = \\lambda x $$\nã®è§£$x$ã¨æ›¸ã‘ã‚‹ï¼ã“ã“ã§$\\lambda$ãŒ$A$ã®å›ºæœ‰å€¤ï¼Œ$x$ãŒå›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ï¼å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§ã¯çµ¶å¯¾å€¤ãŒæœ€å¤§ãªå›ºæœ‰å€¤ã«å¯¾å¿œã™ã‚‹ç¬¬ä¸€å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ã‚’ä¸­å¿ƒæ€§ã¨ã—ã¦æ‰±ã†ï¼å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ã®$i$è¡Œç›®æˆåˆ†ãŒé ‚ç‚¹$i$ã®å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§ï¼\nå›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§ã¯æ¬¡æ•°ä¸­å¿ƒæ€§ã®æ‹¡å¼µã¨ã‚‚è¨€ãˆã‚‹ï¼æ¬¡æ•°ä¸­å¿ƒæ€§ã§ã¯éš£æ¥é ‚ç‚¹ã‚’ã™ã¹ã¦å¹³ç­‰ã«æ‰±ã£ã¦ã„ã‚‹ãŒï¼Œå›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§ã§ã¯ï¼Œã‚ˆã‚Šé‡è¦ãªéš£æ¥é ‚ç‚¹ã®å¯„ä¸ã‚’ã‚ˆã‚Šå¤§ããæ¡ç”¨ã™ã‚‹ï¼\næœ‰å‘ã‚°ãƒ©ãƒ•ã«å¯¾ã™ã‚‹å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§ã§ã¯ï¼Œå…¥æ¬¡æ•°ãŒ0ãªé ‚ç‚¹ã¯ç„¡è¦–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã¨ã„ã†å•é¡ŒãŒã‚ã‚‹ï¼\ndraw(G, pos, nx.eigenvector_centrality(G), \u0026#34;Eigenvector Centrality\u0026#34;)     Phillip Bonacich. â€œPower and Centrality: A Family of Measures.â€ American Journal of Sociology 92(5):1170â€“1182, 1986 Mark E. J. Newman. Networks: An Introduction. Oxford University Press, USA, 2010, pp. 169  Katz Centralityï¼šã‚«ãƒƒãƒ„ä¸­å¿ƒæ€§ å…¥æ¬¡æ•°0ã®é ‚ç‚¹ã®æ‰±ã„ã‚’å·¥å¤«ã—ãŸå›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§ï¼åˆæœŸå€¤ã¨ã—ã¦å…¨ã¦ã®é ‚ç‚¹ã®ä¸­å¿ƒæ€§ã¨ã—ã¦å°ã•ã„å€¤$\\beta$ã‚’ä¸ãˆã‚‹ï¼\n$$ x_i = \\alpha \\sum_{j}A_{ij}x_{j} + \\beta $$\nã“ã‚Œã‚’å…¨é ‚ç‚¹ã«ã¤ã„ã¦ã¾ã¨ã‚ã¦è¨˜è¿°ã™ã‚‹ã¨\n$$ x = \\alpha Ax + \\beta 1 $$\nã®è§£$x$ãŒå…¨é ‚ç‚¹ã®ä¸­å¿ƒæ€§ã«ãªã£ã¦ã„ã‚‹ï¼ãƒ‘ãƒ©ãƒ¡ã‚¿$\\alpha$ã§éš£æ¥é ‚ç‚¹ã®é‡è¦åº¦ã‚’ã©ã®ç¨‹åº¦è‡ªåˆ†ã®é‡è¦åº¦ã«è€ƒæ…®ã™ã‚‹ã‹ã‚’èª¿æ•´ã™ã‚‹ï¼\ndraw(G, pos, nx.katz_centrality(G, alpha=0.1, beta=1.0), \u0026#34;Katz Centrality\u0026#34;)    draw(DiG, dpos, nx.katz_centrality(DiG, alpha=0.1, beta=1.0), \u0026#34;Katz Centrality (Directed Graph)\u0026#34;)     Leo Katz: A New Status Index Derived from Sociometric Index. Psychometrika 18(1):39â€“43, 1953  PageRank Katzä¸­å¿ƒæ€§ã‚’æ‹¡å¼µã—ãŸã‚‚ã®ï¼\n$$ x_i = \\alpha \\sum_{j}A_{ij}\\frac{x_j}{k_{j}^{out}} + \\beta $$\nå…¨é ‚ç‚¹ã«ã¤ã„ã¦ã¾ã¨ã‚ã¦ã‹ãã¨\n$$ x = \\alpha AD^{-1}x + \\beta 1 $$\nãŸã ã—ï¼Œ$D$ã¯å¯¾è§’è¡Œåˆ—ã§$D_{ii} = max(k_{i}^{out}, 1)$\nä½å‡ºæ¬¡æ•°ã®é ‚ç‚¹ã¯ã‚ˆã‚Šå¤§ããéš£æ¥ã™ã‚‹é ‚ç‚¹ã®é‡è¦åº¦ã«å¯„ä¸ã™ã‚‹ï¼\nã‚°ãƒ©ãƒ•ä¸Šã‚’Random Walkã™ã‚‹ã¨ãã®å®šå¸¸çŠ¶æ…‹ã«ãŠã‘ã‚‹å„é ‚ç‚¹ã§ã®æ»åœ¨ç¢ºç‡ã«ç­‰ã—ããªã‚‹ï¼\ndraw(G, pos, nx.pagerank(G), \u0026#34;PageRank\u0026#34;)    draw(DiG, dpos, nx.pagerank(DiG), \u0026#34;PageRank (Directed Graph)\u0026#34;)     Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry, The PageRank citation ranking: Bringing order to the Web. 1999  HITS ã€Œé‡è¦åº¦ã«ã‚‚äºŒç¨®é¡ã‚ã‚‹ã‚ˆã­ã€ã¨ã„ã†ç™ºæƒ³ã‹ã‚‰ç”Ÿã¾ã‚ŒãŸä¸­å¿ƒæ€§ï¼ã‚°ãƒ©ãƒ•ã®ã€Œä¸­å¿ƒã€ã«ã¯ã„ãªã„ã‘ã©é‡è¦ãªé ‚ç‚¹ã ã£ã¦ã‚ã‚‹ã˜ã‚ƒãªã„ã‹ï¼Œãªã‚‰ã°ãã„ã¤ã‚‰ã‚‚æ‰ãˆãŸã„ã¨ã„ã†ã®ãŒHITSï¼ä¾‹ãˆã°ï¼Œã‚µãƒ¼ãƒ™ã‚¤è«–æ–‡ã¯ã€Œé‡è¦ãªè«–æ–‡ã€ã¸ã®ãƒªãƒ³ã‚¯ã‚’å¤§é‡ã«å«ã‚“ã§ã„ã‚‹ã¨ã„ã†æ„å‘³ã§é‡è¦ã ã‘ã‚Œã©ï¼Œã‚µãƒ¼ãƒ™ã‚¤è«–æ–‡è‡ªä½“ã«æ–°è¦æ€§ãŒã‚ã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã§ï¼Œãã“ã‹ã‚‰æ–°ã—ã„æ´¾ç”Ÿç ”ç©¶ãŒå‡ºã¦ãã‚‹è¨³ã§ã¯ãªã„ã¨ã„ã†æ„å‘³ã§é‡è¦ã§ã¯ãªã„ï¼\nHITSã§ã¯é‡è¦ãªé ‚ç‚¹ã®åˆ†é¡ã‚’ä¸ãˆã‚‹ï¼\n Authoritiesï¼šHubsã‹ã‚‰ãŸãã•ã‚“å¼•ç”¨ã•ã‚Œã‚‹é ‚ç‚¹ Hubsï¼šAuthoritiesã‚’ãŸãã•ã‚“å¼•ç”¨ã™ã‚‹é ‚ç‚¹  AuthoritiesãŒã‚¨ãƒãƒƒã‚¯ãƒ¡ã‚¤ã‚­ãƒ³ã‚°ãªè«–æ–‡ã§ï¼ŒHubsãŒã‚µãƒ¼ãƒ™ã‚¤è«–æ–‡ã¨ã„ã†æ„Ÿã˜ï¼\nå†å¸°çš„ãªå®šç¾©ã«ãªã£ã¦ã„ã‚‹ï¼é ‚ç‚¹$i$ã®Authority Centralityã‚’$x_i$ï¼ŒHub Centralityã‚’$y_i$ã¨ã™ã‚‹ã¨\n$$ x_i = \\alpha \\sum_{j}A_{ij}y_j $$\n$$ y_i = \\beta \\sum_{j}A_{ji}x_j $$\nå…¨é ‚ç‚¹ã«ã¤ã„ã¦ã¾ã¨ã‚ã¦æ›¸ãã¨\n$$ x = \\alpha A y $$\n$$ y = \\beta A^{T} x $$\nhub, authority = nx.hits(DiG) draw(DiG, dpos, hub, \u0026#39;HITS Hubs (Directed Graph)\u0026#39;) draw(DiG, dpos, authority, \u0026#39;HITS Authorities (Directed Graph)\u0026#39;)       Jon Kleinberg, Authoritative sources in a hyperlinked environment Journal of the ACM 46 (5): 604-32, 1999. doi:10.1145/324133.324140 A. Langville and C. Meyer, â€œA survey of eigenvector methods of web information retrieval.â€  Closeness Centralityï¼šè¿‘æ¥ä¸­å¿ƒæ€§ é ‚ç‚¹$i$ã‹ã‚‰ä»–ã®å…¨é ‚ç‚¹ã¸ã®æœ€çŸ­çµŒè·¯é•·ã®å¹³å‡ã®é€†æ•°ã§ä¸­å¿ƒæ€§ã¨ã—ãŸã‚‚ã®ï¼ä¸­å¿ƒãªé ‚ç‚¹ã»ã©å‘¨ã‚Šã®é ‚ç‚¹ã«è¿‘ã„ï¼ã€Œãªã‚“ã¨ãªãã¿ã‚“ãªã«ãƒªãƒ¼ãƒã—ã‚„ã™ã„äººã€ã¯ãã®é›†å›£ã®ä¸­å¿ƒã«ã„ãã†ï¼\n$$ x_i = \\frac{1}{l_i} = \\frac{n}{\\sum_{j}d_{ij}} $$\nãŸã ã—ï¼Œ$l_i = \\frac{\\sum_{j}d_{ij}}{n}$ã§ï¼Œ$d_{ij}$ã¯é ‚ç‚¹$i$ã¨é ‚ç‚¹$j$ã®æœ€çŸ­çµŒè·¯é•·ï¼\ndraw(G, pos, nx.closeness_centrality(G), \u0026#34;Closeness Centrality\u0026#34;)     Linton C. Freeman: Centrality in networks: I. Conceptual clarification. Social Networks 1:215-239, 1979.  Current Flow Closeness (a.k.a Information Centrality)ï¼šæƒ…å ±ä¸­å¿ƒæ€§ è¿‘æ¥ä¸­å¿ƒæ€§ã®æ´¾ç”Ÿï¼ã‚°ãƒ©ãƒ•ä¸Šã‚’ä¼ã£ã¦ä¼æ’­ã—ã¦ã„ãæƒ…å ±ã«æ³¨ç›®ã—ãŸä¸­å¿ƒæ€§ï¼é ‚ç‚¹$i$ã¨é ‚ç‚¹$j$ã‚’ç¹‹ãçµŒè·¯ä¸Šã‚’æµã‚Œã‚‹æƒ…å ±ãŒï¼ŒçµŒè·¯é•·ã®é€†æ•°ã«æ¯”ä¾‹ã—ã¦åˆ†æ•£ã™ã‚‹ã¨ã—ãŸã¨ãã®å„é ‚ç‚¹ã§å¾—ã‚‰ã‚Œã‚‹æƒ…å ±é‡ã®èª¿å’Œå¹³å‡ï¼ä¼è¨€ã‚²ãƒ¼ãƒ ã§ã€Œã‚ˆã‚Šæ­£ç¢ºãªã“ã¨ã‚’èã‘ã‚‹äººã€ã¯ä¸­å¿ƒã«ã„ãã†ï¼\ndraw(G, pos, nx.current_flow_closeness_centrality(G), \u0026#34;Current Flow Closeness Centrality a.k.a Information Centrality\u0026#34;)     Ulrik Brandes and Daniel Fleischer, Centrality Measures Based on Current Flow. Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS â€˜05). LNCS 3404, pp. 533-544. Springer-Verlag, 2005. Karen Stephenson and Marvin Zelen: Rethinking centrality: Methods and examples. Social Networks 11(1):1-37, 1989.  æƒ…å ±ä¸­å¿ƒæ€§ã¨ã—ã¦ææ¡ˆ    Betweenness Centralityï¼šåª’ä»‹ä¸­å¿ƒæ€§ ä»»æ„ã®é ‚ç‚¹å¯¾$(s, t)$ã®æœ€çŸ­çµŒè·¯ã®ã†ã¡ï¼Œé ‚ç‚¹$i$ã‚’é€šéã™ã‚‹æœ€çŸ­çµŒè·¯ã¯ã©ã®ãã‚‰ã„ã‚ã‚‹ã‹ï¼Œã‚’ä¸­å¿ƒæ€§ã¨ã—ã¦æ¡ç”¨ã—ãŸã‚‚ã®ï¼ã“ã“ã‹ã‚‰ã‚ãã“ã¾ã§è¡Œãã®ã«ã‚ã®é ‚ç‚¹ã‚’ã¨ã‚‰ãªã„ã¨ã„ã‘ãªã„ã¨ã„ã†ã¨ãï¼Œãã®é ‚ç‚¹ã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã§ã®ä¼é”ã‚’è€ƒãˆãŸã¨ãã®è¦è¡ã§ã‚ã‚‹ã¨è¨€ãˆãã†ï¼ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§ã‚ã‚Œã°ï¼Œç•°ãªã‚‹é›†å›£ã‚’ç¹‹ãã‚­ãƒ¼ãƒ‘ãƒ¼ã‚½ãƒ³ã ã¨åª’ä»‹ä¸­å¿ƒæ€§ã¯å¤§ãã„ï¼\n$$ x_i = \\sum_{s, t \\in V} \\frac{\\sigma (s, t | i)}{\\sigma (s, t)} $$\nãŸã ã—ï¼Œ$\\sigma(s, t)$ã¯é ‚ç‚¹$s$ã¨$t$ã®æœ€çŸ­çµŒè·¯æ•°ï¼Œ$\\sigma(s, t | i)$ã¯ãã‚Œã‚‰ã®ã†ã¡é ‚ç‚¹$i$ã‚’çµŒç”±ã™ã‚‹çµŒè·¯æ•°ï¼\nå¤§è¦æ¨¡ãªã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦BrandesãŒææ¡ˆã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§å³å¯†ãªåª’ä»‹ä¸­å¿ƒæ€§ã¯$O(nm)$ã§è¨ˆç®—ã§ãã‚‹ãŒï¼Œé ‚ç‚¹æ•°ãŒ100ä¸‡ã‚’è¶…ãˆã¦ãã‚‹ã‚°ãƒ©ãƒ•ã«ã¯é›£ã—ã„ï¼è¿‘å¹´ã§ã¯è¿‘ä¼¼å€¤ã‚’é«˜é€Ÿã«æ±‚ã‚ã‚‹ã¨ã„ã†ã¨ã“ã‚ãŒç››ã‚“ã«ç ”ç©¶ã•ã‚Œã¦ã„ã‚‹ï¼\ndraw(G, pos, nx.betweenness_centrality(G), \u0026#34;Betweenness Centrality\u0026#34;)     Ulrik Brandes: A Faster Algorithm for Betweenness Centrality. Journal of Mathematical Sociology 25(2):163-177, 2001. Ulrik Brandes: On Variants of Shortest-Path Betweenness Centrality and their Generic Computation. Social Networks 30(2):136-145, 2008. Linton C. Freeman: A set of measures of centrality based on betweenness. Sociometry 40: 35â€“41, 1977  Current Flow Betweenness (a.k.a Random Walk Betweenness Centrality) åª’ä»‹ä¸­å¿ƒæ€§ã§ã¯ï¼Œæƒ…å ±ãŒæœ€çŸ­çµŒè·¯ä¸Šã‚’ä¼æ’­ã™ã‚‹ã“ã¨ã‚’ä»®å®šã—ã¦ã„ã‚‹ãŒï¼Œãã‚Œã‚’ç·©ã‚ã¦ï¼Œé ‚ç‚¹é–“æœ€çŸ­çµŒè·¯ã®ã¿ãªã‚‰ãšï¼Œã™ã¹ã¦ã®çµŒè·¯ä¸Šã‚’ä¼æ’­ã™ã‚‹ã¨ã—ã¦ï¼Œãã®ä¸­ã§ã‚‚çµŒè·¯é•·ãŒçŸ­ã„ã‚‚ã®ã®å¯„ä¸ã‚’ã‚ˆã‚Šé‡è¦–ã™ã‚‹ä¸­å¿ƒæ€§ã¨ã—ã¦ææ¡ˆã•ã‚ŒãŸï¼åª’ä»‹ä¸­å¿ƒæ€§ã®æ‹¡å¼µï¼æ­´å²çš„ã«ã¯Current Flow BetweennessãŒç›´æ„Ÿã«åã™ã‚‹å ´åˆãŒã‚ã‚‹ã“ã¨ã‚’NewmanãŒç¤ºã—ã¦ï¼Œä»£æ›¿æ¡ˆã¨ã—ã¦Random Walk Betweenness Centralityã‚’ææ¡ˆã—ãŸï¼\né ‚ç‚¹$i$ã®Random Walk Betweennessã¯ï¼Œé ‚ç‚¹$p$ã‹ã‚‰å‡ºç™ºã—ã¦é ‚ç‚¹$q$ã§çµ‚äº†ã™ã‚‹Random WalkãŒãã®é€”ä¸­ã§é ‚ç‚¹$i$ã‚’é€šéã™ã‚‹å›æ•°ã‚’å…¨ã¦ã®é ‚ç‚¹å¯¾$(p, q)$ã§å¹³å‡ã—ãŸã‚‚ã®ã¨ã—ã¦å®šç¾©ã•ã‚Œã‚‹ï¼æƒ…å ±ãŒRandom Walkã™ã‚‹ã¨ãï¼Œä½•å›ã‚‚è¨ªå•ã™ã‚‹é ‚ç‚¹ã¯ãã£ã¨é‡è¦ï¼\ndraw(G, pos, nx.current_flow_betweenness_centrality(G), \u0026#34;Current Flow Betweenness Centrality a.k.a Random Walk Centrality\u0026#34;)     Centrality Measures Based on Current Flow. Ulrik Brandes and Daniel Fleischer, Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS â€˜05). LNCS 3404, pp. 533-544. Springer-Verlag, 2005. A measure of betweenness centrality based on random walks, M. E. J. Newman, Social Networks 27, 39-54 (2005).  Communicability Betweenness Betweenness Centralityã¨Random Walk Betweenness Centralityã®ä¸­é–“ã«ã‚ã‚‹ã‚ˆã†ãªä¸­å¿ƒæ€§ï¼é ‚ç‚¹$i$ã®Communicability Betweennessã¯ï¼Œé ‚ç‚¹$p$ã‹ã‚‰å‡ºç™ºã—ã¦é ‚ç‚¹$q$ã§çµ‚äº†ã™ã‚‹Random WalkãŒãã®é€”ä¸­ã§é ‚ç‚¹$i$ã‚’é€šéã™ã‚‹å›æ•°ã‚’å…¨ã¦ã®é ‚ç‚¹å¯¾$(p, q)$ã¨ãã®çµŒè·¯é•·ã§åŠ é‡å¹³å‡ã—ãŸã‚‚ã®ï¼\ndraw(G, pos, nx.communicability_betweenness_centrality(G), \u0026#34;Communicability Betweenness Centrality\u0026#34;)     Ernesto Estrada, Desmond J. Higham, Naomichi Hatano, â€œCommunicability Betweenness in Complex Networksâ€ Physica A 388 (2009) 764-774.  Power Centralityï¼šãƒœãƒŠãƒãƒƒãƒä¸­å¿ƒæ€§ãƒ»ãƒ‘ãƒ¯ãƒ¼ä¸­å¿ƒæ€§ é‡è¦ãªé ‚ç‚¹ã¨ç¹‹ãŒã£ã¦ã„ã‚‹é ‚ç‚¹ã¯é‡è¦ã§ã¯ ãªã„ ã¨ã™ã‚‹ä¸­å¿ƒæ€§ï¼ã“ã®ãƒ–ãƒ­ã‚°ã«ã‚ˆã‚‹ã¨ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ†æã€ã¨ã„ã†æœ¬ã«\n ä¾‹ãˆã°ã€å•†å–å¼•ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’è€ƒãˆã¦ã¿ã‚ˆã†ã€‚é ‚ç‚¹ã¯ä¼æ¥­ã‚„å€‹äººãªã©å–å¼•ã®ä¸»ä½“ã§ã‚ã‚Šã€è¾ºï¼ˆã“ã“ã§ã¯ã¨ã‚Šã‚ãˆãšç„¡å‘è¾ºã¨ã™ã‚‹ï¼‰ã¯å–å¼•é–¢ä¿‚ã‚’è¡¨ã™ã€‚ã“ã“ã§æ¬¡æ•°ã®é«˜ã„é ‚ç‚¹ã¯ã€æ•°å¤šãã®å–å¼•å…ˆã‚’æŒã¤ä¸»ä½“ã§ã‚ã‚‹ã€‚å–å¼•å…ˆã‚’ä»–ã‚ˆã‚Šå¤šãã‚‚ã¤ä¸»ä½“ã¯ã€å–å¼•ã«ãŠã„ã¦æœ‰åˆ©ãªç«‹å ´ã«ç«‹ã¡å¾—ã‚‹ã€‚ãªãœãªã‚‰ã€è‡ªåˆ†ã¯ä»–ã«ã‚‚å–å¼•ç›¸æ‰‹ã®é¸æŠè‚¢ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã‚’ã€äº¤æ¸‰ã«ãŠã„ã¦ç›¸æ‰‹ã¸ã®åœ§åŠ›ã¨ã—ã¦ä½¿ãˆã‚‹ã‹ã‚‰ã§ã‚ã‚‹ï¼ˆã€Œå®‰ãã—ã¦ãã‚Œãªã„ãªã‚‰ä»–ã‹ã‚‰è²·ã†ã€ãªã©ï¼‰ã€‚ã¤ã¾ã‚Šã€é–¢ä¿‚ã‚ã‚‹ç›¸æ‰‹ã®åŠ›ãŒå¼·ã„ã»ã©ã€è‡ªåˆ†ã®åŠ›ã¯å¼±ããªã‚‹ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚\n ã¨ä¾‹ãˆã‚‰ã‚Œã¦ã„ã‚‹ã¨ã®ã“ã¨ï¼\næœ¬è³ªçš„ã«ã¯å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§ã¨åŒã˜è¨ˆç®—ã§æ±‚ã¾ã‚‹ï¼\nGroup Betweenness Centrality åª’ä»‹ä¸­å¿ƒæ€§ã‚’é ‚ç‚¹é›†åˆã«å¯¾ã—ã¦è¨ˆç®—ã™ã‚‹ã‚ˆã†ã«æ‹¡å¼µã—ãŸã‚‚ã®ï¼é ‚ç‚¹é›†åˆ$C$ã®ã‚°ãƒ«ãƒ¼ãƒ—ä¸­å¿ƒæ€§$BC_{C}$ã¯\n$$ BC_{C} = \\sum_{s, t \\in V - C; s \u0026lt; t} \\frac{\\sigma (s, t | C)}{\\sigma (s, t)} $$\n M G Everett and S P Borgatti: The Centrality of Groups and Classes. Journal of Mathematical Sociology. 23(3): 181-201. 1999. Ulrik Brandes: On Variants of Shortest-Path Betweenness Centrality and their Generic Computation. Social Networks 30(2):136-145, 2008. Sourav Medya et. al.: Group Centrality Maximization via Network Design. SIAM International Conference on Data Mining, SDM 2018, 126â€“134.  Subgraph Centrality networkxã«ã¯\n Subgraph centrality of a node n is the sum of weighted closed walks of all lengths starting and ending at node n. The weights decrease with path length. Each closed walk is associated with a connected subgraph.\n ã¨å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã‚ˆãã‚ã‹ã‚‰ã‚“ï¼æ°´é¢ã«æ°´æ»´ã‚’å‚ã‚‰ã—ãŸã‚‰åŒå¿ƒå††çŠ¶ã«æ³¢åŠã—ã¦ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸ï¼Ÿ\né ‚ç‚¹$u$ã®subgraph centrality$SC_u$ã¯\n$$ SC_u = \\sum_{j = 1}^n (v_{j}^u)^2 e^{\\lambda_{j}} $$\nãŸã ã—$v_j$ã¯ã‚°ãƒ©ãƒ•$G$ã®å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ï¼Œ$\\lambda_j$ã¯ãã‚Œã«å¯¾å¿œã™ã‚‹å›ºæœ‰å€¤ï¼\ndraw(G, pos, nx.subgraph_centrality(G), \u0026#34;Subgraph Centrality\u0026#34;)     Ernesto Estrada, Juan A. Rodriguez-Velazquez, â€œSubgraph centrality in complex networksâ€, Physical Review E 71, 056103 (2005).  Harmonic Centralityï¼šèª¿å’Œä¸­å¿ƒæ€§ é ‚ç‚¹$u$ã®èª¿å’Œä¸­å¿ƒæ€§$x_u$ã¯ãã®ä»–ã®é ‚ç‚¹ã¸ã®æœ€çŸ­çµŒè·¯é•·ã®é€†æ•°ã®å’Œã§å®šç¾©ã•ã‚Œã‚‹ï¼\n$$ x_u = \\sum_{v \\neq u} \\frac{1}{d(v, u)} $$\nãŸã ã—$d(v, u)$ã¯é ‚ç‚¹$v$ã¨é ‚ç‚¹$u$ã®æœ€çŸ­çµŒè·¯é•·ï¼\nè·é›¢ã«æ³¨ç›®ã—ãŸä¸­å¿ƒæ€§æŒ‡æ¨™ï¼PageRankã¨Harmonic Centralityã¯ä¼¼ãŸã‚ˆã†ãªçµæœã«ãªã‚‹ä¸€æ–¹ã§ï¼ŒHarmonic Centralityã®æ–¹ãŒè¨ˆç®—æ™‚é–“ãŒçŸ­ãã¦æ¸ˆã‚€ï¼PageRankã¨Harmonic Centralityã¯ä¸Šä½ã®é ‚ç‚¹ãŒä¸€è‡´ã™ã‚‹ãŒä¸‹ä½ã®é ‚ç‚¹ã§ã¯ãšã‚Œã‚‹ï¼\ndraw(G, pos, nx.harmonic_centrality(G), \u0026#34;Harmonic Centrality\u0026#34;)     Boldi, Paolo, and Sebastiano Vigna. â€œAxioms for centrality.â€ Internet Mathematics 10.3-4 (2014): 222-262.  Second Order Centrality ã‚°ãƒ©ãƒ•$G$ä¸Šã§é ‚ç‚¹$u$ã‹ã‚‰Random Walkã‚’å®Ÿè¡Œã—ãŸã¨ãã«ï¼Œå§‹ç‚¹é ‚ç‚¹$u$ã‚’å†ã³é€šéã™ã‚‹ã¾ã§ã®æ­©é•·ã®æ¨™æº–åå·®ï¼ˆå¹³å‡ã‹ã‚‰ã®ãƒ–ãƒ¬ï¼‰ã‚’Second Order Centralityã¨ã„ã†ï¼\nSecond Order CentralityãŒå°ã•ã„ã»ã©ï¼Œé‡è¦ãªé ‚ç‚¹ã§ã‚ã‚‹ã¨ã„ãˆã‚‹ï¼\nnetworkxã§ã®å®Ÿè£…ã§ã¯Random Walkã‚’å®Ÿéš›ã«å®Ÿè¡Œã™ã‚‹ã®ã§ã¯ãªãï¼Œä»£æ•°çš„ã«è§£ãå®Ÿè£…ã«ãªã£ã¦ã„ã‚‹ï¼è¨ˆç®—é‡ã¯$O(n^3)$ã¨å¤§ããï¼Œè¦æ¨¡ã®å¤§ãã„ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦ã¯è¿‘ä¼¼ãŒå¿…è¦ã«ãªã‚Šãã†ï¼\ndraw(G, pos, nx.second_order_centrality(G), \u0026#34;Second Order Centrality\u0026#34;)     Anne-Marie Kermarrec, Erwan Le Merrer, Bruno Sericola, Gilles TrÃ©dan â€œSecond order centrality: Distributed assessment of nodes criticity in complex networksâ€, Elsevier Computer Communications 34(5):619-628, 2011.  ãã®ä»– ä¸­å¿ƒæ€§ã¨ã„ã†æ¦‚å¿µã®æ­´å²ã®è©±ãŒã“ã¡ã‚‰ã«ã¾ã¨ã¾ã£ã¦ã„ã¾ã—ãŸï¼\n ä¸­å¿ƒæ€§ï¼šå§‹ã¾ã‚Šã‹ã‚‰æœ€è¿‘ã¾ã§ï¼ˆPreferred Networks R\u0026amp;D Blogï¼‰  ","date":1621343598,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1621343598,"objectID":"a1e2136253a9676e53397d143b3c9a04","permalink":"/ja/post/centralities-on-graph/","publishdate":"2021-05-18T22:13:18+09:00","relpermalink":"/ja/post/centralities-on-graph/","section":"post","summary":"ä¸­å¿ƒæ€§ã¨ã¯ ã‚°ãƒ©ãƒ•ç†è«–ã«ãŠã‘ã‚‹é ‚ç‚¹ã®ä¸­å¿ƒæ€§ã¨ã¯ï¼Œãã®é ‚ç‚¹ã®ã‚°ãƒ©ãƒ•ã®ãƒˆãƒãƒ­ã‚¸è¦³ç‚¹ã§ã®ã€Œé‡è¦åº¦ã€ï¼ãƒˆãƒãƒ­ã‚¸è¦³ç‚¹ã¨ã¯ï¼Œãã®ã‚°ãƒ©ãƒ•ã®é ‚ç‚¹ã‚„è¾ºã®æ„å‘³ã¨ã¯","tags":[],"title":"Centralities on Graph","type":"post"},{"authors":[],"categories":[],"content":"TL;DR ãƒªã‚¹ãƒˆã®åˆæœŸåŒ–ã¯å†…åŒ…è¡¨è¨˜ã§æ›¸ãã¹ã—ï¼*ä½¿ã£ã¦äºˆæœŸã—ãªã„ã“ã¨ãŒèµ·ãã‚‹ã“ã¨ã‚’å›é¿ã—ã‚ˆã†ï¼\nãƒªã‚¹ãƒˆã®åˆæœŸåŒ– ãƒªã‚¹ãƒˆã‚’é©åˆ‡ãªå€¤ã§åˆæœŸåŒ–ã—ãŸã„å ´é¢ã¯ã‚ˆãã‚ã‚‹ï¼\nä¾‹ãˆã°ï¼Œã“ã‚“ãªæ„Ÿã˜ï¼\n# è¦ç´ æ•°3ã®ãƒªã‚¹ãƒˆã‚’0ã§åˆæœŸåŒ– arr = [] for _ in range(3): arr.append(0) # 3x3ã®ãƒªã‚¹ãƒˆã‚’0ã§åˆæœŸåŒ– mat = [] for _ in range(3): row = [] for _ in range(3): row.append(0) mat.append(row) ã“ã‚Œã¯ä¸‹ã®æ›¸ã‘ã‚‹ï¼ã“ã®æ›¸ãæ–¹ã¯ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã¨è¨€ã‚ã‚Œã‚‹ï¼\n# è¦ç´ æ•°3ã®ãƒªã‚¹ãƒˆã‚’0ã§åˆæœŸåŒ– arr = [0 for _ in range(3)] # 3x3ã®ãƒªã‚¹ãƒˆã‚’0ã§åˆæœŸåŒ– mat = [[0 for _ in range(3)] for _ in range(3)] ã¾ãŸï¼Œã“ã†ã‚‚æ›¸ã‘ã‚‹ï¼\n# è¦ç´ æ•°3ã®ãƒªã‚¹ãƒˆã‚’0ã§åˆæœŸåŒ– arr = [0] * 3 # 3x3ã®ãƒªã‚¹ãƒˆã‚’0ã§åˆæœŸåŒ– mat = [[0] * 3] * 3 ãŒï¼Œæ›ã‘ç®—ã‚’ä½¿ã£ãŸæ›¸ãæ–¹ã«ã¯ç½ ãŒã‚ã‚‹ï¼\narr = [[0] * 3] * 3 print(arr) # =\u0026gt; [0, 0, 0] arr[0] = 1 print(arr) # =\u0026gt; [1, 0, 0]: æœŸå¾…é€šã‚Šã®å‹•ä½œ class Hoge: def __init__(self): self.val = 0 arr2 = [Hoge()] * 3 print([id(hoge) for hoge in arr2]) # =\u0026gt; [4349443472, 4349443472, 4349443472] arr2[0].val = 99 print([hoge.val for hoge in arr2]) # =\u0026gt; [99, 99, 99] mat = [[0] * 3] * 3 print(mat) # =\u0026gt; [[0, 0, 0], [0, 0, 0], [0, 0, 0]] mat[0][0] = 1 print(mat) # =\u0026gt; [[1, 0, 0], [1, 0, 0], [1, 0, 0]]: ï¼Ÿï¼Ÿï¼Ÿ print([id(row) for row in mat]) # =\u0026gt; [4349542144, 4349542144, 4349542144]: å…¨éƒ¨åŒã˜ç•ªåœ°ã‚’æŒ‡ã—ã¦ã‚‹ *ã‚’ä½¿ã£ã¦åˆæœŸåŒ–ã™ã‚‹ã¨å‚ç…§ã§åˆæœŸåŒ–ã™ã‚‹ã£ã½ã„ï¼ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã§ã¯ãã®éƒ½åº¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã£ã¦ã„ã‚‹ã£ã½ã„ï¼\nè¦ã™ã‚‹ã«å†…åŒ…è¡¨è¨˜ã§æ›¸ã‘ã°äº‹æ•…ã¯èµ·ããªã„ã¨ã„ã†ã“ã¨ï¼\n","date":1618499532,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1618499532,"objectID":"4b4d2e00a3502c8c9d30399c16f31db9","permalink":"/ja/post/tips-on-init-of-list/","publishdate":"2021-04-16T00:12:12+09:00","relpermalink":"/ja/post/tips-on-init-of-list/","section":"post","summary":"TL;DR ãƒªã‚¹ãƒˆã®åˆæœŸåŒ–ã¯å†…åŒ…è¡¨è¨˜ã§æ›¸ãã¹ã—ï¼*ä½¿ã£ã¦äºˆæœŸã—ãªã„ã“ã¨ãŒèµ·ãã‚‹ã“ã¨ã‚’å›é¿ã—ã‚ˆã†ï¼ ãƒªã‚¹ãƒˆã®åˆæœŸåŒ– ãƒªã‚¹ãƒˆã‚’é©åˆ‡ãªå€¤ã§åˆæœŸåŒ–ã—ãŸã„å ´é¢ã¯ã‚ˆã","tags":[],"title":"Tips on initialization of List","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ•´æ•°ã‚’è¦ç´ ã¨ã—ã¦æŒã¤ãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œè¾æ›¸é †ã§ãã®ãƒªã‚¹ãƒˆã®å‰å¾Œã®é †åˆ—ã‚’æ±‚ã‚ã‚ˆï¼\nç­”ãˆ def prev_permutation(arr): i = len(arr) - 1 while 0 \u0026lt; i and arr[i-1] \u0026lt;= arr[i]: i -= 1 if i == 0: # arrã¯æ˜‡é †ã«æ•´åˆ—ã•ã‚Œã¦ã„ã‚‹ arr.reverse() return i -= 1 pivot = arr[i] j = len(arr) - 1 while arr[j] \u0026gt;= arr[i]: j -= 1 # arr[i+1:]ã¯æ˜‡é †ã«æ•´åˆ—ã•ã‚Œã¦ã„ã‚‹ã®ã§äºŒåˆ†æ¢ç´¢ã‚‚å¯ # j = bisect_left(arr[i+1:], arr[i]) + i arr[i], arr[j] = arr[j], arr[i] arr[i+1:] = reversed(arr[i+1:]) def next_permutation(arr): i = len(arr) - 1 while 0 \u0026lt; i and arr[i-1] \u0026gt;= arr[i]: i -= 1 if i == 0: # arrã¯é™é †ã«æ•´åˆ—ã•ã‚Œã¦ã„ã‚‹ arr.sort() return i -= 1 pivot = arr[i] j = len(arr) - 1 while arr[j] \u0026lt;= pivot: j -= 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1:] = reversed(arr[i+1:]) arr = [1, 2, 3] prev_permutation(arr) print(arr) # =\u0026gt; [3, 2, 1] arr = [1, 3, 2] prev_permutation(arr) print(arr) # =\u0026gt; [1, 2, 3] arr = [1, 2, 3] next_permutation(arr) print(arr) # =\u0026gt; [1, 3, 2] arr = [3, 2, 1] next_permutation(arr) print(arr) # =\u0026gt; [1, 2, 3] ","date":1618487609,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1618487609,"objectID":"ab3c7d7d0206bf32dd3973bbfb7f8b04","permalink":"/ja/post/prev-permutation-and-next-permutation/","publishdate":"2021-04-15T20:53:29+09:00","relpermalink":"/ja/post/prev-permutation-and-next-permutation/","section":"post","summary":"å•é¡Œ æ•´æ•°ã‚’è¦ç´ ã¨ã—ã¦æŒã¤ãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œè¾æ›¸é †ã§ãã®ãƒªã‚¹ãƒˆã®å‰å¾Œã®é †åˆ—ã‚’æ±‚ã‚ã‚ˆï¼ ç­”ãˆ def prev_permutation(arr): i = len(arr) - 1 while 0 \u0026lt; i and arr[i-1] \u0026lt;= arr[i]: i -= 1 if i == 0: # a","tags":[],"title":"Previious Permutation and Next Permutation","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ $N \\times N$ã®ç›¤é¢ã«$N$å€‹ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’äº’ã„ã« 1 æ‰‹ã§ã¯è¥²æ’ƒã§ããªã„ã‚ˆã†ã«é…ç½®ã›ã‚ˆï¼\nç­”ãˆ DFS ã§å…¨æ¢ç´¢ï¼\nN = int(input()) queens = [0 for _ in range(N)] board = [[0 for _ in range(N)] for _ in range(N)] def update_board(board, row, col, x): for _col in range(N): board[row][_col] += x for _row in range(N): board[_row][col] += x # (+1, +1) _row = row _col = col while _row + 1 \u0026lt; N and _col + 1 \u0026lt; N: _row += 1 _col += 1 board[_row][_col] += x # (+1, -1) _row = row _col = col while _row + 1 \u0026lt; N and 0 \u0026lt;= _col - 1: _row += 1 _col -= 1 board[_row][_col] += x # (-1, +1) _row = row _col = col while 0 \u0026lt;= _row -1 and _col + 1 \u0026lt; N: _row -= 1 _col += 1 board[_row][_col] += x # (-1, -1) _row = row _col = col while 0 \u0026lt;= _row - 1 and 0 \u0026lt;= _col - 1: _row -= 1 _col -= 1 board[_row][_col] += x def set_queens(queens, board, row): if row == N: # print board with Qs for col in queens: print(\u0026#34;.\u0026#34; * col + \u0026#34;Q\u0026#34; + \u0026#34;.\u0026#34; * (N - col - 1)) print() return for col in range(N): if board[row][col] == 0: queens[row] = col update_board(board, row, col, +1) set_queens(queens, board, row + 1) update_board(board, row, col, -1) set_queens(queens, board, 0) $ python3 main.py Q....... ....Q... .......Q .....Q.. ..Q..... ......Q. .Q...... ...Q.... Q....... .....Q.. .......Q ..Q..... ......Q. ...Q.... .Q...... ....Q... Q....... ......Q. ...Q.... .....Q.. .......Q .Q...... ....Q... ..Q..... ...ï¼ˆç¶šãï¼‰... ","date":1618223389,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1618223389,"objectID":"a5faa2e5c08b2de4a51c2fa3d9ca549f","permalink":"/ja/post/n-queens-problem/","publishdate":"2021-04-12T19:29:49+09:00","relpermalink":"/ja/post/n-queens-problem/","section":"post","summary":"å•é¡Œ $N \\times N$ã®ç›¤é¢ã«$N$å€‹ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’äº’ã„ã« 1 æ‰‹ã§ã¯è¥²æ’ƒã§ããªã„ã‚ˆã†ã«é…ç½®ã›ã‚ˆï¼ ç­”ãˆ DFS ã§å…¨æ¢ç´¢ï¼ N = int(input()) queens = [0 for _ in range(N)] board = [[0 for _ in range(N)] for _ in range(N)]","tags":[],"title":"$N$ Queens Problem","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ éè² æ•´æ•°ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ãã®å¹³æ–¹ã®æ•´æ•°éƒ¨åˆ†ã‚’è¨ˆç®—ã›ã‚ˆï¼\nç­”ãˆ äºŒåˆ†æ¢ç´¢ã§æ›¸ãï¼\nclass Solution: def mySqrt(self, x: int) -\u0026gt; int: ok = 1 \u0026lt;\u0026lt; 16 ng = 0 def is_ok(mid): return x \u0026lt; mid * mid while 1 \u0026lt; abs(ok - ng): mid = (ok + ng) // 2 if is_ok(mid): ok = mid else: ng = mid return ok - 1 å…¨éƒ¨èª¿ã¹ã‚‹ï¼\nclass Solution: def mySqrt(self, x: int) -\u0026gt; int: i = 1 while i * i \u0026lt;= x: i += 1 return i - 1 ","date":1617977020,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1617977020,"objectID":"4431273eec40a145c90a10134eb88df1","permalink":"/ja/post/sqrtx/","publishdate":"2021-04-09T23:03:40+09:00","relpermalink":"/ja/post/sqrtx/","section":"post","summary":"å•é¡Œ éè² æ•´æ•°ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ãã®å¹³æ–¹ã®æ•´æ•°éƒ¨åˆ†ã‚’è¨ˆç®—ã›ã‚ˆï¼ ç­”ãˆ äºŒåˆ†æ¢ç´¢ã§æ›¸ãï¼ class Solution: def mySqrt(self, x: int) -\u0026gt; int: ok = 1 \u0026lt;\u0026lt; 16 ng = 0 def is_ok(mid): return x \u0026lt; mid * mid while 1 \u0026lt; abs(ok - ng): mid =","tags":[],"title":"Sqrt(x)","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã«ã¤ã„ã¦æ¬¡ã®è¦å‰‡ã«å¾“ã£ã¦æ–‡å­—åˆ—ã‚’åœ§ç¸®ã›ã‚ˆ\n ã‚‚ã—ã‚ã‚‹æ–‡å­—xãŒé€£ç¶šã—ã¦ 1 ã¤ã—ã‹å­˜åœ¨ã—ãªã„ãªã‚‰x ã‚‚ã—ã‚ã‚‹æ–‡å­—xãŒé€£ç¶šã—ã¦yã¤ä»¥ä¸Šå­˜åœ¨ã™ã‚‹ãªã‚‰xy  ç­”ãˆ class Solution: def compress(self, chars: List[str]) -\u0026gt; int: pos_anchor = 0 pos_write = 0 for pos_read, char in enumerate(chars): if pos_read == len(chars) - 1 or char != chars[pos_read + 1]: chars[pos_write] = char pos_write += 1 if pos_anchor \u0026lt; pos_read: for digit in str(pos_read - pos_anchor + 1): chars[pos_write] = digit pos_write += 1 pos_anchor = pos_read + 1 return pos_write è‹±èªã ã¨ run length compressopm ã¨å‘¼ã°ã‚Œã¦ã„ã‚‹ï¼Ÿ\nåå¯¾ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹å•é¡Œã‚‚è€ƒãˆã‚‰ã‚Œã‚‹ï¼\nhttps://leetcode.com/problems/decompress-run-length-encoded-list/\nclass Solution: def decompressRLElist(self, nums: List[int]) -\u0026gt; List[int]: ret = [] for i in range(len(nums) // 2): freq = nums[2 * i] num = nums[2 * i + 1] for _ in range(freq): ret += [num] return ret ref https://leetcode.com/problems/string-compression/\n","date":1617197790,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1617197790,"objectID":"2ca8342370023d8d580c472258f28375","permalink":"/ja/post/string-compression/","publishdate":"2021-03-31T22:36:30+09:00","relpermalink":"/ja/post/string-compression/","section":"post","summary":"å•é¡Œ ä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã«ã¤ã„ã¦æ¬¡ã®è¦å‰‡ã«å¾“ã£ã¦æ–‡å­—åˆ—ã‚’åœ§ç¸®ã›ã‚ˆ ã‚‚ã—ã‚ã‚‹æ–‡å­—xãŒé€£ç¶šã—ã¦ 1 ã¤ã—ã‹å­˜åœ¨ã—ãªã„ãªã‚‰x ã‚‚ã—ã‚ã‚‹æ–‡å­—xãŒé€£ç¶šã—ã¦yã¤ä»¥ä¸Š","tags":[],"title":"String Compression","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ 1 - 1å€‹ã®1 -\u0026gt; 11 - 2å€‹ã®1 -\u0026gt; 21 - 1å€‹ã®2ã¨1å€‹ã®1 -\u0026gt; 1211 -\u0026gt; ... ä¸Šã®ã‚ˆã†ã«ç¶šãæ•°åˆ—ã®ç¬¬$n$é …ã‚’æ±‚ã‚ã‚ˆï¼\nç­”ãˆ def count_and_say(n): if n == 1: return \u0026#34;1\u0026#34; def get_next_count_and_say(curr): ch = curr[0] cnt = 1 ret = \u0026#34;\u0026#34; for i in range(1, len(curr)): if curr[i] != ch: ret += (str(cnt) + ch) ch = curr[i] cnt = 1 else: cnt += 1 ret += (str(cnt) + ch) return ret ret = \u0026#34;1\u0026#34; for i in range(2, n + 1): ret = get_next_count_and_say(ret) return ret ã“ã‚Œã¯ä¸€ç¨®ã®ç¬¦å·åŒ–æ–¹å¼ï¼\n","date":1617196312,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1617196312,"objectID":"4f3b4a77534638b5c1c5c03e73fdf9dd","permalink":"/ja/post/count-and-say/","publishdate":"2021-03-31T22:11:52+09:00","relpermalink":"/ja/post/count-and-say/","section":"post","summary":"å•é¡Œ 1 - 1å€‹ã®1 -\u0026gt; 11 - 2å€‹ã®1 -\u0026gt; 21 - 1å€‹ã®2ã¨1å€‹ã®1 -\u0026gt; 1211 -\u0026gt; ... ä¸Šã®ã‚ˆã†ã«ç¶šãæ•°åˆ—ã®ç¬¬$n$é …ã‚’æ±‚ã‚ã‚ˆï¼ ç­”ãˆ def count_and_say(n): if n == 1: return \u0026#34;1\u0026#34; def get_next_count_and_say(curr): ch = curr[0] cnt = 1 ret","tags":[],"title":"Count and Say","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã¨æ•°å­—ã§æ§‹æˆã•ã‚Œã‚‹æ–‡å­—åˆ—ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ä»»æ„ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã«ã¤ã„ã¦å¤§æ–‡å­—å°æ–‡å­—ã«å¤‰æ›ã§ãã‚‹ï¼ã“ã®å¤‰æ›ã«ã‚ˆã£ã¦å¾—ã‚‰ã‚Œã‚‹ã™ã¹ã¦ã®æ–‡å­—åˆ—ã‚’è¨ˆç®—ã›ã‚ˆï¼\nhttps://leetcode.com/problems/letter-case-permutation/\nç­”ãˆ DFSï¼\nclass Solution: def letterCasePermutation(self, S: str) -\u0026gt; List[str]: ret = [] def rec(pos, sofar): if pos == len(S): ret.append(sofar) return if S[pos].isalpha(): rec(pos + 1, sofar + S[pos]) rec(pos + 1, sofar + S[pos].swapcase()) else: rec(pos + 1, sofar + S[pos]) rec(0, \u0026#34;\u0026#34;) return ret ","date":1617116498,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1617116498,"objectID":"b5f531575fc98ee682fca155ee9237b0","permalink":"/ja/post/letter-case-permutation/","publishdate":"2021-03-31T00:01:38+09:00","relpermalink":"/ja/post/letter-case-permutation/","section":"post","summary":"å•é¡Œ ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã¨æ•°å­—ã§æ§‹æˆã•ã‚Œã‚‹æ–‡å­—åˆ—ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ä»»æ„ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã«ã¤ã„ã¦å¤§æ–‡å­—å°æ–‡å­—ã«å¤‰æ›ã§ãã‚‹ï¼ã“ã®å¤‰æ›ã«ã‚ˆã£ã¦å¾—ã‚‰ã‚Œã‚‹ã™ã¹ã¦","tags":[],"title":"Letter Case Permutation","type":"post"},{"authors":[],"categories":[],"content":"æ•´æ•°ã‚’è¦ç´ ã¨ã—ã¦æ ¼ç´ã™ã‚‹é…åˆ—ãŒä¸ãˆã‚‰ã‚Œï¼Œãã“ã‹ã‚‰$N$å€‹è¦ç´ ã‚’å–ã‚Šä¸Šã’ã¦ãã®å’ŒãŒ$X$ã«ãªã‚‹ã‚ˆã†ãªè¦ç´ ã®ã¨ã‚Šæ–¹ã¯ã„ãã¤ã‚ã‚‹ã‹ï¼Œè¦ç´ ã®ã¨ã‚Šæ–¹ãã®ã‚‚ã®ã‚’è¿”ã›ï¼Œã¨ã„ã†ç³»çµ±ã®å•é¡Œã«ã¤ã„ã¦ãŠå‹‰å¼·ã—ãŸã®ã§ã¾ã¨ã‚ã‚‹ï¼\n$2$-Sum ä¸ãˆã‚‰ã‚ŒãŸé…åˆ—numsã‹ã‚‰è¦ç´ ã‚’ 2 ã¤å–ã‚Šå‡ºã—ã¦ï¼Œãã®å’ŒãŒtargetã¨ç­‰ã—ããªã‚‹ã‚ˆã†ãªçµ„ã¿åˆã‚ã›ã‚’é…åˆ—ã«ãŠã‘ã‚‹ä½ç½®ã®ãƒšã‚¢ã§è¿”ã›ï¼\nä¸»ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ 3 ã¤ã‚ã‚Šãã†\n ã€Œè¶³ã—ã¦targetã«ãªã‚‹ç›¸æ–¹ã€ãŒã„ã‚‹ã‹ã‚’ç®¡ç†ã—ãªãŒã‚‰è¦ç´ ã‚’èˆã‚ã‚‹ï¼ˆ$O(n)$ï¼‰ numsã‚’æ˜‡é †ã«æ•´åˆ—ã—ã¦ã€Œè¶³ã—ã¦targetã«ãªã‚‹ç›¸æ–¹ã€ã‚’ç·šå½¢ã«æ¢ç´¢ï¼ˆ$O(n)$ï¼‰  ã“ã®æ–¹æ³•ã ã¨ä¸ãˆã‚‰ã‚ŒãŸé…åˆ—ã«é‡è¤‡è¦ç´ ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã¨ãã«å¯¾å¿œã—ã‚„ã™ã„ï¼Ÿ   numsã‚’æ˜‡é †ã«æ•´åˆ—ã—ã¦ã€Œè¶³ã—ã¦targetã«ãªã‚‹ç›¸æ–¹ã€ã‚’äºŒåˆ†æ¢ç´¢ï¼ˆ$O(n \\log n)$ï¼‰  ã€Œè¶³ã—ã¦targetã«ãªã‚‹ç›¸æ–¹ã€ãŒã„ã‚‹ã‹ã‚’ç®¡ç†ã—ãªãŒã‚‰è¦ç´ ã‚’èˆã‚ã‚‹ nums = [2,7,11,15] target = 9 def two_sum(nums, target): table = dict() for idx, num in enumerate(nums): remain = target - num if remain in table: return [idx, table[remain]] table[num] = idx print(two_sum(nums, target)) # =\u0026gt; [1, 0] numsã‚’æ˜‡é †ã«æ•´åˆ—ã—ã¦ã€Œè¶³ã—ã¦targetã«ãªã‚‹ç›¸æ–¹ã€ã‚’ç·šå½¢ã«æ¢ç´¢ def two_sum(nums, target): nums.sort() left = 0 right = len(nums) - 1 while left \u0026lt; right: added = nums[left] + nums[right] if added == target: return [left, right] elif added \u0026lt; target: left += 1 else: # target \u0026lt; added right -= 1 æ˜‡é †ã«ãªã£ã¦ã„ã‚‹ãªã‚‰ã°ï¼Œã€Œè¶³ã—ä¸Šã’ãŸçµæœãŒtargetã‚ˆã‚Šå°ã•ã„ã¨ãã¯ç‰‡æ–¹ã‚’å¤§ããã™ã‚Œã°ã„ã„ã—ï¼Œtargetã‚’è¶…ãˆã¡ã‚ƒã£ãŸã¨ãã¯ç‰‡æ–¹ã‚’å°ã•ãã™ã‚Œã°è‰¯ã„ã€ã¨ã„ã†æ“ä½œã‚’ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®éš£ã¸ã®ç§»å‹•ã§å®Ÿç¾ã§ãã‚‹ï¼\nã¾ãŸï¼Œè¦ç´ ã®é‡è¤‡ãŒã‚ã‚‹ã‚ˆã†ãªé…åˆ—ã‚’æ¸¡ã•ã‚ŒãŸã¨ãã«é‡è¤‡è¦ç´ ã‚’ç„¡è¦–ã™ã‚‹æ“ä½œã‚‚ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ç§»å‹•ã§ã§ãã‚‹ï¼\nnumsã‚’æ˜‡é †ã«æ•´åˆ—ã—ã¦ã€Œè¶³ã—ã¦targetã«ãªã‚‹ç›¸æ–¹ã€ã‚’äºŒåˆ†æ¢ç´¢ æ˜‡é †ã«ãªã£ã¦ã„ã‚Œã°ç›¸æ–¹ã‚’äºŒåˆ†æ¢ç´¢ã§æ¢ã™ã“ã¨ã‚‚ã§ãã‚‹ï¼\nnums = [2,7,11,15] target = 9 def two_sum(nums, target): nums.sort() def binary_search(nums, target): ng = -1 ok = len(nums) def is_ok(mid): return target \u0026lt;= nums[mid] while 1 \u0026lt; abs(ng - ok): mid = (ng + ok) // 2 if is_ok(mid): ok = mid else: ng = mid return ok for idx, num in enumerate(nums): remain = target - num remain_idx = binary_search(nums, remain) if num + nums[remain_idx] == target: return [idx, remain_idx] print(two_sum(nums, target)) # =\u0026gt; [0, 1] $3$-Sum ä¸ãˆã‚‰ã‚ŒãŸé…åˆ—numsã‹ã‚‰è¦ç´ ã‚’ 3 ã¤å–ã‚Šå‡ºã—ã¦ï¼Œãã®å’ŒãŒtargetã¨ç­‰ã—ããªã‚‹ã‚ˆã†ãªçµ„ã¿åˆã‚ã›ã‚’é…åˆ—ã«ãŠã‘ã‚‹ä½ç½®ã®ãƒšã‚¢ã§è¿”ã›ï¼\nã“ã‚Œã¯ï¼Œnums[i] + nums[j] + nums[k] == targetã¨ã™ã‚‹ã¨ï¼Œnums[i] + nums[j] == target - nums[k]ã¨ã„ã†ï¼Œã€Œæ¯å›targetã®å¤‰ã‚ã‚‹$2$-Sumã€ã¨è¦‹ã¦è§£ãã“ã¨ãŒã§ãã‚‹ï¼\nãªã‚“ã¨ Wikipedia ã«è¨˜äº‹ã‚‚ã‚ã‚‹ï¼\nå‚è€ƒå•é¡Œ Two Sum ã“ã‚Œã¯ç›¸æ–¹ã‚’ãƒ¡ãƒ¢ã—ã¦ãŠãè§£æ³•\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: table = dict() for idx, num in enumerate(nums): remain = target - num if remain in table: return [idx, table[remain]] table[num] = idx Two Sum II - Input array is sorted ç›¸æ–¹ã‚’ãƒ¡ãƒ¢ã—ã¦ãŠãè§£æ³•\nclass Solution: def twoSum(self, numbers: List[int], target: int) -\u0026gt; List[int]: table = dict() for idx, num in enumerate(numbers): remain = target - num if remain in table: return [idx + 1, table[remain] + 1] if idx \u0026lt; table[remain] else [table[remain] + 1, idx + 1] table[num] = idx æ˜‡é †ã«ä¸¦ã‚“ã§ã„ã‚‹ã“ã¨ã‚’åˆ©ç”¨ã—ã¦ç›¸æ–¹ã‚’æ¢ã™è§£æ³•\nclass Solution: def twoSum(self, numbers: List[int], target: int) -\u0026gt; List[int]: left = 0 right = len(numbers) - 1 while left \u0026lt; right: added = numbers[left] + numbers[right] if added == target: return [left + 1, right + 1] elif added \u0026lt; target: left += 1 else: # target \u0026lt; added right -= 1 Two Sum III - Data structure design Not Yet.\nTwo Sum IV - Input is a BST äºŒåˆ†æ¢ç´¢æœ¨ã‚’ DFS ã—ãªãŒã‚‰ç›¸æ–¹ã‚’ãƒ¡ãƒ¢ã™ã‚‹è§£æ³•\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findTarget(self, root: TreeNode, k: int) -\u0026gt; bool: if root is None: return False seen = set() suspended = [root] while len(suspended) != 0: u = suspended.pop() if k - u.val in seen: return True seen.add(u.val) if u.left is not None: suspended.append(u.left) if u.right is not None: suspended.append(u.right) return False å†å¸°ã§äºŒåˆ†æ¢ç´¢æœ¨ã‚’ DFS ã—ãªãŒã‚‰ç›¸æ–¹ã‚’ãƒ¡ãƒ¢ã™ã‚‹è§£æ³•\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findTarget(self, root: TreeNode, k: int) -\u0026gt; bool: seen = set() def DFS(root): if root is None: return False if k - root.val in seen: return True seen.add(root.val) return DFS(root.left) or DFS(root.right) return DFS(root) BFS ã§äºŒåˆ†æ¢ç´¢æœ¨ã‚’ BFS ã—ãªãŒã‚‰ç›¸æ–¹ã‚’ãƒ¡ãƒ¢ã™ã‚‹è§£æ³•\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findTarget(self, root: TreeNode, k: int) -\u0026gt; bool: if root is None: return False seen = set() suspended = [root] while len(suspended) != 0: u = suspended.pop(0) if k - u.val in seen: return True seen.add(u.val) if u.left is not None: suspended.append(u.left) if u.right is not None: suspended.append(u.right) return False äºŒåˆ†æ¢ç´¢æœ¨ã‚’é–“é †èµ°æŸ»ã™ã‚‹ã¨æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé…åˆ—ãŒè¨ˆç®—ã§ãã‚‹ã®ã§ï¼Œé…åˆ—ã«å¯¾ã™ã‚‹$2$-Sum å•é¡Œã«å¸°ç€ã—ã¦è§£ãè§£æ³•\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findTarget(self, root: TreeNode, k: int) -\u0026gt; bool: if root is None: return False inordered = [] def inorder(root): if root is None: return if root.left is not None: inorder(root.left) inordered.append(root.val) if root.right is not None: inorder(root.right) inorder(root) left = 0 right = len(inordered) - 1 while left \u0026lt; right: added = inordered[left] + inordered[right] if added == k: return True elif added \u0026lt; k: left += 1 else: right -= 1 return False Two Sum BSTs 2 ã¤ã®äºŒåˆ†æ¢ç´¢æœ¨ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã®$2$-Sum å•é¡Œï¼äºŒåˆ†æ¢ç´¢æœ¨ã§ã¯root.left.val \u0026lt; root.val \u0026lt; root.right.valãŒæˆç«‹ã™ã‚‹ã®ã§ã‚ã‚‹æ„å‘³ã€Œæ•´åˆ—ã—ã¦ã„ã‚‹ã€ã¨ã‚‚è¨€ãˆã‚‹ï¼\ndef two_sum_bsts(root1, root2, target): if root2 is None: return False return helper(root1, root2.val, target) or two_sum_bsts(root1, root2.left, target) or two_sum_bsts(root1, root2.right, target) def helper(root1, root2_val, target): if root1 is None: return False added = root1.val + root2_val if added == target: return True elif added \u0026lt; target: return helper(root1.right, root2_val, target) else: # target \u0026lt; added return helper(root1.left, root2_val, target) Two Sum Less Than K é…åˆ—ãŒä¸ãˆã‚‰ã‚Œã¦ï¼Œãã®ä¸­ã‹ã‚‰å’ŒãŒ$K$ã‚’è¶…ãˆãªã„ç¯„å›²ã§æœ€ã‚‚å¤§ãããªã‚‹ã‚ˆã†ã«é‡è¤‡ã‚’è¨±ã•ãšã« 2 ã¤è¦ç´ ã‚’é¸ã‚“ã ã¨ãã®ï¼Œãã®å’Œã‚’è¨ˆç®—ã›ã‚ˆï¼\nnums = [34, 23, 1, 24, 75, 33, 54, 8] K = 60 def two_sum_less_than_k(nums, target): nums.sort() left = 0 right = len(nums) - 1 ans = -1 while left \u0026lt; right: added = nums[left] + nums[right] if added \u0026lt; target: ans = max(ans, added) left += 1 else: right -= 1 return ans print(two_sum_less_than_k(nums, K)) # =\u0026gt; 58 3Sum å…¨ä½“ã¨ã—ã¦ã¯$O(n^2)$\nclass Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: ret = [] nums.sort() for i in range(len(nums) - 2): if 1 \u0026lt;= i and nums[i - 1] == nums[i]: continue # skip same num left = i + 1 # target = nums[i] right = len(nums) - 1 while left \u0026lt; right: added = nums[i] + nums[left] + nums[right] if added == 0: ret.append([nums[i], nums[left], nums[right]]) while left \u0026lt; right and nums[left] == nums[left + 1]: # skip same num left += 1 while left \u0026lt; right and nums[right] == nums[right - 1]: # skip same num right -= 1 left += 1 right -= 1 elif added \u0026lt; 0: left += 1 else: # 0 \u0026lt; added right -= 1 return ret 3Sum Closest class Solution: def threeSumClosest(self, nums: List[int], target: int) -\u0026gt; int: diff = float(\u0026#34;inf\u0026#34;) nums.sort() for i in range(len(nums) - 2): left = i + 1 right = len(nums) - 1 while left \u0026lt; right: added = nums[i] + nums[left] + nums[right] if abs(target - added) \u0026lt; abs(diff): diff = target - added if added \u0026lt; target: left += 1 else: right -= 1 if diff == 0: break return target - diff 3Sum Smaller é…åˆ—ãŒä¸ãˆã‚‰ã‚Œã¦ï¼Œãã®ä¸­ã‹ã‚‰å’ŒãŒ$K$ã‚’è¶…ãˆãªã„ç¯„å›²ã§æœ€ã‚‚å¤§ãããªã‚‹ã‚ˆã†ã«é‡è¤‡ã‚’è¨±ã•ãšã« 3 ã¤è¦ç´ ã‚’é¸ã¶ã¨ãã®æ•°å­—ã®é¸ã³æ–¹ã®ç·æ•°ã‚’æ±‚ã‚ã‚ˆï¼\nnums = [-2, 0, 1, 3] target = 2 def two_sum_smaller(nums, target): def two_sum(nums, target): left = 0 right = len(nums) - 1 ans = 0 while left \u0026lt; right: added = nums[left] + nums[right] if added \u0026lt; target: ans += (right - left) left += 1 else: right -= 1 return ans nums.sort() ans = 0 for i in range(len(nums) - 2): ans += two_sum(nums[i + 1:], target - nums[i]) return ans print(two_sum_smaller(nums, target)) # =\u0026gt; 2 4Sum $3$-Sum ã¨åŒæ§˜ã«è€ƒãˆã‚Œã°$K$-Sum ã¯$2$-Sum ã«å¸°ç€ã§ãã‚‹ï¼\nclass Solution: def fourSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: def k_sum(nums, target, k): ret = [] if len(nums) == 0 or target \u0026lt; nums[0] * k or nums[-1] * k \u0026lt; target: return ret if k == 2: return two_sum(nums, target) for i in range(len(nums)): if 1 \u0026lt;= i and nums[i - 1] == nums[i]: continue for _ret in k_sum(nums[i + 1:], target - nums[i], k - 1): ret.append([nums[i]] + _ret) return ret def two_sum(nums, target): ret = [] left = 0 right = len(nums) - 1 while left \u0026lt; right: added = nums[left] + nums[right] if added == target: ret.append([nums[left], nums[right]]) while left \u0026lt; right and nums[left] == nums[left + 1]: left += 1 while left \u0026lt; right and nums[right - 1] == nums[right]: right -= 1 left += 1 right -= 1 elif added \u0026lt; target: left += 1 else: right -= 1 return ret nums.sort() return k_sum(nums, target, 4) 4Sum II ï¼ˆAï¼ŒBï¼‰ã¨ï¼ˆCï¼ŒDï¼‰ã§ãã‚Œãã‚Œã®çµ„ã§ã‚ã‚Šãˆã‚‹çµ„ã¿åˆã‚ã›ã‚’ãƒ¡ãƒ¢ã—ã¦ãŠã„ã¦ï¼Œé•ã†ã«æ‰“ã¡æ¶ˆã—åˆã†ã‚„ã¤ãŒã‚ã‚Œã°ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ï¼\nclass Solution: def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -\u0026gt; int: ans = 0 counter_AB = Counter() counter_CD = Counter() for (a, b) in product(A, B): counter_AB[a + b] += 1 for (c, d) in product(C, D): counter_CD[c + d] += 1 for sum_ab in counter_AB: if -sum_ab in counter_CD: ans += counter_AB[sum_ab] * counter_CD[-sum_ab] return ans Max Number of K-Sum Pairs ç›¸æ–¹å€™è£œãŒä½•äººã„ã‚‹ã‹ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ï¼ãƒ€ãƒ–ãƒ«ã‚«ã‚¦ãƒ³ãƒˆã«æ³¨æ„ï¼\nclass Solution: def maxOperations(self, nums: List[int], k: int) -\u0026gt; int: ans = 0 cnt = Counter(nums) for num in cnt: ans += min(cnt[num], cnt[k - num]) return ans // 2 Count Good Meals class Solution: def countPairs(self, deliciousness: List[int]) -\u0026gt; int: MOD = 1_000_000_007 ans = 0 cnt = Counter(deliciousness) for item in cnt: for k in range(22): if item == 2 ** k - item: ans += cnt[item] * (cnt[item] - 1) else: ans += cnt[item] * cnt[2 ** k - item] return ans // 2 % MOD ","date":1617095025,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1617095025,"objectID":"ff97446e1b2f5bd0e498670853094cca","permalink":"/ja/post/n-sum-problems/","publishdate":"2021-03-30T18:03:45+09:00","relpermalink":"/ja/post/n-sum-problems/","section":"post","summary":"æ•´æ•°ã‚’è¦ç´ ã¨ã—ã¦æ ¼ç´ã™ã‚‹é…åˆ—ãŒä¸ãˆã‚‰ã‚Œï¼Œãã“ã‹ã‚‰$N$å€‹è¦ç´ ã‚’å–ã‚Šä¸Šã’ã¦ãã®å’ŒãŒ$X$ã«ãªã‚‹ã‚ˆã†ãªè¦ç´ ã®ã¨ã‚Šæ–¹ã¯ã„ãã¤ã‚ã‚‹ã‹ï¼Œè¦ç´ ã®ã¨ã‚Šæ–¹ã","tags":[],"title":"$2$-Sum, $3$-Sum, ..., $N$-Sum Problems","type":"post"},{"authors":[],"categories":[],"content":"AOJ-ITP1ã‚’ Python ã§è§£ãï¼\nITP1_1_A:  ç­”ãˆ print(\u0026#34;Hello World\u0026#34;)  ITP1_1_B:  ç­”ãˆ x = int(input()) print(x ** 3)  ITP1_1_C:  ç­”ãˆ h, w = map(int, input().split()) print(h * w, 2 * (h + w))  ITP1_1_D:  ç­”ãˆ S = int(input()) print(\u0026#34;{}:{}:{}\u0026#34;.format(S // 3600, (S % 3600) // 60, S % 60))  ITP1_2_A:  ç­”ãˆ a, b = map(int, input().split()) if a \u0026lt; b: print(\u0026#34;a \u0026lt; b\u0026#34;) elif a == b: print(\u0026#34;a == b\u0026#34;) else: print(\u0026#34;a \u0026gt; b\u0026#34;)  ITP1_2_B:  ç­”ãˆ a, b, c = map(int, input().split()) if a \u0026lt; b \u0026lt; c: print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;)  ITP1_2_C:  ç­”ãˆ lst = list(map(int, input().split())) lst.sort() print(*lst)  ITP1_2_D:  ç­”ãˆ W, H, x, y, r = map(int, input().split()) if r \u0026lt;= x \u0026lt;= W - r and r \u0026lt;= y \u0026lt;= H - r: print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;)  ITP1_3_A:  ç­”ãˆ for _ in range(1000): print(\u0026#34;Hello World\u0026#34;)  ITP1_3_B:  ç­”ãˆ i = 1 while True: x = int(input()) if x == 0: break print(\u0026#34;Case {}: {}\u0026#34;.format(i, x)) i += 1  ITP1_3_C:  ç­”ãˆ while True: x, y = map(int, input().split()) if x == 0 and y == 0: break if y \u0026lt; x: x, y = y, x print(x, y)  ITP1_3_D:  ç­”ãˆ a, b, c = map(int, input().split()) cnt = 0 for i in range(a, b + 1): if c % i == 0: cnt += 1 print(cnt)  ITP1_4_A:  ç­”ãˆ a, b = map(int, input().split()) print(a // b, a % b, \u0026#34;{:.6f}\u0026#34;.format(a / b))  ITP1_4_B:  ç­”ãˆ from math import pi r = int(input()) print(\u0026#34;{:.6f} {:.6f}\u0026#34;.format(2 * pi * r, pi * r ** 2))  ITP1_4_C:  ç­”ãˆ while True: s = input().split() lhs = int(s[0]) op = s[1] rhs = int(s[2]) if op == \u0026#34;?\u0026#34;: break if op == \u0026#34;+\u0026#34;: print(lhs + rhs) elif op == \u0026#34;-\u0026#34;: print(lhs - rhs) elif op == \u0026#34;*\u0026#34;: print(lhs * rhs) elif op == \u0026#34;/\u0026#34;: print(lhs // rhs)  ITP1_4_D:  ç­”ãˆ _ = int(input()) lst = list(map(int, input().split())) print(min(lst), max(lst), sum(lst))  ITP1_5_A:  ç­”ãˆ while True: h, w = map(int, input().split()) if h == 0 and w == 0: break for _ in range(h): print(\u0026#34;#\u0026#34; * w) print()  ITP1_5_B:  ç­”ãˆ while True: h, w = map(int, input().split()) if h == 0 and w == 0: break print(\u0026#34;#\u0026#34; * w) for _ in range(h - 2): print(\u0026#34;#\u0026#34; + \u0026#34;.\u0026#34; * (w - 2) + \u0026#34;#\u0026#34;) print(\u0026#34;#\u0026#34; * w) print()  ITP1_5_C:  ç­”ãˆ while True: H, W = map(int, input().split()) if H == 0 and W == 0: break for h in range(H): for w in range(W): if (h + w) % 2 == 0: print(\u0026#34;#\u0026#34;, end=\u0026#34;\u0026#34;) else: print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) print() print()  ITP1_5_D:  ç­”ãˆ N = int(input()) for i in range(1, N + 1): if i % 3 == 0 or \u0026#34;3\u0026#34; in str(i): print(\u0026#34; {}\u0026#34;.format(i), end=\u0026#34;\u0026#34;) print()  ITP1_6_A:  ç­”ãˆ _ = int(input()) lst = list(map(int, input().split())) lst.reverse() print(*lst)  ITP1_6_B:  ç­”ãˆ N = int(input()) suits = [\u0026#34;S\u0026#34;, \u0026#34;H\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;] cards = [] for _ in range(N): s, n = input().split() if s == \u0026#34;S\u0026#34;: cards.append(int(n)) elif s == \u0026#34;H\u0026#34;: cards.append(13 + int(n)) elif s == \u0026#34;C\u0026#34;: cards.append(26 + int(n)) else: cards.append(39 + int(n)) for i in range(1, 53): if i not in cards: print(suits[(i - 1) // 13], (i - 1) % 13 + 1) ele in lstã¯n = len(lst)ã¨ã—ã¦$O(n)$ã‚‰ã—ã„ï¼\n ITP1_6_C:  ç­”ãˆ N = int(input()) room = [[[0] * 10 for _ in range(3)] for _ in range(4)] for _ in range(N): b, f, r, v = map(int, input().split()) room[b - 1][f - 1][r - 1] += v for i in range(4): for j in range(3): for k in range(10): print(\u0026#34; {}\u0026#34;.format(room[i][j][k]), end=\u0026#34;\u0026#34;) print() if i != 3: print(\u0026#34;####################\u0026#34;)  ITP1_6_D:  ç­”ãˆ N, M = map(int, input().split()) A = [list(map(int, input().split())) for _ in range(N)] B = [int(input()) for _ in range(M)] for i in range(N): ans = 0 for j in range(M): ans += A[i][j] * B[j] print(ans)  ITP1_7_A:  ç­”ãˆ while True: m, f, r = map(int, input().split()) if m == -1 and f == -1 and r == -1: break score = m + f if m == -1 or f == -1: print(\u0026#34;F\u0026#34;) elif 80 \u0026lt;= score: print(\u0026#34;A\u0026#34;) elif 65 \u0026lt;= score: print(\u0026#34;B\u0026#34;) elif 50 \u0026lt;= score: print(\u0026#34;C\u0026#34;) elif 30 \u0026lt;= score: if 50 \u0026lt;= r: print(\u0026#34;C\u0026#34;) else: print(\u0026#34;D\u0026#34;) else: print(\u0026#34;F\u0026#34;)  ITP1_7_B:  ç­”ãˆ while True: N, X = map(int, input().split()) if N == 0 and X == 0: break cnt = 0 for i in range(1, N - 1): for j in range(i + 1, N): if j \u0026lt; X - i - j \u0026lt;= N: cnt += 1 print(cnt)  ITP1_7_C:  ç­”ãˆ H, W = map(int, input().split()) sheet = [list(map(int, input().split())) for _ in range(H)] for h in range(H): sheet[h].append(sum(sheet[h])) sheet.append([0 for _ in range(W + 1)]) for w in range(W + 1): for h in range(H): sheet[-1][w] += sheet[h][w] for r in sheet: print(*r)  ITP1_7_D:  ç­”ãˆ N, M, L = map(int, input().split()) A = [list(map(int, input().split())) for _ in range(N)] B = [list(map(int, input().split())) for _ in range(M)] C = [[0 for _ in range(L)] for _ in range(N)] for i in range(N): for j in range(L): c = 0 for k in range(M): c += A[i][k] * B[k][j] C[i][j] = c for r in C: print(*r)  ITP1_8_A:  ç­”ãˆ string = input() print(string.swapcase())  ITP1_8_B:  ç­”ãˆ while True: x = int(input()) if x == 0: break ans = 0 while x: ans += x % 10 x //= 10 print(ans)  ITP1_8_C:  ç­”ãˆ import sys string = sys.stdin.read().lower() cnt = [0] * 26 alphabets = [chr(ord(\u0026#39;a\u0026#39;) + i) for i in range(26)] for x in string: if x in alphabets: cnt[alphabets.index(x)] += 1 for i in range(26): print(\u0026#34;{} : {}\u0026#34;.format(alphabets[i], cnt[i]))  ITP1_8_D:  ç­”ãˆ s = input() p = input() s = s + s if s.find(p) != -1: print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;)  ITP1_9_A:  ç­”ãˆ import sys word = input() text = sys.stdin.read() print(text.lower().split().count(word))  ITP1_9_B:  ç­”ãˆ while True: cards = input() if cards == \u0026#34;-\u0026#34;: break m = int(input()) for i in range(m): interval = int(input()) head = cards[:interval] tail = cards[interval:] cards = tail + head print(cards)  ITP1_9_C:  ç­”ãˆ N = int(input()) taro = 0 hanako = 0 for i in range(N): card_taro, card_hanako = input().split() if card_taro == card_hanako: taro += 1 hanako += 1 elif card_taro \u0026lt; card_hanako: hanako += 3 else: taro += 3 print(taro, hanako)  ITP1_9_D:  ç­”ãˆ text = input() N = int(input()) for _ in range(N): command = input().split() if command[0] == \u0026#34;replace\u0026#34;: a = int(command[1]) b = int(command[2]) s = command[3] text = text[:a] + s + text[b + 1:] elif command[0] == \u0026#34;reverse\u0026#34;: a = int(command[1]) b = int(command[2]) text = text[:a] + \u0026#34;\u0026#34;.join(reversed(text[a:b + 1])) + text[b + 1:] else: a = int(command[1]) b = int(command[2]) print(text[a:b + 1])  ITP1_10_A:  ç­”ãˆ x1, y1, x2, y2 = map(float, input().split()) print(((x1 - x2) **2 + (y1 - y2) ** 2) ** 0.5)  ITP1_10_B:  ç­”ãˆ import math a, b, C=map(float, input().split()) theta = math.radians(C) h = b * math.sin(theta) S = (a * h) / 2 c = math.sqrt(a ** 2 + b ** 2 - 2 * a * b * math.cos(theta)) L = a + b + c print(S, L, h, sep=\u0026#34;\\n\u0026#34;)  ITP1_10_C:  ç­”ãˆ while True: N = int(input()) if N == 0: break score = list(map(int, input().split())) mean = sum(score) / N variant = 0 for i in range(N): variant += (score[i] - mean) ** 2 print((variant / N) ** 0.5)  ITP1_10_D:  ç­”ãˆ def dist(xs, ys, p): ret = 0 for (x, y) in zip(xs, ys): ret += abs(x - y) ** p return ret ** (1 / p) N = int(input()) xs = list(map(int, input().split())) ys = list(map(int, input().split())) for p in range(1, 4): print(dist(xs, ys, p)) print(max(abs(x - y) for (x, y) in zip(xs, ys)))  ITP1_11_A:  ç­”ãˆ class Dice: def __init__(self, nums): self.s1 = nums[0] self.s2 = nums[1] self.s3 = nums[2] self.s4 = nums[3] self.s5 = nums[4] self.s6 = nums[5] def rotate(self, dir): if dir == \u0026#34;N\u0026#34;: self.s1, self.s2, self.s5, self.s6 = self.s2, self.s6, self.s1, self.s5 elif dir == \u0026#34;S\u0026#34;: self.s1, self.s2, self.s5, self.s6 = self.s5, self.s1, self.s6, self.s2 elif dir == \u0026#34;E\u0026#34;: self.s1, self.s3, self.s4, self.s6 = self.s4, self.s1, self.s6, self.s3 else: # dir == \u0026#34;W\u0026#34;: self.s1, self.s3, self.s4, self.s6 = self.s3, self.s6, self.s1, self.s4 nums = list(map(int, input().split())) ops = input() d = Dice(nums) for op in ops: d.rotate(op) print(d.s1)  ITP1_11_B:  ç­”ãˆ class Dice: def __init__(self, nums): self.nums = nums def rotate(self, dir): if dir == \u0026#34;N\u0026#34;: self.nums[0], self.nums[1], self.nums[4], self.nums[5] = self.nums[1], self.nums[5], self.nums[0], self.nums[4] elif dir == \u0026#34;S\u0026#34;: self.nums[0], self.nums[1], self.nums[4], self.nums[5] = self.nums[4], self.nums[0], self.nums[5], self.nums[1] elif dir == \u0026#34;E\u0026#34;: self.nums[0], self.nums[2], self.nums[3], self.nums[5] = self.nums[3], self.nums[0], self.nums[5], self.nums[2] else: # dir == \u0026#34;W\u0026#34;: self.nums[0], self.nums[2], self.nums[3], self.nums[5] = self.nums[2], self.nums[5], self.nums[0], self.nums[3] def query(self, top, front): saved = nums ret = -1 for dir in \u0026#34;NNNNWNNNWNNNENNNENNNWNNN\u0026#34;: self.rotate(dir) if self.nums[0] == top and self.nums[1] == front: ret = self.nums[2] break self.nums = saved return ret nums = list(map(int, input().split())) N = int(input()) d = Dice(nums) for _ in range(N): top, front = map(int, input().split()) print(d.query(top, front))  ITP1_11_C:  ç­”ãˆ class Dice: def __init__(self, nums): self.nums = nums def rotate(self, dir): if dir == \u0026#34;N\u0026#34;: self.nums[0], self.nums[1], self.nums[4], self.nums[5] = self.nums[1], self.nums[5], self.nums[0], self.nums[4] elif dir == \u0026#34;S\u0026#34;: self.nums[0], self.nums[1], self.nums[4], self.nums[5] = self.nums[4], self.nums[0], self.nums[5], self.nums[1] elif dir == \u0026#34;E\u0026#34;: self.nums[0], self.nums[2], self.nums[3], self.nums[5] = self.nums[3], self.nums[0], self.nums[5], self.nums[2] else: # dir == \u0026#34;W\u0026#34;: self.nums[0], self.nums[2], self.nums[3], self.nums[5] = self.nums[2], self.nums[5], self.nums[0], self.nums[3] def query(self, top, front): saved = nums ret = -1 for dir in \u0026#34;NNNNWNNNWNNNENNNENNNWNNN\u0026#34;: self.rotate(dir) if self.nums[0] == top and self.nums[1] == front: ret = self.nums[2] break self.nums = saved return ret def is_equal(self, other): for dir in \u0026#34;NNNNWNNNWNNNENNNENNNWNNN\u0026#34;: self.rotate(dir) flag = True for k in range(6): if self.nums[k] != other.nums[k]: flag = False break if flag: return True return False nums = list(map(int, input().split())) d1 = Dice(nums) nums = list(map(int, input().split())) d2 = Dice(nums) if d1.is_equal(d2): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;)  ITP1_11_D:  ç­”ãˆ class Dice: def __init__(self, nums): self.nums = nums def rotate(self, dir): if dir == \u0026#34;N\u0026#34;: self.nums[0], self.nums[1], self.nums[4], self.nums[5] = self.nums[1], self.nums[5], self.nums[0], self.nums[4] elif dir == \u0026#34;S\u0026#34;: self.nums[0], self.nums[1], self.nums[4], self.nums[5] = self.nums[4], self.nums[0], self.nums[5], self.nums[1] elif dir == \u0026#34;E\u0026#34;: self.nums[0], self.nums[2], self.nums[3], self.nums[5] = self.nums[3], self.nums[0], self.nums[5], self.nums[2] else: # dir == \u0026#34;W\u0026#34;: self.nums[0], self.nums[2], self.nums[3], self.nums[5] = self.nums[2], self.nums[5], self.nums[0], self.nums[3] def query(self, top, front): saved = nums ret = -1 for dir in \u0026#34;NNNNWNNNWNNNENNNENNNWNNN\u0026#34;: self.rotate(dir) if self.nums[0] == top and self.nums[1] == front: ret = self.nums[2] break self.nums = saved return ret def is_equal(self, other): for dir in \u0026#34;NNNNWNNNWNNNENNNENNNWNNN\u0026#34;: self.rotate(dir) flag = True for k in range(6): if self.nums[k] != other.nums[k]: flag = False break if flag: return True return False N = int(input()) dices = [] for _ in range(N): nums = list(map(int, input().split())) dices.append(Dice(nums)) flag = True for i in range(N - 1): for j in range(i + 1, N): if dices[i].is_equal(dices[j]): flag = False break if flag: print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;)  ","date":1616999640,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616999640,"objectID":"52fbbf3cc23263ccad1df0b359bd6655","permalink":"/ja/post/aoj-itp1/","publishdate":"2021-03-29T15:34:00+09:00","relpermalink":"/ja/post/aoj-itp1/","section":"post","summary":"AOJ-ITP1ã‚’ Python ã§è§£ãï¼ ITP1_1_A: ç­”ãˆ print(\u0026#34;Hello World\u0026#34;) ITP1_1_B: ç­”ãˆ x = int(input()) print(x ** 3) ITP1_1_C: ç­”ãˆ h, w = map(int, input().split()) print(h * w, 2 * (h + w)) ITP1_1_D: ç­”ãˆ S = int(input()) print(\u0026#34;{}:{}:{}\u0026#34;.format(S // 3600, (S % 3600) // 60, S % 60)) ITP1_2_A: ç­”ãˆ a, b = map(int, input().split()) if","tags":[],"title":"AOJ ITP1 in Python","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æœ¨ã®ç›´å¾„ã‚’æ±‚ã‚ã‚ˆï¼\nç­”ãˆ ä»»æ„ã®é ‚ç‚¹$x$ã‹ã‚‰ BFS ã‚’ã—ã¦$x$ã‹ã‚‰æœ€é ã®é ‚ç‚¹$u$ã‚’è¨ˆç®—ã—ï¼Œå†ã³$u$ã‹ã‚‰ BFS ã—ã¦$u$ã‹ã‚‰æœ€é ã®é ‚ç‚¹$v$ã‚’è¨ˆç®—ã™ã‚‹ï¼ã“ã®ã¨ãï¼Œ$u$-$v$ã¯ãã®æœ¨ã®ç›´å¾„ã‚’ãªã™ãƒ‘ã‚¹ã®ä¸¡ç«¯ç‚¹ã«ãªã£ã¦ã„ã‚‹ï¼\nN = int(input()) T = [[] for _ in range(N)] for _ in range(N-1): s, t, w = map(int, input().split()) T[s].append((t, w)) T[t].append((s, w)) def BFS(tree, s): dist = [-1 for _ in range(N)] dist[s] = 0 suspended = [s] while suspended: u = suspended.pop(0) cost = dist[u] for (v, w) in tree[u]: if dist[v] == -1: dist[v] = cost + w suspended.append(v) d = max(dist) return dist.index(d), d u, _ = BFS(T, 0) v, diameter = BFS(T, u) print(diameter) å¯¾è±¡ã¨ãªã‚‹æœ¨ãŒã€ŒäºŒåˆ†æœ¨ã€ã§ã‚ã‚‹ã¨ãã¯åˆ¥ã®è§£ãæ–¹ã‚‚ã§ãã‚‹ï¼ã‚ã‚‹é ‚ç‚¹ã‚’æ ¹ã¨ã—ãŸã¨ãï¼Œã€Œãã®æ ¹ã®å·¦éƒ¨åˆ†æœ¨ã®ç›´å¾„ã€ï¼Œã€Œãã®æ ¹ã®å³éƒ¨åˆ†æœ¨ã®ç›´å¾„ã€ï¼Œã€Œãã®æ ¹ã®å·¦å³ã®éƒ¨åˆ†æœ¨ã®é«˜ã•ã®å’Œ+1ã€ã®ã†ã¡ã®æœ€å¤§å€¤ãŒãã®æœ¨ã®ç›´å¾„ã¨ãªã‚‹ï¼ã“ã‚Œã‚’å†å¸°çš„ã«æ›¸ã„ã¦ã‚‚ç­”ãˆãŒå¾—ã‚‰ã‚Œã‚‹ï¼\nclass TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def get_height(root): if root is None: return 0 if root.left is None and root.right is None: return 1 if root.left is None and root.right is not None: return get_height(root.right) + 1 if root.left is not None and root.right is None: return get_height(root.left) + 1 # root.left is not None and root.right is not None: return max(get_height(root.left), get_height(root.right)) + 1 def get_diameter(root): if root is None: return 0 left_height = get_height(root.left) right_height = get_height(root.right) root_diameter = left_height + right_height + 1 left_diameter = get_diameter(root.left) right_diameter = get_diameter(root.right) return max(left_diameter, right_diameter, root_diameter) ","date":1616998230,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616998230,"objectID":"04f39a51ddef0edbc3f3054c896aa630","permalink":"/ja/post/diameter-of-a-tree/","publishdate":"2021-03-29T15:10:30+09:00","relpermalink":"/ja/post/diameter-of-a-tree/","section":"post","summary":"å•é¡Œ æœ¨ã®ç›´å¾„ã‚’æ±‚ã‚ã‚ˆï¼ ç­”ãˆ ä»»æ„ã®é ‚ç‚¹$x$ã‹ã‚‰ BFS ã‚’ã—ã¦$x$ã‹ã‚‰æœ€é ã®é ‚ç‚¹$u$ã‚’è¨ˆç®—ã—ï¼Œå†ã³$u$ã‹ã‚‰ BFS ã—ã¦$u$ã‹ã‚‰æœ€é ã®é ‚ç‚¹$v$ã‚’è¨ˆ","tags":[],"title":"Diameter of a Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ã‚ã‚‹ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’è€ƒãˆã‚ˆã†ï¼ãã®ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’å®¹å™¨ã«è¦‹ç«‹ã¦ã¦ä¸Šã‹ã‚‰æ°´ã‚’æµã—è¾¼ã‚€ï¼ã“ã®ã¨ãï¼Œãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ å†…ã«è²¯ã¾ã‚‹æ°´ã®é‡ã¯ã„ãã¤ã‹ï¼\nå…¥åŠ›ã¨ã—ã¦ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã¯ãƒªã‚¹ãƒˆã®å½¢ã§ä¸ãˆã‚‰ã‚Œã‚‹ï¼\n_ |x| _ _ |x| |x| |x| |x| _ |x| |x| |x| |x| |x| |x| |x| |x| |x| _ |x| |x| |x| |x| |x| ------------------------------------------------ input = [0, 0, 4, 0, 0, 6, 0, 0, 3, 0, 5, 0, 1, 0, 0, 0] æ™‚é–“è¨ˆç®—é‡$O(n^2)$ãƒ»ç©ºé–“è¨ˆç®—é‡$O(1)$ãªç­”ãˆ ã‚ã‚‹ä½ç½®iã§æºœã¾ã‚‹æ°´ã®é«˜ã•ã¯ï¼Œãã®ä½ç½®ã‹ã‚‰å·¦å³ä¸¡å´ã‚’è¦‹ã¦ï¼Œãã®ä½ç½®ã‚ˆã‚Šé«˜ã„åœ°ç‚¹ãŒã‚ã‚‹ãªã‚‰ãã‚Œã‚‰ã®ä½ã„æ–¹ã®é«˜ã•ã«ãªã‚‹ï¼ã“ã‚Œã‚’å„ä½ç½®ã«ã¤ã„ã¦è¨ˆç®—ã™ã‚‹ï¼\nhist = [0, 0, 4, 0, 0, 6, 0, 0, 3, 0, 5, 0, 1, 0, 0, 0] def volume_of_hist(hist): if len(hist) == 0: return 0 volume = 0 for i in range(len(hist)): max_by_left = max(hist[:i]) if 0 \u0026lt; i else 0 max_by_right = max(hist[:i + 1]) if i \u0026lt; len(hist) - 1 else 0 volume += max(0, min(max_by_left, max_by_right) - hist[i]) return volume print(volume_of_hist(hist)) # =\u0026gt; 26 æ™‚é–“è¨ˆç®—é‡$O(n)$ãƒ»ç©ºé–“è¨ˆç®—é‡$O(n)$ãªç­”ãˆ ã‚ã‚‹ä½ç½®iã‹ã‚‰è¦‹ã¦å·¦å³ã®é«˜ã•ã®æœ€å¤§å€¤ã¯ï¼Œä½ç½®i - 1ã§ã®ãã‚Œã¨ä½ç½®iã®é«˜ã•ã®ã†ã¡ã®é«˜ã„æ–¹ãªã®ã§ï¼Œå·¦å³ã‹ã‚‰ã€Œãã®ä½ç½®ã§ã®ç›´è¿‘ã®æœ€å¤§å€¤ã€ã‚’è¨ˆç®—ã—ï¼Œå„ä½ç½®ã§å°ã•ã„æ–¹ã‚’å–ã‚Œã°æ°´é¢ã®é«˜ã•ãŒå–ã‚Œã‚‹ï¼max_by_left/max_by_rightã‚’çœŸé¢ç›®ã«æ±‚ã‚ã‚‹ã®ã§ã¯ãªãã¦ç›´è¿‘ã¨ã®æ¯”è¼ƒã§æ™‚é–“åŠ¹ç‡è‰¯ãæ±‚ã‚ã‚‹ã¨ã„ã†ã®ãŒã“ã®ã‚„ã‚Šæ–¹ï¼\n   ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¦‚è¦³   hist = [0, 0, 4, 0, 0, 6, 0, 0, 3, 0, 5, 0, 1, 0, 0, 0] def volume_of_hist(hist): if len(hist) == 0: return 0 max_by_left = [0] * len(hist) max_by_left[0] = hist[0] for i in range(1, len(hist)): max_by_left[i] = max(max_by_left[i - 1], hist[i]) max_by_right = [0] * len(hist) max_by_right[-1] = hist[-1] for i in range(len(hist) - 2, -1, -1): max_by_right[i] = max(max_by_right[i + 1], hist[i]) height = [0] * len(hist) for i in range(len(hist)): height[i] = min(max_by_left[i], max_by_right[i]) volume = 0 for i in range(len(hist)): volume += (height[i] - hist[i]) return volume print(volume_of_hist(hist)) # =\u0026gt; 26 _ |x| _ _ |x| |x| |x| |x| _ |x| |x| |x| |x| |x| |x| |x| |x| |x| _ |x| |x| |x| |x| |x| ------------------------------------------------ [0, 0, 4, 0, 0, 6, 0, 0, 3, 0, 5, 0, 1, 0, 0, 0] \u0026lt;- input [0, 0, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6] \u0026lt;- max_by_left [6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 1, 1, 0, 0, 0] \u0026lt;- max_by_right [0, 0, 4, 4, 4, 6, 5, 5, 5, 5, 5, 1, 1, 0, 0, 0] \u0026lt;- height = min(max_by_left[i], max_by_right[i]) [0, 0, 0, 4, 4, 0, 5, 5, 2, 5, 0, 1, 0, 0, 0, 0] \u0026lt;- volume = height - input æ™‚é–“è¨ˆç®—é‡$O(n)$ãƒ»ç©ºé–“è¨ˆç®—é‡$O(1)$ãªç­”ãˆ å·¦å³ã‹ã‚‰åŒæ™‚ã«é«˜ã•ã‚’æ±‚ã‚ã¦ã„ãã“ã¨ã§ç©ºé–“è¨ˆç®—é‡ã‚’å‰Šæ¸›ã™ã‚‹ï¼å·¦å³ã‹ã‚‰ãƒã‚¤ãƒ³ã‚¿ã‚’äº¤å·®ã™ã‚‹ã¾ã§èµ°ã‚‰ã›ï¼Œèµ°ã‚‰ã›ãªãŒã‚‰é«˜ã•ã‚’ç¢ºå®šã•ã›ã¦ã„ãï¼\nhist = [0, 0, 4, 0, 0, 6, 0, 0, 3, 0, 5, 0, 1, 0, 0, 0] def volume_of_hist(hist): if len(hist) == 0: return 0 left = 0 right = len(hist) - 1 max_height = 0 volume = 0 while left \u0026lt; right: if hist[left] \u0026lt;= hist[right]: curr_height = hist[left] left += 1 else: curr_height = hist[right] right -= 1 volume += max(0, max_height - curr_height) max_height = max(max_height, curr_height) return volume print(volume_of_hist(hist)) # =\u0026gt; 26 é¡é¡Œ 3 æ¬¡å…ƒã®ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã®æºœã¾ã‚‹æ°´ã®é‡ã‚’è¨ˆç®—ã›ã‚ˆï¼\n[[1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1]] é¡é¡Œç­”ãˆ å¤–å €ã‹ã‚‰åŸ‹ã‚ã¦ã„ãï¼\nhist_3d = [ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ] import heapq def volume_of_hist_3d(hist_3d): if len(hist_3d) == 0 or len(hist_3d[0]) == 0: return 0 H = len(hist_3d) W = len(hist_3d[0]) if H \u0026lt;= 2 or W \u0026lt;= 2: return 0 # å¤–å €ãŒä½œã‚Œãšå…¨éƒ¨æµå‡ºã—ã¦ã—ã¾ã† has_visited = set() queue = [] for h in range(H): queue.append((hist_3d[h][0], h, 0)) queue.append((hist_3d[h][W - 1], h, W - 1)) has_visited.add((h, 0)) has_visited.add((h, W - 1)) for w in range(W): queue.append((hist_3d[0][w], 0, w)) queue.append((hist_3d[H - 1][w], H - 1, w)) has_visited.add((0, w)) has_visited.add((H - 1, w)) heapq.heapify(queue) max_height = 0 volume = 0 while len(queue) != 0: curr_height, h, w = heapq.heappop(queue) volume += max(0, max_height - curr_height) max_height = max(max_height, curr_height) for (dh, dw) in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nh = h + dh nw = w + dw if 0 \u0026lt;= nh \u0026lt; H and 0 \u0026lt;= nw \u0026lt; W and (nh, nw) not in has_visited: heapq.heappush(queue, (hist_3d[nh][nw], nh, nw)) has_visited.add((nh, nw)) return volume print(volume_of_hist_3d(hist_3d)) # =\u0026gt; 4 refs  https://leetcode.com/problems/trapping-rain-water/ https://leetcode.com/problems/trapping-rain-water-ii/  ","date":1616922436,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616922436,"objectID":"50e4b24ae6596bdfe33c208379c4f0fd","permalink":"/ja/post/volume-of-histogram/","publishdate":"2021-03-28T18:07:16+09:00","relpermalink":"/ja/post/volume-of-histogram/","section":"post","summary":"å•é¡Œ ã‚ã‚‹ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’è€ƒãˆã‚ˆã†ï¼ãã®ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’å®¹å™¨ã«è¦‹ç«‹ã¦ã¦ä¸Šã‹ã‚‰æ°´ã‚’æµã—è¾¼ã‚€ï¼ã“ã®ã¨ãï¼Œãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ å†…ã«è²¯ã¾ã‚‹æ°´ã®é‡ã¯ã„ãã¤ã‹ï¼ å…¥åŠ›ã¨","tags":[],"title":"Volume of Histogram","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ åŒä¸€è¦ç´ ã‚’å«ã¾ãªã„ï¼Œé•·ã•$n$ã®é…åˆ—lstãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼å°ã•ã„é †ã«$k$å€‹ã®è¦ç´ ã‚’å–ã‚Šå‡ºã›ï¼\nç­”ãˆ $O(n \\log n)$ï¼šæ˜‡é †ã«ã‚½ãƒ¼ãƒˆã—ã¦å…ˆé ­$k$å€‹å–ã‚Šå‡ºã™ ã‚½ãƒ¼ãƒˆã™ã‚‹ã®ã«$O(n \\log n)$ï¼\ndef smallest_k(lst, k): lst.sort() return lst[:k] $O(nk)$ï¼šãƒãƒ–ãƒ«ã‚½ãƒ¼ãƒˆã‚’é€”ä¸­ã§ã‚„ã‚ã‚‹ å…ˆé ­$k$å€‹ãŒæ±ºå®šã™ã‚‹ã¾ã§æ˜‡é †ã®ãƒãƒ–ãƒ«ã‚½ãƒ¼ãƒˆã‚’å®Ÿè¡Œã—ï¼Œé€”ä¸­ã§ã‚„ã‚ã‚‹ï¼\ndef smallest_k(lst, k): for i in range(0, k, 1): for j in range(len(lst) - 1, i, -1): if lst[j - 1] \u0026gt; lst[j]: lst[j - 1], lst[j] = lst[j], lst[j - 1] return lst[:k] $O(k \\log n)$ï¼šãƒ’ãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆã‚’é€”ä¸­ã§ã‚„ã‚ã‚‹ å…ˆé ­$k$å€‹ãŒæ±ºå®šã™ã‚‹ã¾ã§æ˜‡é †ã®ãƒ’ãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆã‚’å®Ÿè¡Œã—ï¼Œé€”ä¸­ã§ã‚„ã‚ã‚‹ï¼\nimport heapq def smallest_k(lst, k): heapq.heapify(lst) ret = [] for _ in range(k): ret.append(heapq.heappop(lst)) return ret heapqã«ã¯ãã‚Œç”¨ã®heapq.nsmallest()é–¢æ•°ãŒç”¨æ„ã•ã‚Œã¦ã„ã‚‹ï¼\nimport heapq def smallest_k(lst, k): return heapq.nsmallest(k, lst) $O(n \\log k)$ï¼šã‚µã‚¤ã‚º$k$ã® Max Heap ã‚’ä½œã‚‹ lstã®è¦ç´ ã‚’ä¸€ã¤ãšã¤è¦‹ãªãŒã‚‰ Max Heap ã‚’ä½œã‚‹ï¼ä»Šè¦‹ã¦ã‚‹è¦ç´ ã‚ˆã‚Š Max Heap ã®å…ˆé ­ãŒå¤§ãã‹ã£ãŸã‚‰ç¾åœ¨ã® Max Heap ã®å…ˆé ­ã¯ç­”ãˆã«å«ã¾ã‚Œãªã„ã®ã§popã—ã¦ä»Šè¦‹ã¦ã‚‹è¦ç´ ã‚’pushã™ã‚‹ï¼\ndef smallest_k(lst, k): def max_heapify(lst): p = len(lst) // 2 while -1 \u0026lt; p: left = 2*p + 1 if 2*p + 1 \u0026lt; len(lst) else -1 right = 2*p + 2 if 2*p + 2 \u0026lt; len(lst) else -1 if left != -1 and lst[p] \u0026lt; lst[left]: lst[p], lst[left] = lst[left], lst[p] if right != -1 and lst[p] \u0026lt; lst[right]: lst[p], lst[right] = lst[right], lst[p] p -= 1 def max_heappop(lst): m = lst.pop(0) max_heapify(lst) return m def max_heappush(lst, ele): lst.append(ele) max_heapify(lst) heap = [] for ele in lst: if len(heap) \u0026lt; k: max_heappush(heap, ele) elif ele \u0026lt; heap[0]: max_heappop(heap) max_heappush(heap, ele) return heap $O(n)$ï¼šSelection Rank Algorithm $k$ç•ªç›®ã«å°ã•ã„å€¤ã‚’åŠ¹ç‡ã‚ˆãè¦‹ã¤ã‘å‡ºã—ï¼Œãã‚Œä»¥ä¸Šã®å€¤ã‚’å–ã£ã¦ãã‚‹ã¨ã„ã†ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼åˆ†å‰²çµ±æ²»æ³•ï¼æœ€æ‚ªã®æ™‚é–“è¨ˆç®—é‡ã¯$O(n^2)$ã ãŒï¼Œã†ã¾ãè¡Œã‘ã°$O(n)$ãŒæœŸå¾…ã§ãã‚‹ï¼ã‚¯ã‚¤ãƒƒã‚¯ã‚½ãƒ¼ãƒˆã®æ¢ç´¢ç‰ˆã‚’ä½¿ã£ã¦$k$ç•ªç›®ã«å°ã•ã„å€¤ã‚’æ‹¾ã£ã¦ãã‚‹ï¼\ndef smallest_k(lst, k): # partition lst[left:right+1] by pivot = lst[right] # left, right: 0-origin # [left_side] \u0026lt;= pivot \u0026lt; [right_side] def partition(lst, left, right): pivot = lst[right] left_end = left for curr in range(left, right): if lst[curr] \u0026lt;= pivot: lst[left_end], lst[curr] = lst[curr], lst[left_end] left_end += 1 lst[left_end], lst[right] = lst[right], lst[left_end] return left_end # tail index of left side(0-origin) # rank, left, right: 0-origin def get_ele_at_rank(lst, left, right, rank): if 0 \u0026lt;= rank and rank \u0026lt;= right - left: left_end = partition(lst, left, right) left_size = left_end - left + 1 # 1-origin count if left_end - left == rank: return lst[left_end] if rank \u0026lt; left_end - left: return get_ele_at_rank(lst, left, left_end - 1, rank) return get_ele_at_rank(lst, left_end + 1, right, rank - left_size) # given k: 1-origin kth_smallest = get_ele_at_rank(lst, 0, len(lst) - 1, k - 1) return [ele for ele in lst if ele \u0026lt;= kth_smallest] lst = [i for i in range(20)] import random random.shuffle(lst) lst = lst[:10] print(lst) k = 5 print(\u0026#34;{}th smallest elements: {}\u0026#34;.format(k, smallest_k(lst, k))) TODO: selection rank ã®å®Ÿè£…\n$O(n)$ï¼šäºŒåˆ†æ¢ç´¢æœ¨ã‚’ä½œã£ã¦é–“é †èµ°æŸ» æ­£ã—ã„äºŒåˆ†æ¢ç´¢æœ¨ã‚’é–“é †èµ°æŸ»ã™ã‚Œã°æ˜‡é †ã«$k$å€‹ã®é ‚ç‚¹ã‚’è¨ªã‚Œã‚‹ï¼\nclass TreeNode: def __init__(self, val=-1, left=None, right=None): self.val = val self.left = left self.right = right def insert(self, val): if self.val == val: return elif self.val \u0026lt; val: if self.right is None: self.right = TreeNode(val) else: self.right.insert(val) else: # self.key \u0026gt; key if self.left is None: self.left = TreeNode(val) else: self.left.insert(val) def display(self): lines, *_ = self._display_aux() for line in lines: print(line) def _display_aux(self): \u0026#34;\u0026#34;\u0026#34;Returns list of strings, width, height, and horizontal coordinate of the root.\u0026#34;\u0026#34;\u0026#34; # No child. if self.right is None and self.left is None: line = \u0026#39;%s\u0026#39; % self.val width = len(line) height = 1 middle = width // 2 return [line], width, height, middle # Only left child. if self.right is None: lines, n, p, x = self.left._display_aux() s = \u0026#39;%s\u0026#39; % self.val u = len(s) first_line = (x + 1) * \u0026#39; \u0026#39; + (n - x - 1) * \u0026#39;_\u0026#39; + s second_line = x * \u0026#39; \u0026#39; + \u0026#39;/\u0026#39; + (n - x - 1 + u) * \u0026#39; \u0026#39; shifted_lines = [line + u * \u0026#39; \u0026#39; for line in lines] return [first_line, second_line] + shifted_lines, n + u, p + 2, n + u // 2 # Only right child. if self.left is None: lines, n, p, x = self.right._display_aux() s = \u0026#39;%s\u0026#39; % self.val u = len(s) first_line = s + x * \u0026#39;_\u0026#39; + (n - x) * \u0026#39; \u0026#39; second_line = (u + x) * \u0026#39; \u0026#39; + \u0026#39;\\\\\u0026#39; + (n - x - 1) * \u0026#39; \u0026#39; shifted_lines = [u * \u0026#39; \u0026#39; + line for line in lines] return [first_line, second_line] + shifted_lines, n + u, p + 2, u // 2 # Two children. left, n, p, x = self.left._display_aux() right, m, q, y = self.right._display_aux() s = \u0026#39;%s\u0026#39; % self.val u = len(s) first_line = (x + 1) * \u0026#39; \u0026#39; + (n - x - 1) * \u0026#39;_\u0026#39; + s + y * \u0026#39;_\u0026#39; + (m - y) * \u0026#39; \u0026#39; second_line = x * \u0026#39; \u0026#39; + \u0026#39;/\u0026#39; + (n - x - 1 + u + y) * \u0026#39; \u0026#39; + \u0026#39;\\\\\u0026#39; + (m - y - 1) * \u0026#39; \u0026#39; if p \u0026lt; q: left += [n * \u0026#39; \u0026#39;] * (q - p) elif q \u0026lt; p: right += [m * \u0026#39; \u0026#39;] * (p - q) zipped_lines = zip(left, right) lines = [first_line, second_line] + [a + u * \u0026#39; \u0026#39; + b for a, b in zipped_lines] return lines, n + m + u, max(p, q) + 2, n + u // 2 import random lst = [i for i in range(100)] random.shuffle(lst) lst = lst[:20] root = TreeNode(val=lst[0]) for ele in lst[1:]: root.insert(ele) root.display() def smallest_k(root, k, sofar): if root is None: return if root.left is not None: sofar = smallest_k(root.left, k, sofar) if len(sofar) \u0026lt; k: sofar.append(root.val) if root.right is not None: sofar = smallest_k(root.right, k, sofar) return sofar k = 5 ret = smallest_k(root, k, []) print(ret) def is_bst(root): if root is None: return True if root.left is not None and root.left.val \u0026gt; root.val: return False if root.right is not None and root.right.val \u0026lt; root.val: return False if is_bst(root.left) or is_bst(root.right): return False return True print(is_bst(root)) ","date":1616904404,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616904404,"objectID":"58420703c816658cc6e36fd47b60966b","permalink":"/ja/post/find-k-th-smallest-elements/","publishdate":"2021-03-28T13:06:44+09:00","relpermalink":"/ja/post/find-k-th-smallest-elements/","section":"post","summary":"å•é¡Œ åŒä¸€è¦ç´ ã‚’å«ã¾ãªã„ï¼Œé•·ã•$n$ã®é…åˆ—lstãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼å°ã•ã„é †ã«$k$å€‹ã®è¦ç´ ã‚’å–ã‚Šå‡ºã›ï¼ ç­”ãˆ $O(n \\log n)$ï¼šæ˜‡é †ã«ã‚½ãƒ¼ãƒˆã—ã¦å…ˆé ­$k$å€‹","tags":[],"title":"Find $K$th Smallest Elements","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ é…åˆ—$A$ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼$A$ã®éåŠæ•°ã‚’å ã‚ã‚‹è¦ç´ ãŒã‚ã‚Œã°ãã‚Œã‚’è¦‹ã¤ã‘ãªã•ã„ï¼ãªã‘ã‚Œã°-1ã‚’è¿”ã—ãªã•ã„ï¼\nç­”ãˆ ãƒŠã‚¤ãƒ¼ãƒ–ãªã‚„ã‚Šæ–¹ï¼šå„è¦ç´ ã®é »åº¦ã‚’è¨ˆç®—ã—ã¦éåŠæ•°ã«é”ã—ã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹ï¼æ™‚é–“ã«ã¤ã„ã¦$O(n^2)$ï¼Œç©ºé–“ã«ã¤ã„ã¦$O(1)$\ndef find_majority_element(lst): def check(lst, candidate): count = 0 for ele in lst: if ele == candidate: count += 1 return len(lst) // 2 \u0026lt; count for ele in lst: if check(lst, ele): return ele return -1 é…åˆ—ã‚’ä¸€åº¦èˆã‚ã‚‹ã ã‘ã§ï¼ŒéåŠæ•°ã«é”ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„è¦ç´ ã¯è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ã“ã‚Œã‚’ä½¿ã†ã¨æ™‚é–“ã«ã¤ã„ã¦$O(n)$ï¼Œç©ºé–“ã«ã¤ã„ã¦$O(1)$ã§æ¸ˆã‚€ï¼\ndef find_majority_element(lst): def get_candidate(lst): count = 0 candidate = 0 for ele in lst: if count == 0: # æ—§candidateã¨åŒæ•°ã®ç•°ãªã‚‹è¦ç´ ãŒå­˜åœ¨ã—ãŸã®ã§å€™è£œã‹ã‚‰è½ã¡ï¼Œ # ä»Šè¦‹ã¦ã„ã‚‹è¦ç´ ãŒæ–°candidateã¨ãªã‚‹ï¼ candidate = ele if ele == candidate: count += 1 else: count -= 1 return candidate def validate(lst, candidate): count = 0 for ele in lst: if ele == candidate: count += 1 return len(lst) // 2 \u0026lt; count candidate = get_candidate(lst) return candidate if validate(lst, candidate) else -1 print(find_majority_element([1, 1, 2, 2, 1])) # =\u0026gt; 1 print(find_majority_element([1, 1, 2, 2])) # =\u0026gt; -1 ","date":1616861906,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616861906,"objectID":"28581b127ae49669cdd74f1523db5edb","permalink":"/ja/post/find-majority-element-from-a-list/","publishdate":"2021-03-28T01:18:26+09:00","relpermalink":"/ja/post/find-majority-element-from-a-list/","section":"post","summary":"å•é¡Œ é…åˆ—$A$ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼$A$ã®éåŠæ•°ã‚’å ã‚ã‚‹è¦ç´ ãŒã‚ã‚Œã°ãã‚Œã‚’è¦‹ã¤ã‘ãªã•ã„ï¼ãªã‘ã‚Œã°-1ã‚’è¿”ã—ãªã•ã„ï¼ ç­”ãˆ ãƒŠã‚¤ãƒ¼ãƒ–ãªã‚„ã‚Šæ–¹ï¼šå„è¦ç´ ã®é »","tags":[],"title":"Find Majority Element From a List","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ é•·ã•$N$ã®é…åˆ—ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«$M$å€‹è¦ç´ ã‚’å–ã‚Šå‡ºã—ãŸé…åˆ—ã‚’æ±‚ã‚ã‚ˆï¼\nç­”ãˆ æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†ï¼\nimport random def pick_m_random_elements(lst, m): random.shuffle(lst) return lst[:m] Fisher-Yates ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ä¼¼ãŸæ„Ÿã˜ã§ã‚„ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ï¼\nimport random def pick_m_random_elements(lst, m): ret = lst[:m] for i in range(m, len(lst), 1): j = random.randint(0, i) if j \u0026lt; m: ret[j] = lst[i] return ret ","date":1616859018,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616859018,"objectID":"c03776bb347b1e6a5c9ecb8d5828d50c","permalink":"/ja/post/pick-up-m-elements-from-list/","publishdate":"2021-03-28T00:30:18+09:00","relpermalink":"/ja/post/pick-up-m-elements-from-list/","section":"post","summary":"å•é¡Œ é•·ã•$N$ã®é…åˆ—ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«$M$å€‹è¦ç´ ã‚’å–ã‚Šå‡ºã—ãŸé…åˆ—ã‚’æ±‚ã‚ã‚ˆï¼ ç­”ãˆ æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†ï¼ import random def pick_m_random_elements(lst, m): random.shuffle(lst) return lst[:m] Fisher-Yates ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ä¼¼ãŸæ„Ÿã˜ã§","tags":[],"title":"Pick Up M Elements From List","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ $N$æšã®ã‚«ãƒ¼ãƒ‰ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã›ã‚ˆï¼ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã®çµæœã«åã‚ŠãŒã‚ã£ã¦ã¯ãªã‚‰ãªã„ï¼\nç­”ãˆ æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†ã¨ã•ã™ãŒã«ãƒãƒ¼ãƒˆã‹ï¼\nN = int(input()) cards = [i for i in range(N)] import random random.shuffle(cards) print(cards) random.shuffleã®å†…éƒ¨çš„ã«ã¯Fisher-Yates ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒç”¨ã„ã‚‰ã‚Œã¦ã„ã‚‹ï¼\nTo shuffle an array A of N elements (indices: 0...N-1): for i in range(N - 1, 0, -1) j \u0026lt;- random_integer_between(0, i) # 0 \u0026lt;= j \u0026lt;= i swap(A[j], A[i]) Fisher-Yates ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã¯æœ«å°¾ã®è¦ç´ ã‹ã‚‰æ±ºå®šã™ã‚‹ï¼$i$ç•ªç›®ã®è¦ç´ ã‚’$0$ç•ªç›®ã‹ã‚‰$i$ç•ªç›®ã¾ã§ã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠã™ã‚‹ï¼\nè‡ªå‰ã§å®Ÿè£…ã™ã‚‹ã¨ä»¥ä¸‹ï¼\ndef fisher_yates_shuffle(lst): for i in range(len(lst) - 1, 0, -1): j = random.randint(0, i) # randint(a, b) returns a random value in a \u0026lt;= n \u0026lt;= b lst[i], lst[j] = lst[j], lst[i] Fisher-Yates ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã¯$N - 1$å›ä¹±æ•°ã‚’å¼•ãã“ã¨ã«ãªã‚‹ï¼ä¹±æ•°ã‚’ 1 åº¦ã ã‘å¼•ãã‚ˆã†ãªã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯å­˜åœ¨ã—ãªã„ã®ã ã‚ã†ã‹ï¼Ÿ\n$N$æšã®ã‚«ãƒ¼ãƒ‰ã®ã‚·ãƒ£ãƒƒãƒ•ãƒ«çµæœã®ç·æ•°ã¯$N!$é€šã‚Šã‚ã‚‹ï¼ãã“ã§ï¼Œãã‚Œã‚‰ã«$0$ã‹ã‚‰$N!-1$ã¾ã§ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä»˜ã‘ã¦ï¼Œä¸€åº¦ã ã‘å¼•ã„ãŸä¹±æ•°ãŒã¨ç­‰ã—ã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®çµæœã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã®çµæœã¨ã™ã‚‹ã¨ã„ã†ã®ã‚’è€ƒãˆã‚‹ï¼\nimport random def shuffle(lst): def factorial(n): memo = [-1] * (n + 1) memo[0] = 1 def rec(n, memo): if memo[n] != -1: return memo[n] if n == 0: return 1 return n * rec(n - 1, memo) return rec(n, memo) f = factorial(len(lst)) idx = random.randrange(f) for i in range(len(lst) - 1, -1, -1): fi = factorial(i) q = idx // fi lst.append(lst.pop(q)) idx = idx % fi ä¹±æ•°ã‚’å¼•ãå›æ•°ãŒæ¸›ã‚‰ã›ã‚‹ä»£ã‚ã‚Šã«ï¼Œéšä¹—ã‚’æ±‚ã‚ã‚‹ã¨ãã®è¨ˆç®—ã§ãƒ¡ãƒ¢ãƒªã‚’æ¶ˆè²»ã™ã‚‹ï¼\næ‰‹å…ƒã§ã®å®Ÿé¨“ã®æ„Ÿè¦šã§ã¯ï¼Œ$N$ãŒå¤§ãããªã‚‹ã¨éšä¹—ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ãŒå›°é›£ã«ãªã‚‹ã®ã§ï¼Œä½™ã‚ŠåŠ¹ç‡ã¯è‰¯ããªã„ã¨æ€ãˆã‚‹ï¼\n","date":1616854543,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616854543,"objectID":"04cc4412a30dfa1ea5fafa39f93e4d15","permalink":"/ja/post/shuffle-a-deck-of-cards/","publishdate":"2021-03-27T23:15:43+09:00","relpermalink":"/ja/post/shuffle-a-deck-of-cards/","section":"post","summary":"å•é¡Œ $N$æšã®ã‚«ãƒ¼ãƒ‰ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã›ã‚ˆï¼ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã®çµæœã«åã‚ŠãŒã‚ã£ã¦ã¯ãªã‚‰ãªã„ï¼ ç­”ãˆ æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†ã¨ã•ã™ãŒã«ãƒãƒ¼ãƒˆã‹ï¼ N = int(input()) cards = [i for i","tags":[],"title":"Shuffle a Deck of Cards","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ +ã‚’ä½¿ã‚ãšã«è¶³ã—ç®—ã‚’å®Ÿè£…ã›ã‚ˆï¼\nç­”ãˆ è¨ˆç®—æ©Ÿã¯ãƒ“ãƒƒãƒˆæ¼”ç®—ã§å››å‰‡æ¼”ç®—ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ï¼è¶³ã—ç®—ã¨ã¯ï¼Œå„æ¡ã®æ•°å­—ã®è¶³ã—ç®—ã¨ç¹°ã‚Šä¸ŠãŒã‚Šã®å‡¦ç†ã‹ã‚‰ãªã‚‹ï¼ã“ã‚Œã‚‰ã¯åˆ¥ã€…ã«è¨ˆç®—ã—ã¦æœ€å¾Œã«è¶³ã—åˆã‚ã›ã‚‹ã¨ã„ã†ã‚„ã‚Šæ–¹ã§ã‚‚æ­£ã—ã„è¶³ã—ç®—ãŒã§ãã‚‹ï¼10 é€²æ•°ã§ã‚„ã‚‹ã¨æ¬¡ã®é€šã‚Šï¼\n762 + 949 ------ 601 \u0026lt;- ç¹°ã‚Šä¸ŠãŒã‚Šã‚’ç„¡è¦–ã—ãŸå„æ¡åŒå£«ã®å’Œï¼ˆå„æ¡åŒå£«ã®å’Œ % 10ï¼‰ + 1110 \u0026lt;- ç¹°ã‚Šä¸ŠãŒã‚Šã ã‘ã‚’ä¸¦ã¹ã‚‹ ------ 1711 \u0026lt;- æ­£ã—ã„ç­”ãˆ ã“ã‚Œã‚’ 2 é€²æ•°ã§ã‚„ã‚Œã°ã„ã„ï¼ã€Œç¹°ã‚Šä¸ŠãŒã‚Šã‚’ç„¡è¦–ã—ãŸè¶³ã—ç®—ã€ã¯ãã®ã¾ã¾xorãŒå¯¾å¿œã™ã‚‹ï¼ã€Œç¹°ã‚Šä¸ŠãŒã‚Šã ã‘ä¸¦ã¹ã‚‹ã€ã¨ã„ã†ã®ã¯ï¼Œ\u0026amp;ã‚’å–ã£ã¦å·¦ 1 ã‚·ãƒ•ãƒˆã¨å¯¾å¿œã™ã‚‹ï¼\n x + y = (x XOR y) + 2 * (x AND y)\n def add(a, b): # 32 bits integer max MAX = 0x7FFFFFFF # 32 bits interger min MIN = 0x80000000 # mask to get last 32 bits mask = 0xFFFFFFFF if b == 0: # a + 0 = a return a if a \u0026lt;= MAX else ~(a ^ mask) s = a ^ b c = (a \u0026amp; b) \u0026lt;\u0026lt; 1 a = s \u0026amp; mask b = c \u0026amp; mask return add(a, b) print(add(1, -1)) ç¹°ã‚Šè¿”ã—ã§æ›¸ãã¨æ¬¡ã®é€šã‚Šï¼\ndef add(a, b): # 32 bits integer max MAX = 0x7FFFFFFF # 32 bits interger min MIN = 0x80000000 # mask to get last 32 bits mask = 0xFFFFFFFF while b: s = a ^ b c = (a \u0026amp; b) \u0026lt;\u0026lt; 1 a = s \u0026amp; mask b = c \u0026amp; mask return a if a \u0026lt;= MAX else ~(a ^ mask) print(add(1, -1)) ","date":1616847359,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616847359,"objectID":"6a8697c6b3e05e43ae2f7cfe9d1fafa5","permalink":"/ja/post/add-without-plus/","publishdate":"2021-03-27T21:15:59+09:00","relpermalink":"/ja/post/add-without-plus/","section":"post","summary":"å•é¡Œ +ã‚’ä½¿ã‚ãšã«è¶³ã—ç®—ã‚’å®Ÿè£…ã›ã‚ˆï¼ ç­”ãˆ è¨ˆç®—æ©Ÿã¯ãƒ“ãƒƒãƒˆæ¼”ç®—ã§å››å‰‡æ¼”ç®—ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ï¼è¶³ã—ç®—ã¨ã¯ï¼Œå„æ¡ã®æ•°å­—ã®è¶³ã—ç®—ã¨ç¹°ã‚Šä¸ŠãŒã‚Šã®å‡¦ç†ã‹ã‚‰ãªã‚‹ï¼","tags":[],"title":"Add Without Plus","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ–‡å­—åˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚Œã‚‹æ•°å¼ã‚’è¨ˆç®—ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ï¼\nprint(compute(\u0026#34;2*3+5/6*3+15\u0026#34;)) # =\u0026gt; 23.5 ç­”ãˆ from enum import Enum, auto class Op(Enum): ADD = auto() SUB = auto() MUL = auto() DIV = auto() NOP = auto() def priority(op): if op == Op.ADD or op == Op.SUB: return 1 elif op == Op.MUL or op == Op.DIV: return 2 else: # op == Op.NOP return 1 def compute(s): num_stack = [] op_stack = [] def parse_num(s, i): buf = \u0026#34;\u0026#34; while i \u0026lt; len(s) and s[i].isdigit(): buf += s[i] i += 1 return int(buf) def parse_op(s, i): if i \u0026lt; len(s): op_str = s[i] if op_str == \u0026#34;+\u0026#34;: return Op.ADD elif op_str == \u0026#34;-\u0026#34;: return Op.SUB elif op_str == \u0026#34;*\u0026#34;: return Op.MUL elif op_str == \u0026#34;/\u0026#34;: return Op.DIV return Op.NOP def apply(next_op, num_stack, op_stack): while 2 \u0026lt;= len(num_stack) and 1 \u0026lt;= len(op_stack): if priority(next_op) \u0026lt;= priority(op_stack[-1]): right = num_stack.pop() op = op_stack.pop() left = num_stack.pop() if op == Op.ADD: num_stack.append(left + right) elif op == Op.SUB: num_stack.append(left - right) elif op == Op.MUL: num_stack.append(left * right) elif op == Op.DIV: num_stack.append(left / right) else: # op == Op.NOP num_stack.append(right) else: break i = 0 while i \u0026lt; len(s): num = parse_num(s, i) num_stack.append(num) i += len(str(num)) if len(s) \u0026lt;= i: break next_op = parse_op(s, i) i += 1 apply(next_op, num_stack, op_stack) op_stack.append(next_op) apply(Op.NOP, num_stack, op_stack) if len(num_stack) == 1 and len(op_stack) == 0: return num_stack.pop() else: return 0 s = \u0026#34;2*3+5/6*3+15\u0026#34; print(compute(s)) # =\u0026gt; 23.5 ","date":1616845258,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616845258,"objectID":"51f0029374c9b02504207f6eb0f1e4dd","permalink":"/ja/post/simple-calculator/","publishdate":"2021-03-27T20:40:58+09:00","relpermalink":"/ja/post/simple-calculator/","section":"post","summary":"å•é¡Œ æ–‡å­—åˆ—ã¨ã—ã¦ä¸ãˆã‚‰ã‚Œã‚‹æ•°å¼ã‚’è¨ˆç®—ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ï¼ print(compute(\u0026#34;2*3+5/6*3+15\u0026#34;)) # =\u0026gt; 23.5 ç­”ãˆ from enum import Enum, auto class Op(Enum): ADD = auto() SUB = auto() MUL = auto() DIV = auto() NOP = auto() def priority(op): if op == Op.ADD or op == Op.SUB: return 1 elif","tags":[],"title":"Simple Calculator","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ é…åˆ—aï¼ŒbãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ãã‚Œãã‚Œã®é…åˆ—ã‹ã‚‰ä¸€ã¤ãšã¤è¦ç´ ã‚’é¸ã‚“ã ã¨ãï¼Œãã®å·®ã®çµ¶å¯¾å€¤ãŒæœ€å°ã¨ãªã‚‹ã‚ˆã†ãªè¦ç´ ã®ãƒšã‚¢ã¨ãã®å·®ã‚’æ±‚ã‚ã‚ˆï¼\nç­”ãˆ å…¨ã¦ã®ãƒšã‚¢ã‚’å…¨æ¢ç´¢ã—ãªãŒã‚‰æœ€å°ã®å·®ã‚’ä¸ãˆã‚‹ãƒšã‚¢ã‚’æ¢ã›ã°åŸç†çš„ã«è§£ã‘ã‚‹ï¼$O(AB)$ï¼ãŸã ã—$A$ï¼Œ$B$ã¯ãã‚Œãã‚Œã®é…åˆ—ã®é•·ã•ï¼\na = [1, 3, 15, 11, 2] b = [23, 127, 235, 19, 8] def smallest_diff(a, b): ans = (-1, -1) diff = float(\u0026#34;inf\u0026#34;) for i in range(len(a)): for j in range(len(b)): if abs(a[i] - b[j]) \u0026lt; diff: diff = abs(a[i] - b[j]) ans = (a[i], b[j]) return diff, ans print(smallest_diff(a, b)) # =\u0026gt; (3, (11, 8)) ä¸¡é…åˆ—ã‚’æ˜‡é †ã«ä¸¦ã³æ›¿ãˆã¦ã‹ã‚‰æ¢ã™ã¨åŠ¹ç‡ãŒè‰¯ããªã‚‹ï¼æ˜‡é †ã«ä¸¦ã³æ›¿ãˆã¦ã‚ã‚‹ã¨ï¼Œå°ã•ã„æ–¹ã‚’å‹•ã‹ã™ã“ã¨ã§diffãŒå°ã•ããªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰å¤§ãã„è¦ç´ ã®æ–¹ã®ä½ç½®ã‚’å›ºå®šã—ã¦å°ã•ã„è¦ç´ ã®ä½ç½®ã‚’å‹•ã‹ã™ï¼ã‚½ãƒ¼ãƒˆã™ã‚‹ã®ã«$O(A \\log A + B \\log B)$ã‹ã‹ã‚Šï¼Œæ¢ç´¢ã«$O(A + B)$ã‹ã‹ã‚‹ã®ã§ï¼Œå…¨ä½“ã¨ã—ã¦ã¯$O(A \\log A + B \\log B)$ï¼\ndef smallest_diff(a, b): a.sort() b.sort() i = 0 j = 0 ans = (-1, -1) diff = float(\u0026#34;inf\u0026#34;) while i \u0026lt; len(a) and j \u0026lt; len(b): if abs(a[i] - b[j]) \u0026lt; diff: ans = (a[i], b[j]) diff = abs(a[i] - b[j]) if a[i] \u0026lt; b[j]: i += 1 else: j += 1 return diff, ans print(smallest_diff(a, b)) # =\u0026gt; (3, (11, 8)) ","date":1616835418,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616835418,"objectID":"6bb01550578b2b8664f5a576965f4a2f","permalink":"/ja/post/smallest-difference-in-two-arrays/","publishdate":"2021-03-27T17:56:58+09:00","relpermalink":"/ja/post/smallest-difference-in-two-arrays/","section":"post","summary":"å•é¡Œ é…åˆ—aï¼ŒbãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ãã‚Œãã‚Œã®é…åˆ—ã‹ã‚‰ä¸€ã¤ãšã¤è¦ç´ ã‚’é¸ã‚“ã ã¨ãï¼Œãã®å·®ã®çµ¶å¯¾å€¤ãŒæœ€å°ã¨ãªã‚‹ã‚ˆã†ãªè¦ç´ ã®ãƒšã‚¢ã¨ãã®å·®ã‚’æ±‚ã‚ã‚ˆï¼ ç­”ãˆ å…¨ã¦","tags":[],"title":"Smallest Difference in Two Arrays","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ $n$ã®éšä¹—ã®æœ«å°¾ã«ã¯$0$ãŒã„ãã¤ä¸¦ã‚“ã§ã„ã‚‹ã‹ï¼æ±‚ã‚ã‚ˆï¼\nç­”ãˆ ã‚ˆãã‚ã‚‹ä¸­å­¦å—é¨“å•é¡Œï¼ç´ å› æ•°åˆ†è§£ã—ãŸã¨ãã«$2$ã‚ˆã‚Š$5$ã®ã»ã†ãŒæ•°ãŒå¤šã„ã®ã§ï¼Œ$5$ã®å€‹æ•°ã‚’æ•°ãˆã‚Œã°è‰¯ã„ï¼\ndef factorial_zeros(n): def factor_of_5(n): count = 0 while n % 5 == 0: count += 1 n = n / 5 return count ans = 0 for i in range(1, n + 1): ans += factor_of_5(i) return ans $5$ã®ç´¯ä¹—ã®å€æ•°ãŒãã‚Œãã‚Œä½•å€‹ã‚ã‚‹ã‹ã‚’è¨ˆç®—ã—ã¦è¶³ã—ä¸Šã’ã¦ã‚‚ã„ã„ï¼\ndef factorial_zeros(n): ans = 0 i = 5 while i \u0026lt;= n: ans += n // i i *= 5 return ans éšæ®µã‚’ç¸¦ã«è¦‹ã¦ã‚‹ã‹ï¼Œæ¨ªã«è¦‹ã¦ã‚‹ã‹ã®é•ã„ï¼\n","date":1616834523,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616834523,"objectID":"f3e72ab9ced22510b83986aa34d7342f","permalink":"/ja/post/how-many-zeros-in-suffix-of-factorial/","publishdate":"2021-03-27T17:42:03+09:00","relpermalink":"/ja/post/how-many-zeros-in-suffix-of-factorial/","section":"post","summary":"å•é¡Œ $n$ã®éšä¹—ã®æœ«å°¾ã«ã¯$0$ãŒã„ãã¤ä¸¦ã‚“ã§ã„ã‚‹ã‹ï¼æ±‚ã‚ã‚ˆï¼ ç­”ãˆ ã‚ˆãã‚ã‚‹ä¸­å­¦å—é¨“å•é¡Œï¼ç´ å› æ•°åˆ†è§£ã—ãŸã¨ãã«$2$ã‚ˆã‚Š$5$ã®ã»ã†ãŒæ•°ãŒå¤šã„","tags":[],"title":"How Many Zeros in Suffix of Factorial","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ä¸€æ™‚å¤‰æ•°ã‚’ä½¿ã‚ãšã«æ•´æ•°aã¨bã‚’äº¤æ›ã›ã‚ˆï¼\nç­”ãˆ a = 10 b = 3 print(a, b) # =\u0026gt; 10 3 a = a - b b = a + b # (1) a = b - a # (2) print(a, b) # =\u0026gt; 3, 10 aï¼Œbã‚’äº¤æ›å‰ã®æ•°å­—ã¨ã™ã‚‹ã¨ï¼Œ\n (1)ï¼š(a - b) + b = a (2)ï¼ša - (a - b) = b  xorã‚’ä½¿ã†æ–¹ãŒæ±ç”¨æ€§ã¯é«˜ãã†ï¼a xor a = 0ï¼Œ0 xor a = aã¨ã„ã†æ€§è³ªã‚’åˆ©ç”¨ã™ã‚‹ï¼\na = 10 b = 3 print(a, b) # =\u0026gt; 10 3 a = a ^ b b = a ^ b # (1) a = a ^ b # (2) print(a, b) # =\u0026gt; 3, 10 aï¼Œbã‚’äº¤æ›å‰ã®æ•°å­—ã¨ã™ã‚‹ã¨ï¼Œ\n (1)ï¼š(a xor b) xor b = a xor (b xor b) = a xor 0 = a (2)ï¼š(a xor b) xor a = b xor (a xor a) = b xor 0 = b  ","date":1616833051,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616833051,"objectID":"14380f7806db8087874d07ff97a98bd9","permalink":"/ja/post/swap-two-intergers-without-additional-mrmory/","publishdate":"2021-03-27T17:17:31+09:00","relpermalink":"/ja/post/swap-two-intergers-without-additional-mrmory/","section":"post","summary":"å•é¡Œ ä¸€æ™‚å¤‰æ•°ã‚’ä½¿ã‚ãšã«æ•´æ•°aã¨bã‚’äº¤æ›ã›ã‚ˆï¼ ç­”ãˆ a = 10 b = 3 print(a, b) # =\u0026gt; 10 3 a = a - b b = a + b # (1) a = b - a # (2) print(a, b) # =\u0026gt; 3, 10 aï¼Œbã‚’äº¤æ›å‰ã®æ•°","tags":[],"title":"Swap Two Intergers Without Additional Mrmory","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ Listã¿ãŸã„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ Listyã‚’è€ƒãˆã‚‹ï¼Listyã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹ï¼\nclass Listy: def __init__(self, lst): lst.sort() self.lst = lst def at(self, idx): if idx \u0026lt; len(lst): return self.lst[idx] else: return -1 åŸºæœ¬çš„ã«Listyã¯è¦ç´ ã‚’æ˜‡é †ã«æ ¼ç´ã—ã¦ã„ã‚‹Listã®ã‚ˆã†ãªã‚‚ã®ã§ã‚ã‚‹ï¼ã“ã“ã§Listyã«ã¯ãã®é•·ã•ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”¨æ„ã•ã‚Œã¦ã„ãªã„ï¼ã¤ã¾ã‚ŠListyã®é•·ã•ã‚’ç›´æ¥çŸ¥ã‚‹ã“ã¨ã¯ã§ããªã„ï¼ä¸€æ–¹ã§ï¼ŒListy.at(idx)ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”¨æ„ã•ã‚Œã¦ãŠã‚Šï¼Œidxã®ä½ç½®ã«å­˜åœ¨ã™ã‚‹è¦ç´ ã‚’$O(1)$ã§è¿”ã™ã“ã¨ãŒã§ãã‚‹ï¼ã‚‚ã—idxãŒListyã®ç¯„å›²ã‚’è¶…ãˆã‚‹ã¨-1ã‚’è¿”ã™ï¼\nã‚ã‚‹Listyã¨keyã‚’ä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼ŒkeyãŒListyå†…ã«å­˜åœ¨ã™ã‚‹ã‹ã‚’åˆ¤å®šã—ï¼Œå­˜åœ¨ã™ã‚‹ãªã‚‰ãã®ä½ç½®ï¼ˆ0-ã‚ªãƒªã‚¸ãƒ³ï¼‰ã‚’è¿”ã™é–¢æ•°ã‚’æ›¸ã‘ï¼\nç­”ãˆ ã€Œè¦ç´ ãŒæ˜‡é †ã«ä¸¦ã‚“ã§ã„ã‚‹ã€ã®ã§äºŒåˆ†æ¢ç´¢ã‚’ä½¿ã„ãŸã„ã¨ã“ã‚ï¼Listyã®å…¨é•·ã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ããªã„ã®ã§[2^i, 2^(i + 1))ã§æ¢ç´¢ç¯„å›²ã‚’åºƒã’ãªãŒã‚‰äºŒåˆ†æ¢ç´¢ã™ã‚‹ï¼\nlisty = Listy([0, 4, 2, 5, 7, 3, 9 ,13, 15]) def search(listy, key): # listyã®[left:right)ã‹ã‚‰è¦ç´ ãŒkeyä»¥ä¸Šã¨ãªã‚‹æœ€å°ã®ä½ç½®ã‚’äºŒåˆ†æ¢ç´¢ def binary_search(listy, key, left, right): ng = left - 1 ok = right def is_ok(mid): return key \u0026lt;= listy.at(mid) while 1 \u0026lt; abs(ok - ng): mid = (ok + ng) // 2 if is_ok(mid): ok = mid else: ng = mid # okã®ä½ç½®ã«ã‚ã‚‹è¦ç´ ãŒkeyã¨ç­‰ã—ã‘ã‚Œã°ç™ºè¦‹æˆåŠŸ found = listy.at(ok) == key return found, ok right = 1 while listy.at(right) != -1 and listy.at(right) \u0026lt; key: right *= 2 left = right // 2 return binary_search(listy, key, left, right) print(search(listy, -1)) # =\u0026gt; (False, 0) print(search(listy, 0)) # =\u0026gt; (True, 0) print(search(listy, 2)) # =\u0026gt; (True, 1) print(search(listy, 3)) # =\u0026gt; (True, 2) print(search(listy, 13)) # =\u0026gt; (True, 7) print(search(listy, 15)) # =\u0026gt; (True, 8) print(search(listy, 16)) # =\u0026gt; (False, 16) ","date":1616825179,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616825179,"objectID":"54dcaf3b852db6e3e4be055da4938704","permalink":"/ja/post/find-key-in-listy/","publishdate":"2021-03-27T15:06:19+09:00","relpermalink":"/ja/post/find-key-in-listy/","section":"post","summary":"å•é¡Œ Listã¿ãŸã„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ Listyã‚’è€ƒãˆã‚‹ï¼Listyã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹ï¼ class Listy: def __init__(self, lst): lst.sort() self.lst = lst def at(self, idx): if idx \u0026lt; len(lst): return self.lst[idx] else: return -1 åŸºæœ¬çš„ã«Lis","tags":[],"title":"Find Key in Listy","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ å…±ã«æ˜‡é †ã«æ•´åˆ—ã•ã‚ŒãŸé…åˆ—aã¨é…åˆ—bãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼aã«ã¯bã®è¦ç´ ã‚’å…¨ã¦æ ¼ç´ã™ã‚‹ã»ã©ã®ãƒãƒƒãƒ•ã‚¡ãŒå­˜åœ¨ã™ã‚‹ï¼ã“ã®ã¨ãï¼Œè¿½åŠ ã®ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã›ãšã«aã¨bã‚’æ˜‡é †ã«æ•´åˆ—ã•ã‚ŒãŸçŠ¶æ…‹ã«ãƒãƒ¼ã‚¸ã›ã‚ˆï¼\nç­”ãˆ å¾Œã‚ã‹ã‚‰ã‚„ã‚‹ï¼\na = [1, 3, 4, 8, 10, -1, -1, -1, -1] b = [2, 7, 11, 14] def sorted_merge(a, b, tail_a, tail_b): idx_a = tail_a - 1 idx_b = tail_b - 1 idx_merged = tail_a + tail_b - 1 while 0 \u0026lt;= idx_b: if 0 \u0026lt;= idx_a and b[idx_b] \u0026lt; a[idx_a]: a[idx_merged] = a[idx_a] idx_a -= 1 else: a[idx_merged] = b[idx_b] idx_b -= 1 idx_merged -= 1 sorted_merge(a, b, 5, 4) print(a) # =\u0026gt; [1, 2, 3, 4, 7, 8, 10, 11, 14] ","date":1616821318,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616821318,"objectID":"250dc9ebefb7c7972f907d6f1af85c6a","permalink":"/ja/post/merge-two-sorted-array-in-place/","publishdate":"2021-03-27T14:01:58+09:00","relpermalink":"/ja/post/merge-two-sorted-array-in-place/","section":"post","summary":"å•é¡Œ å…±ã«æ˜‡é †ã«æ•´åˆ—ã•ã‚ŒãŸé…åˆ—aã¨é…åˆ—bãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼aã«ã¯bã®è¦ç´ ã‚’å…¨ã¦æ ¼ç´ã™ã‚‹ã»ã©ã®ãƒãƒƒãƒ•ã‚¡ãŒå­˜åœ¨ã™ã‚‹ï¼ã“ã®ã¨ãï¼Œè¿½åŠ ã®ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã›ãšã«","tags":[],"title":"Merge Two Sorted Array in Place","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ‰‹å…ƒã«$1$å††ç¡¬è²¨ï¼Œ$5$å††ç¡¬è²¨ï¼Œ$10$å††ç¡¬è²¨ï¼Œ$25$å††ç¡¬è²¨ãŒç„¡é™ã«å­˜åœ¨ã™ã‚‹ï¼$n$å††æ”¯æ‰•ã†ã¨ãã®ï¼Œç¡¬è²¨ã®å‡ºã—æ–¹ã®ç·æ•°ã¯ã„ãã‚‰ã‹ï¼\nç­”ãˆ coins = [25, 10, 5, 1] def make_change(n, coins): # remainå††ã‚’coins[pos:]ã‚’ä½¿ã£ã¦æ”¯æ‰•ã†ã¨ãã®æ”¯æ‰•ã„æ–¹ã®ç·æ•° def rec(coins, pos, remain): if pos == len(coins) - 1: return 1 # remainå††ã‚’1å††ç¡¬è²¨ã§æ”¯æ‰•ã†æ–¹æ³•ã¯ã€Œremainæšã®1å††ç¡¬è²¨ã€ã®1é€šã‚Š ways = 0 i = 0 while i * coins[pos] \u0026lt;= remain: ways += rec(coins, pos + 1, remain - i * coins[pos]) i += 1 return ways return rec(coins, 0, n) å®Ÿéš›ã®æ”¯æ‰•ã„æ–¹ã‚’ä¿å­˜ã—ã¦ãŠãã“ã¨ã‚‚ã§ãã‚‹ï¼\ncoins = [25, 10, 5, 1] def make_change(n, coins): payments = [] # remainå††ã‚’coins[pos:]ã‚’ä½¿ã£ã¦æ”¯æ‰•ã†ã¨ãã®æ”¯æ‰•ã„æ–¹ã®ç·æ•° def rec(remain, pos, sofar): if pos == len(coins) - 1: payments.append(sofar + [1 for _ in range(remain)]) return 1 # remainå††ã‚’1å††ç¡¬è²¨ã§æ”¯æ‰•ã†æ–¹æ³•ã¯ã€Œremainæšã®1å††ç¡¬è²¨ã€ã®1é€šã‚Š ways = 0 i = 0 while i * coins[pos] \u0026lt;= remain: ways += rec(remain - i * coins[pos], pos + 1, sofar + [coins[pos] for _ in range(i)]) i += 1 return ways ans = rec(n, 0, []) return ans, payments ways, payments = make_change(100, coins) print(\u0026#34;ways:\u0026#34;, ways) for i, payment in enumerate(payments): print(\u0026#34;{}: coin usage: {}, payment: {}\u0026#34;.format(i, len(payment), payment)) rec()ã®æ±‚ã‚ã‚‹ã‚‚ã®ã‚’ã€Œremainå††ã‚’coins[:pos]ã‚’ä½¿ã£ã¦æ”¯æ‰•ã†ã¨ãã®æ”¯æ‰•ã„æ–¹ã®ç·æ•°ã€ã¨ã—ãŸæ–¹ãŒè‡ªç„¶ï¼\ndef make_change(n, coins): # remainå††ã‚’coins[:pos+1]ã‚’ä½¿ã£ã¦æ”¯æ‰•ã†ã¨ãã®æ”¯æ‰•ã„æ–¹ã®ç·æ•° def rec(remain, pos): if pos == 0: return 1 ways = 0 i = 0 while i * coins[pos] \u0026lt;= remain: ways += rec(remain - i * coins[pos], pos - 1) i += 1 return ways coins.sort() # coins = [1, ...] return rec(n, len(coins) - 1) TODOï¼šãƒ¡ãƒ¢åŒ–\n","date":1616813821,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616813821,"objectID":"8cb4740f699e990b38869e6f217b92b0","permalink":"/ja/post/coin-change/","publishdate":"2021-03-27T11:57:01+09:00","relpermalink":"/ja/post/coin-change/","section":"post","summary":"å•é¡Œ æ‰‹å…ƒã«$1$å††ç¡¬è²¨ï¼Œ$5$å††ç¡¬è²¨ï¼Œ$10$å††ç¡¬è²¨ï¼Œ$25$å††ç¡¬è²¨ãŒç„¡é™ã«å­˜åœ¨ã™ã‚‹ï¼$n$å††æ”¯æ‰•ã†ã¨ãã®ï¼Œç¡¬è²¨ã®å‡ºã—æ–¹ã®ç·æ•°ã¯ã„ãã‚‰ã‹ï¼ ç­”","tags":[],"title":"Coin Change","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ $n$å€‹ã®()ã‚’ï¼Œå…¨ã¦ã®é–‹ãã‚«ãƒƒã‚³ã¨é–‰ã˜ã‚«ãƒƒã‚³ã®å¯¾å¿œãŒæ­£ã—ã„ã‚ˆã†ã«ä¸¦ã¹ãŸã¨ãã®å…¨é€šã‚Šã‚’æ±‚ã‚ã‚ˆï¼\nç­”ãˆ def valid_parentheses(n): ret = [] def rec(left, right, sofar): if left == 0 and right == 0: ret.append(sofar) return if 0 \u0026lt; left: rec(left - 1, right, sofar + \u0026#34;(\u0026#34;) if left \u0026lt; right: rec(left, right - 1, sofar + \u0026#34;)\u0026#34;) rec(n, n, \u0026#34;\u0026#34;) return ret print(valid_parentheses(3)) # =\u0026gt; [\u0026#39;((()))\u0026#39;, \u0026#39;(()())\u0026#39;, \u0026#39;(())()\u0026#39;, \u0026#39;()(())\u0026#39;, \u0026#39;()()()\u0026#39;] ","date":1616813465,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616813465,"objectID":"f8543b124a997a9e2ede3523719e27c3","permalink":"/ja/post/valid-parentheses/","publishdate":"2021-03-27T11:51:05+09:00","relpermalink":"/ja/post/valid-parentheses/","section":"post","summary":"å•é¡Œ $n$å€‹ã®()ã‚’ï¼Œå…¨ã¦ã®é–‹ãã‚«ãƒƒã‚³ã¨é–‰ã˜ã‚«ãƒƒã‚³ã®å¯¾å¿œãŒæ­£ã—ã„ã‚ˆã†ã«ä¸¦ã¹ãŸã¨ãã®å…¨é€šã‚Šã‚’æ±‚ã‚ã‚ˆï¼ ç­”ãˆ def valid_parentheses(n): ret = [] def rec(left, right, sofar): if left == 0 and right == 0: ret.append(sofar) return","tags":[],"title":"Valid Parentheses","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ *ã‚’ä½¿ã‚ãšã«æ›ã‘ç®—ã‚’å®Ÿè£…ã›ã‚ˆï¼\nç­”ãˆ def product(a, b): smaller = a if a \u0026lt; b else b larger = b if a \u0026lt; b else a def helper(smaller, larger): # sum up `larger` in `smaller` times if smaller == 0: # 0 x larger = 0 return 0 if smaller == 1: # 1 x larger = larger return larger s = smaller \u0026gt;\u0026gt; 1 half = helper(s, larger) if smaller \u0026amp; 1: return half + half + larger else: return half + half return helper(smaller, larger) ãƒ¡ãƒ¢åŒ–å†å¸°ã§ã‚‚ã£ã¨åŠ¹ç‡è‰¯ãã§ãã‚‹ï¼\ndef product(a, b): smaller = a if a \u0026lt; b else b larger = b if a \u0026lt; b else a memo = [-1] * (smaller + 1) def helper(smaller, larger, memo): if smaller == 0: return 0 if smaller == 1: return larger if memo[smaller] != -1: return memo[smaller] s = smaller \u0026gt;\u0026gt; 1 half = helper(s, larger, memo) ret = 0 if smaller \u0026amp; 1: ret = half + half + larger else: ret = half + half memo[smaller] = ret return ret return helper(smaller, larger, memo) ","date":1616772863,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616772863,"objectID":"16bed3c941f6fa77ac07a0f4a405cbff","permalink":"/ja/post/recursive-multiply/","publishdate":"2021-03-27T00:34:23+09:00","relpermalink":"/ja/post/recursive-multiply/","section":"post","summary":"å•é¡Œ *ã‚’ä½¿ã‚ãšã«æ›ã‘ç®—ã‚’å®Ÿè£…ã›ã‚ˆï¼ ç­”ãˆ def product(a, b): smaller = a if a \u0026lt; b else b larger = b if a \u0026lt; b else a def helper(smaller, larger): # sum up `larger` in `smaller` times if smaller == 0: # 0 x larger = 0 return 0 if smaller == 1: # 1 x larger","tags":[],"title":"Recursive Multiply","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ã™ã¹ã¦ã®è¦ç´ ãŒäº’ã„ã«ç•°ãªã‚Šã‹ã¤æ˜‡é †ã«æ•´åˆ—ã•ã‚ŒãŸé…åˆ—$a$ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã“ã§\n$$ a_i = i $$\nã¤ã¾ã‚Šï¼Œé…åˆ—$a$ã®$i$ç•ªç›®ã®è¦ç´ ãŒ$i$ã§ã‚ã‚‹ã‚ˆã†ãª$i$ã‚’ magic index ã¨å‘¼ã¶ã“ã¨ã«ã™ã‚‹ï¼\né…åˆ—ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œmagic index ã‚’æ±‚ã‚ã‚ˆï¼\nç­”ãˆ ã™ã¹ã¦ã®è¦ç´ ã‚’ä¸€ã¤ãšã¤è¦‹ãªãŒã‚‰ magic index ã§ã‚ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã§æ±‚ã¾ã‚‹ï¼$O(n)$\ndef get_magic_index(lst): ret = [] for idx, ele in enumerate(lst): if ele == idx: ret.append(idx) return ret ã ãŒï¼Œã“ã‚Œã§ã¯ã€Œä¸ãˆã‚‰ã‚Œã‚‹é…åˆ—ãŒæ˜‡é †ã«ãªã£ã¦ã„ã‚‹ã€ã¨ã„ã†æ¡ä»¶ã‚’ä½¿ãˆã¦ã„ãªã„ï¼\nã€Œæ˜‡é †ã€ã¨æ¥ãŸã‚‰ï¼ŒäºŒåˆ†æ¢ç´¢ï¼$O(\\log n)$\ndef get_magic_index(lst): def rec(lst, left, right): if right \u0026lt; left: return -1 mid = (left + right) // 2 if lst[mid] == mid: return mid if lst[mid] \u0026lt; mid: return rec(lst, mid + 1, right) if mid \u0026lt; lst[mid]: return rec(lst, left, mid - 1) return rec(lst, 0, len(lst) - 1) ","date":1616766549,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616766549,"objectID":"0ae980ace738bac000014c4fbafbc189","permalink":"/ja/post/magic-index/","publishdate":"2021-03-26T22:49:09+09:00","relpermalink":"/ja/post/magic-index/","section":"post","summary":"å•é¡Œ ã™ã¹ã¦ã®è¦ç´ ãŒäº’ã„ã«ç•°ãªã‚Šã‹ã¤æ˜‡é †ã«æ•´åˆ—ã•ã‚ŒãŸé…åˆ—$a$ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã“ã§ $$ a_i = i $$ ã¤ã¾ã‚Šï¼Œé…åˆ—$a$ã®$i$ç•ªç›®ã®è¦ç´ ãŒ$i$ã§ã‚ã‚‹","tags":[],"title":"Magic Index","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ $n$æ®µã®éšæ®µãŒã‚ã‚‹ï¼ãŠã˜ã•ã‚“ã¯ç­‹ãƒˆãƒ¬ã«ãƒãƒã£ã¦ãŠã‚Šï¼Œ$i$æ®µé£›ã°ã—ãŒå¥½ãã ï¼ç¾çŠ¶ãŠã˜ã•ã‚“ã¯$i = 1, 2, 3$ã®$i$æ®µé£›ã°ã—ãŒã§ãã‚‹ï¼ãŠã˜ã•ã‚“ãŒ$n$æ®µã®éšæ®µã‚’ã®ã¼ã‚‹æ–¹æ³•ã¯å…¨éƒ¨ã§ä½•é€šã‚Šã‚ã‚‹ã‹ï¼\nç­”ãˆ def solve(n): if n \u0026lt; 0: return 0 if n == 0: return 1 return solve(n - 1) + solve(n - 2) + solve(n - 3) ãƒ¡ãƒ¢åŒ–å†å¸°\ndef solve(n, memo): if n \u0026lt; 0: return 0 if n == 0: return 1 if memo[n] != -1: return memo[n] ret = solve(n - 1, memo) + solve(n - 2, memo) + solve(n - 3, memo) memo[n] = ret return ret ","date":1616764218,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616764218,"objectID":"3e19f874f4725b18fdb451c30dfef448","permalink":"/ja/post/how-many-ways-to-run-up-the-stairs/","publishdate":"2021-03-26T22:10:18+09:00","relpermalink":"/ja/post/how-many-ways-to-run-up-the-stairs/","section":"post","summary":"å•é¡Œ $n$æ®µã®éšæ®µãŒã‚ã‚‹ï¼ãŠã˜ã•ã‚“ã¯ç­‹ãƒˆãƒ¬ã«ãƒãƒã£ã¦ãŠã‚Šï¼Œ$i$æ®µé£›ã°ã—ãŒå¥½ãã ï¼ç¾çŠ¶ãŠã˜ã•ã‚“ã¯$i = 1, 2, 3$ã®$i$æ®µé£›ã°ã—ãŒã§ãã‚‹ï¼ãŠã˜","tags":[],"title":"How Many Ways to Run Up the Stairs?","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ•´æ•°$A$ã‚’æ•´æ•°$B$ã«å¤‰æ›ã™ã‚‹ã®ã«å¿…è¦ãªãƒ“ãƒƒãƒˆåè»¢ã®å›æ•°ã‚’è¨ˆç®—ã›ã‚ˆï¼\nç­”ãˆ def count(a, b): ret = 0 c = a ^ b # ç•°ãªã‚‹æ¡ã ã‘1ãŒç«‹ã¤ while c != 0: ret += 1 if c \u0026amp; 1 else 0 c = c \u0026gt;\u0026gt; 1 return ret ã“ã†ã‚‚æ›¸ã‘ã‚‹ï¼\ndef count(a, b): ret = 0 c = a ^ b while c != 0: ret += 1 c = c \u0026amp; (c - 1) # å³ç«¯ã®1ãŒ0ã«ãªã‚‹ return ret ","date":1616753682,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616753682,"objectID":"f0bb68c2d1ed64f40ce2ef12445d52ad","permalink":"/ja/post/convert-a-number-to-a-number/","publishdate":"2021-03-26T19:14:42+09:00","relpermalink":"/ja/post/convert-a-number-to-a-number/","section":"post","summary":"å•é¡Œ æ•´æ•°$A$ã‚’æ•´æ•°$B$ã«å¤‰æ›ã™ã‚‹ã®ã«å¿…è¦ãªãƒ“ãƒƒãƒˆåè»¢ã®å›æ•°ã‚’è¨ˆç®—ã›ã‚ˆï¼ ç­”ãˆ def count(a, b): ret = 0 c = a ^ b # ç•°ãªã‚‹æ¡ã ã‘1ãŒç«‹ã¤ while c != 0: ret += 1 if c","tags":[],"title":"Convert a Number to a Number","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ãƒ“ãƒƒãƒˆåˆ—ã®æŒ‡å®šã•ã‚ŒãŸä½ç½®ã«åˆ¥ã®ãƒ“ãƒƒãƒˆåˆ—ã‚’æŒ¿å…¥ã›ã‚ˆï¼\nA = 100000000 ã® 2æ¡ç›®ã‹ã‚‰6æ¡ç›®ã«B = 101101ã‚’æŒ¿å…¥ -\u0026gt; 101011010 ç­”ãˆ # aã®iæ¡ç›®ã‹ã‚‰jæ¡ç›®ã«bã‚’æŒ¿å…¥ def insert(a, b, i, j): ones = ~0 # å…¨éƒ¨1 left = ones \u0026lt;\u0026lt; (j + 1) right = (1 \u0026lt;\u0026lt; i) - 1 mask = left | right a \u0026amp;= mask b \u0026lt;\u0026lt;= i return a | b (1 \u0026lt;\u0026lt; i) - 1ï¼š1ãŒ$i$å€‹å³ç«¯ã«ä¸¦ã¶\n","date":1616753171,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616753171,"objectID":"40efc95fa2c8407a0c0180f5d484f27c","permalink":"/ja/post/insert-a-number-in-a-number/","publishdate":"2021-03-26T19:06:11+09:00","relpermalink":"/ja/post/insert-a-number-in-a-number/","section":"post","summary":"å•é¡Œ ãƒ“ãƒƒãƒˆåˆ—ã®æŒ‡å®šã•ã‚ŒãŸä½ç½®ã«åˆ¥ã®ãƒ“ãƒƒãƒˆåˆ—ã‚’æŒ¿å…¥ã›ã‚ˆï¼ A = 100000000 ã® 2æ¡ç›®ã‹ã‚‰6æ¡ç›®ã«B = 101101ã‚’æŒ¿å…¥ -\u0026gt; 101011010 ç­”ãˆ # aã®iæ¡ç›®ã‹ã‚‰jæ¡ç›®ã«bã‚’æŒ¿","tags":[],"title":"Insert a Number in a Number","type":"post"},{"authors":[],"categories":[],"content":"éƒ¨åˆ†å’Œå•é¡Œ é…åˆ—lstã¨æ•´æ•°WãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œlstã®éƒ¨åˆ†é…åˆ—ã®å’ŒãŒWã«ãªã‚‹ã“ã¨ã‚ˆã†ãªéƒ¨åˆ†é…åˆ—ã¯å­˜åœ¨ã™ã‚‹ã‹ï¼\nè§£æ³• å†å¸°ã§è§£ãï¼\ndef check(lst, W): def rec(pos, sofar): if pos == len(lst): return sofar == W if rec(pos + 1, sofar + lst[pos]): return True if rec(pos + 1, sofar): return True return False return rec(0, 0) def check(lst, W): def rec(pos, remain): if pos == len(lst): return remain == 0 if rec(pos + 1, remain - lst[pos]): return True if rec(pos + 1, remain): return True return False return rec(0, W) def check(lst, W): memo = [[-1 for _ in range(len(lst))] for _ in range(W)] def rec(pos, remain): if memo[remain][pos] != -1: return memo[remain][pos] ret = 0 if pos == 0: return remain == 0 if rec(pos - 1, remain - lst[pos]): ret = 1 if rec(pos - 1, remain): ret = 1 memo[remain][pos] = ret return ret return rec(N, W) ãƒ“ãƒƒãƒˆå…¨æ¢ç´¢\ndef check(lst, W): for i in range(1 \u0026lt;\u0026lt; len(lst)): sofar = 0 for j in range(len(lst)): if i \u0026amp; (1 \u0026lt;\u0026lt; j): sofar += lst[j] if sofar == W: return True return False ","date":1616686897,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616686897,"objectID":"41f207d688c7f164a2f60a05b1bed4c9","permalink":"/ja/post/sub-of-subarray/","publishdate":"2021-03-26T00:41:37+09:00","relpermalink":"/ja/post/sub-of-subarray/","section":"post","summary":"éƒ¨åˆ†å’Œå•é¡Œ é…åˆ—lstã¨æ•´æ•°WãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œlstã®éƒ¨åˆ†é…åˆ—ã®å’ŒãŒWã«ãªã‚‹ã“ã¨ã‚ˆã†ãªéƒ¨åˆ†é…åˆ—ã¯å­˜åœ¨ã™ã‚‹ã‹ï¼ è§£æ³• å†å¸°ã§è§£ãï¼ def check(lst, W): def rec(pos, sofar): if pos","tags":[],"title":"Sub of Subarray","type":"post"},{"authors":[],"categories":[],"content":"Longest Increasing Subarrayï¼šæœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—å•é¡Œ é•·ã•$N$ã®æ•°åˆ—ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®ã†ã¡ã„ãã¤ã‹ã®é …ã‚’é †ç•ªã‚’å¤‰ãˆãšã«å–ã‚Šå‡ºã—ã¦éƒ¨åˆ†åˆ—ã‚’ä½œã‚‹ï¼ã“ã‚Œã‚‰éƒ¨åˆ†åˆ—ã®ã†ã¡ï¼Œãã‚ŒãŒå¢—åŠ åˆ—ã§ã‚ã‚‹ã‚ˆã†ãªã‚‚ã®ã®ä¸­ã§ï¼Œæœ€å¤§ã®é•·ã•ã‚’æ±‚ã‚ã‚ˆï¼\n[3, 5, 2, 6, 7, 1, 4] -\u0026gt; [3, 5, 6, 7] (len = 4) è§£æ³• $O(2^N \\times N)$ãªåŠ›æŠ€ è€ƒãˆã‚‰ã‚Œã‚‹éƒ¨åˆ†åˆ—ã‚’å…¨ã¦åˆ—æŒ™ã—ï¼Œãã‚Œãã‚ŒãŒå¢—åŠ åˆ—ã§ã‚ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ï¼éƒ¨åˆ†åˆ—ã®åˆ—æŒ™ã«$O(2^N)$ï¼Œã‚ã‚‹éƒ¨åˆ†åˆ—ãŒå¢—åŠ åˆ—ã§ã‚ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ã®ã«$O(N)$ã‹ã‹ã‚‹ï¼\nå†å¸°ã§å…¨æ¢ç´¢ï¼\nlst = [3, 5, 2, 6, 7, 1, 4] # =\u0026gt; 4 def LIS(lst): subs = [] def rec(pos, sofar): if pos == len(lst): subs.append(sofar) return rec(pos + 1, sofar) rec(pos + 1, sofar + [lst[pos]]) rec(0, []) def is_increasing(lst): for i in range(len(lst) - 1): if lst[i] \u0026gt; lst[i + 1]: return False return True ans = 0 for sub in subs: if is_increasing(sub): ans = max(ans, len(sub)) return ans print(LIS(lst)) ãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ï¼\nlst = [3, 5, 2, 6, 7, 1, 4] # =\u0026gt; 4 def LIS(lst): ans = 0 def is_increasing(lst): for i in range(len(lst) - 1): if lst[i] \u0026gt; lst[i + 1]: return False return True for i in range(1 \u0026lt;\u0026lt; len(lst)): sub = [] for j in range(len(lst)): if i \u0026amp; (1 \u0026lt;\u0026lt; j): sub.append(lst[j]) if is_increasing(sub): ans = max(ans, len(sub)) return ans print(LIS(lst)) $O(N^2)$ã§è§£ã DP dp[i]ã‚’ã€Œlst[i]ãŒå³ç«¯ã¨ãªã‚‹ã‚ˆã†ãªå¢—åŠ éƒ¨åˆ†åˆ—ã®æœ€å¤§ã®é•·ã•ã€ã¨ã™ã‚‹ã¨ï¼Œdp[i + 1]ã¯ã€Œj \u0026lt; i + 1ã‹ã¤lst[j] \u0026lt;= lst[i + 1]ãªjã«ã¤ã„ã¦ã®dp[j]ã®æœ€å¤§å€¤ + 1ã€ã¨æ›´æ–°ã§ãã‚‹ï¼\nlst = [3, 5, 2, 6, 7, 1, 4] # =\u0026gt; 4 def LIS(lst): # dp[i]: lst[i]ãŒå³ç«¯ã¨ãªã‚‹ã‚ˆã†ãªå¢—åŠ éƒ¨åˆ†åˆ—ã®æœ€å¤§ã®é•·ã• dp = [1 for _ in range(len(lst))] for i in range(len(lst)): for j in range(i): if lst[j] \u0026lt;= lst[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) print(LIS(lst)) $O(N^2)$ã§è§£ã DP ä¸€ã¤å‰ã®ã¨æ·»å­—ã‚’é€†è»¢ã•ã›ã‚‹ï¼ã¤ã¾ã‚Šï¼Œdp[i]ã‚’ã€Œé•·ã•i + 1ã®å¢—åŠ éƒ¨åˆ†åˆ—ã®ã†ã¡ã®æœ€å°ã®å³ç«¯ã€ã¨ã™ã‚‹ï¼dp[i+1]ã¯dp[i]ã‚ˆã‚Šå¤§ãã„æœ€å°ã®lstè¦ç´ ï¼\nlst = [3, 5, 2, 6, 7, 1, 4] # =\u0026gt; 4 def LIS(lst): # dp[i]: é•·ã•ãŒi+1ã®å¢—åŠ éƒ¨åˆ†åˆ—ã®æœ€å°ã®å³ç«¯ INF = float(\u0026#39;inf\u0026#39;) dp = [INF for _ in range(len(lst))] for i in range(len(lst)): for j in range(len(dp)): if j == 0 or dp[j - 1] \u0026lt; lst[i]: dp[j] = min(dp[j], lst[i]) ans = 0 for i in range(len(dp)): if dp[i] \u0026lt; INF: ans = i ans += 1 return ans print(LIS(lst)) $O(N \\log N)$ã§è§£ã DP dp[j]ã”ã¨ã«ãã“ã«å…¥ã‚Œã‚‹ã¹ãlstè¦ç´ ã‚’æ±ºã‚ã‚‹ã®ã§ãªãã¦ï¼Œlstè¦ç´ ã”ã¨ã«dpã®ã©ã“ã«å…¥ã‚Œã‚‹ã¹ããªã®ã‹ã‚’äºŒåˆ†æ¢ç´¢ã§è¨ˆç®—ã™ã‚‹ï¼\nlst = [3, 5, 2, 6, 7, 1, 4] # =\u0026gt; 4 from bisect import bisect_left def LIS(lst): # dp[i]: é•·ã•ãŒi+1ã®å¢—åŠ éƒ¨åˆ†åˆ—ã®æœ€å°ã®å³ç«¯ INF = float(\u0026#39;inf\u0026#39;) dp = [INF for _ in range(len(lst))] for i in range(len(lst)): dp[bisect_left(dp, lst[i])] = lst[i] return bisect_left(dp, INF) print(LIS(lst)) ","date":1616648306,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616648306,"objectID":"da8a2ba3a1373b6665b60798ca85e843","permalink":"/ja/post/longest-increasing-subarray/","publishdate":"2021-03-25T13:58:26+09:00","relpermalink":"/ja/post/longest-increasing-subarray/","section":"post","summary":"Longest Increasing Subarrayï¼šæœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—å•é¡Œ é•·ã•$N$ã®æ•°åˆ—ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®ã†ã¡ã„ãã¤ã‹ã®é …ã‚’é †ç•ªã‚’å¤‰ãˆãšã«å–ã‚Šå‡ºã—ã¦éƒ¨åˆ†åˆ—ã‚’ä½œã‚‹ï¼ã“ã‚Œã‚‰","tags":[],"title":"Longest Increasing Subarray","type":"post"},{"authors":[],"categories":[],"content":"è¾æ›¸é †ã§ç›´å¾Œã®é †åˆ—ã‚’æ±‚ã‚ãŸã„ é•·ã•$n$ã®é…åˆ—ã‹ã‚‰$n$å€‹ã®è¦ç´ ã‚’å–ã‚Šå‡ºã™é †åˆ—ã‚’è€ƒãˆã‚‹ï¼ã‚ã‚‹ä¸¦ã³ã‚’ä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼Œé †åˆ—ã‚’è¾æ›¸é †ã«ä¸¦ã¹ãŸã¨ãã®ç›´å¾Œã®ä¸¦ã³ã‚’æ±‚ã‚ãŸã„ï¼\n[0, 1, 2, 3] -\u0026gt; [0, 1, 3, 2] [0, 1, 2, 5, 3, 3, 0] -\u0026gt; [0, 1, 3, 0, 2, 3, 5] ç­”ãˆ def next_permutation(lst): i = len(lst) - 1 while 0 \u0026lt; i and lst[i-1] \u0026gt;= lst[i]: i -= 1 if i == 0: return lst.reverse() i -= 1 pivot = lst[i] j = len(lst) - 1 while pivot \u0026gt;= lst[j]: j -= 1 lst[i], lst[j] = lst[j], lst[i] lst[i + 1:] = reversed(lst[i + 1:]) return lst ref: https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\n","date":1616600916,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616600916,"objectID":"2a5e4f10921ca3dbfad4a85c6c86bc10","permalink":"/ja/post/next-lexicographical-permutation/","publishdate":"2021-03-25T00:48:36+09:00","relpermalink":"/ja/post/next-lexicographical-permutation/","section":"post","summary":"è¾æ›¸é †ã§ç›´å¾Œã®é †åˆ—ã‚’æ±‚ã‚ãŸã„ é•·ã•$n$ã®é…åˆ—ã‹ã‚‰$n$å€‹ã®è¦ç´ ã‚’å–ã‚Šå‡ºã™é †åˆ—ã‚’è€ƒãˆã‚‹ï¼ã‚ã‚‹ä¸¦ã³ã‚’ä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼Œé †åˆ—ã‚’è¾æ›¸é †ã«ä¸¦ã¹ãŸã¨ãã®","tags":[],"title":"Next Lexicographical Permutation","type":"post"},{"authors":[],"categories":[],"content":"Maximum Subarray Problemï¼šæœ€å¤§éƒ¨åˆ†é…åˆ—å•é¡Œ æ•´æ•°é…åˆ—arrã‚’ä¸ãˆã‚‰ã‚Œã‚‹ï¼arrã®é€£ç¶šã™ã‚‹éƒ¨åˆ†é…åˆ—ã®å’Œã®ã†ã¡æœ€å¤§ã¨ãªã‚‹ã‚‚ã®ã®å€¤ã‚’æ±‚ã‚ã‚ˆï¼\nè§£æ³• ã„ãã¤ã‹ã‚„ã‚Šæ–¹ã¯ã‚ã‚‹ï¼\n$O(n^3)$ãªåŠ›æŠ€ éƒ¨åˆ†é…åˆ—ã®å€™è£œã¨ãªã‚‹æ·»å­—ã®çµ„ã¿åˆã‚ã›å…¨éƒ¨ã«å¯¾ã—ã¦ï¼Œãã®éƒ¨åˆ†é…åˆ—ã®å’Œã‚’å®Ÿéš›ã«è¨ˆç®—ã—ã¦æœ€å¤§å€¤ã‚’å‡ºã™ï¼\nlst = [-5, -1, 6, 4, 9, -6, -7] # ans = 19 # [2, 5] # index def solve(lst): ans = - 10 ** 9 idx = (-1, -1) for i in range(len(lst)): for j in range(i+1, len(lst)+1): s = 0 for k in range(i, j): s += lst[k] if ans \u0026lt; s: idx = (i, j) ans = s return ans, idx print(solve(lst)) $O(n^2)$ãªåŠ›æŠ€ ç´¯ç©å’Œã‚’è¨ˆç®—ã—ã¦ãŠã‘ã°lst[i:j]ã®å’Œã‚’$O(1)$ã§è¨ˆç®—ã§ãã‚‹ã®ã§å…¨ä½“ã¨ã—ã¦$O(n^2)$ã«ã§ãã‚‹ï¼\nlst = [-5, -1, 6, 4, 9, -6, -7] # ans = 19 # [2, 5] # index def solve(lst): accum = [0] for num in lst: accum.append(accum[-1] + num) print(accum) ans = - 10 ** 9 idx = (-1, -1) for i in range(len(lst)): for j in range(i+1, len(lst)+1): s = accum[j] - accum[i] if ans \u0026lt; s: idx = (i, j) ans = s return ans, idx print(solve(lst)) $O(n)$ãªè³¢ã„ã‚„ã‚Šæ–¹ æ•°åˆ—$a$ã®éƒ¨åˆ†å’Œã‚’\n$$ sum(i, j) = a_i + a_{i+1} + \u0026hellip; + a_{j-1} + a_j $$\nã¨ã™ã‚‹ï¼ã“ã“ã§æœ€å¾Œã®è¦ç´ ãŒ$a_j$ã§ã‚ã‚‹ã‚ˆã†ãªéƒ¨åˆ†é…åˆ—ã®å’Œã®æœ€å¤§å€¤ã‚’$s_j$ã¨ã™ã‚‹ã¨ï¼Œ$s_j$ã¯\n$$ s_j = max_{i \u0026lt; j} sum(i, j) $$\næœ€çµ‚çš„ã«æ±‚ã‚ãŸã„å€¤ã¯\n$$ max_{j} s_j $$\nã“ã“ã§ï¼Œ$s_{j+1}$ã¯ï¼Œ\n$$ s_{j+1} = max(s_j + a_{j+1}, a_{j+1}) $$\n$a_{j+1}$ã¨æ¯”ã¹ã‚‹ç†ç”±ã¯ï¼Œã€Œ$a_{j+1}$ã®ã¿ã‹ã‚‰ãªã‚‹åˆ—ã€ã‚‚ã€Œæœ€å¾Œã®è¦ç´ ãŒ$a_{j+1}$ã§çµ‚ã‚ã‚‹éƒ¨åˆ†åˆ—ã€ã§ã‚ã‚Šï¼Œãã®è¦ç´ ã®å’Œã¯$a_{j+1}$ã ã‹ã‚‰ï¼\nlst = [-5, -1, 6, 4, 9, -6, -7] # ans = 19 # [2, 5] # index def solve(lst): # dp[i]: æœ€å¾Œã®è¦ç´ ãŒlst[i]ã§ã‚ã‚‹ã‚ˆã†ãªéƒ¨åˆ†åˆ—ã®å’Œã®æœ€å¤§å€¤ dp = [lst[0]] for i in range(len(lst)-1): dp.append(max(dp[i] + lst[i+1], lst[i+1])) return max(dp) print(solve(lst)) dp[i+1]ã‚’æ±‚ã‚ã‚‹ã®ã«dp[i]ã—ã‹ä½¿ã‚ãªã„ã®ã§é…åˆ—ã‚‚ä½¿ã‚ãªã„å®Ÿè£…ã‚‚å¯èƒ½ï¼\nlst = [-5, -1, 6, 4, 9, -6, -7] # ans = 19 # [2, 5] # index def solve(lst): ans = lst[0] for i in range(len(lst)-1): ans = max(ans, max(ans + lst[i+1], lst[i+1])) return ans print(solve(lst)) ","date":1616595565,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616595565,"objectID":"f85097f6a216a0e1ddbec9a574f758f8","permalink":"/ja/post/max-subarray-problem-by-kadane-algorithm/","publishdate":"2021-03-24T23:19:25+09:00","relpermalink":"/ja/post/max-subarray-problem-by-kadane-algorithm/","section":"post","summary":"Maximum Subarray Problemï¼šæœ€å¤§éƒ¨åˆ†é…åˆ—å•é¡Œ æ•´æ•°é…åˆ—arrã‚’ä¸ãˆã‚‰ã‚Œã‚‹ï¼arrã®é€£ç¶šã™ã‚‹éƒ¨åˆ†é…åˆ—ã®å’Œã®ã†ã¡æœ€å¤§ã¨ãªã‚‹ã‚‚ã®ã®å€¤ã‚’æ±‚ã‚ã‚ˆï¼ è§£æ³• ã„ãã¤ã‹ã‚„","tags":[],"title":"Max Subarray Problem by Kadane Algorithm","type":"post"},{"authors":[],"categories":[],"content":"é †åˆ—ãƒ»çµ„ã¿åˆã‚ã›ã‚’ Python ã§æ±‚ã‚ãŸã„ Python ã¯å‰ã„ã®ã§ï¼Œitertoolsã¨ã„ã†ä¾¿åˆ©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ãˆã°ã†ã‚“ã¨åŠ¹ç‡ã®è‰¯ã„å®Ÿè£…ãŒå¾—ã‚‰ã‚Œã‚‹ï¼ä»Šå›ã¯æ•¢ãˆã¦itertoolsã‚’ä½¿ã‚ãšã«æ›¸ã„ã¦ã¿ã‚‹ï¼è¦ã™ã‚‹ã«å®Ÿè£…ã®ç·´ç¿’ï¼\nå–ã‚Šå‡ºã™è¦ç´ æ•°ã‚’å›ºå®šã«ã—ãŸé †åˆ—ãƒ»çµ„ã¿åˆã‚ã›ã®å®Ÿè£…ã‚’è€ƒãˆã‚‹ $n$å€‹ã®ã‚‚ã®ã‹ã‚‰$r$å€‹å–ã‚Šå‡ºã™ã“ã¨ã‚’ã„ããªã‚Šè€ƒãˆã‚‹ã¨æ··ä¹±ã™ã‚‹ã®ã§ï¼Œã¨ã‚Šã‚ãˆãš$n$å€‹ã®ã‚‚ã®ã‹ã‚‰$3$å€‹å–ã‚Šå‡ºã™ã“ã¨ã‚’è€ƒãˆã‚‹ï¼\né‡è¤‡ã‚’è¨±ã™é †åˆ— é‡è¤‡ã‚’è¨±ã™é †åˆ—ã¯$r$å›ãƒã‚¹ãƒˆã—ãŸforã«ç­‰ã—ã„ï¼\ndef repeated_permutation(lst): ret = [] for i in range(len(lst)): for j in range(len(lst)): for k in range(len(lst)): ret.append([lst[i], lst[j], lst[k]]) return ret é †åˆ— ä¸€åº¦å–ã‚Šå‡ºã—ãŸã‚‚ã®ã¯æ¬¡ã«å–ã‚Šå‡ºã›ãªã„ï¼\ndef permutation(lst): def exclude(lst, idx): return lst[:idx] + lst[idx+1:] ret = [] for i in range(len(lst)): for j in range(len(lst)-1): for k in range(len(lst)-2): ex_i = exclude(lst, i) ex_ij = exclude(ex_i, j) ret.append([lst[i], ex_i[j], ex_ij[k]]) return ret é‡è¤‡ã‚’è¨±ã™çµ„ã¿åˆã‚ã› 000 -\u0026gt; 001 -\u0026gt; 002 -\u0026gt; 010 -\u0026gt; 011 -\u0026gt; \u0026hellip;\ndef repeated_combination(lst): ret = [] for i in range(len(lst)): for j in range(i, len(lst)): for k in range(j, len(lst)): ret.append([lst[i], lst[j], lst[k]]) return ret çµ„ã¿åˆã‚ã› ä¸€åº¦å–ã‚Šå‡ºã—ãŸã‚‚ã®ã¯æ¬¡ã«å–ã‚Šå‡ºã›ãªã„ï¼\ndef combination(lst): def exclude(lst, idx): return lst[:idx] + lst[idx+1:] ret = [] for i in range(len(lst)): for j in range(i, len(lst)-1): for k in range(j, len(lst)-2): ex_i = exclude(lst, i) ex_ij = exclude(ex_i, j) ret.append([lst[i], ex_i[j], ex_ij[k]]) return ret ã“ã†ã¨ã‚‚è¨€ãˆã‚‹ï¼\ndef combination(lst): ret = [] for i in range(len(lst)): for j in range(i+1, len(lst)): for k in range(j+1, len(lst)): ret.append([lst[i], lst[j], lst[k]]) return ret å–ã‚Šå‡ºã™è¦ç´ æ•°ã‚’$r$å€‹ã«ã—ãŸé †åˆ—ãƒ»çµ„ã¿åˆã‚ã›ã®å®Ÿè£…ã‚’è€ƒãˆã‚‹ $r$å›ã®ãƒã‚¹ãƒˆã‚’å†å¸°é–¢æ•°ã§æ›¸ãï¼\né‡è¤‡ã‚’è¨±ã™é †åˆ— def repeated_permutation(lst, r): if r \u0026lt;= 0: return [] ret = [] def _recurse(lst, r, sofar): if r == 0: ret.append(sofar) return for i in range(len(lst)): _recurse(lst, r-1, sofar + [lst[i]]) _recurse(lst, r, []) return ret é †åˆ— def permutation(lst, r): if r \u0026lt;= 0: return [] ret = [] def _recurse(lst, r, sofar): if r == 0: ret.append(sofar) return for i in range(len(lst)): _recurse(lst[i:] + lst[i+1:], r-1, sofar + [lst[i]]) _recurse(lst, r, []) return ret é‡è¤‡ã‚’è¨±ã™çµ„ã¿åˆã‚ã› def repeated_combination(lst, r): if r \u0026lt;= 0: return [] ret = [] def _recurse(lst, r, sofar, start_idx): if r == 0: ret.append(sofar) return for i in range(start_idx, len(lst)): _recurse(lst, r-1, sofar + [lst[i]], i) _recurse(lst, r, [], 0) return ret çµ„ã¿åˆã‚ã› def combination(lst, r): if r \u0026lt;= 0: return 0 ret = [] def _recurse(lst, r, sofar, start_idx): if r == 0: ret.append(sofar) return for i in range(start_idx, len(lst)): _recurse(lst[:i] + lst[i+1:], r-1, sofar + [lst[i]], i) _recurse(lst, r, [], 0) return ret def combination(lst, r): if r \u0026lt;= 0: return 0 ret = [] def _recurse(lst, r, sofar, start_idx): if r == 0: ret.append(sofar) return for i in range(start_idx, len(lst)): _recurse(lst, r-1, sofar + [lst[i]], i+1) _recurse(lst, r, [], 0) return ret ","date":1616591859,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616591859,"objectID":"d7fb34de5b1d350aaa11070bda41065e","permalink":"/ja/post/permutation-combination-in-python/","publishdate":"2021-03-24T22:17:39+09:00","relpermalink":"/ja/post/permutation-combination-in-python/","section":"post","summary":"é †åˆ—ãƒ»çµ„ã¿åˆã‚ã›ã‚’ Python ã§æ±‚ã‚ãŸã„ Python ã¯å‰ã„ã®ã§ï¼Œitertoolsã¨ã„ã†ä¾¿åˆ©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ãˆã°ã†ã‚“ã¨åŠ¹ç‡ã®è‰¯ã„å®Ÿè£…ãŒå¾—ã‚‰ã‚Œã‚‹ï¼ä»Šå›ã¯æ•¢ãˆã¦ite","tags":[],"title":"Permutation and Combination in Python","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ•°å­—ã‚’ 2 é€²æ•°è¡¨ç¤ºã«ã—ãªã•ã„ï¼\nç­”ãˆ å†å¸°ã§è§£ãï¼\ndef num_to_bits(num): if 1 \u0026lt; num: return num_to_bits(num // 2) + str(num % 2) return str(num % 2) for num in range(10): print(\u0026#34;{}:{}\u0026#34;.format(num, num_to_bits(num))) ç¹°ã‚Šè¿”ã—ã§è§£ãï¼\ndef num_to_bits(num): if num == 0: return 0 bits = \u0026#34;\u0026#34; while num: if num % 2: bits = \u0026#34;1\u0026#34; + bits else: bits = \u0026#34;0\u0026#34; + bits num \u0026gt;\u0026gt;= 1 return bits for num in range(10): print(\u0026#34;{}:{}\u0026#34;.format(num, num_to_bits(num))) ","date":1616590466,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616590466,"objectID":"460befaa4e473da3467577670375f20a","permalink":"/ja/post/binary-representation-of-a-given-number/","publishdate":"2021-03-24T21:54:26+09:00","relpermalink":"/ja/post/binary-representation-of-a-given-number/","section":"post","summary":"å•é¡Œ æ•°å­—ã‚’ 2 é€²æ•°è¡¨ç¤ºã«ã—ãªã•ã„ï¼ ç­”ãˆ å†å¸°ã§è§£ãï¼ def num_to_bits(num): if 1 \u0026lt; num: return num_to_bits(num // 2) + str(num % 2) return str(num % 2) for num in range(10): print(\u0026#34;{}:{}\u0026#34;.format(num, num_to_bits(num))) ç¹°ã‚Šè¿”ã—ã§è§£ãï¼ def num_to_bits(num): if num == 0: return 0 bits = \u0026#34;\u0026#34; while num: if","tags":[],"title":"Binary Representation of a Given Number","type":"post"},{"authors":[],"categories":[],"content":"é…åˆ—ã®éƒ¨åˆ†é…åˆ—ã‚’å…¨éƒ¨æ±‚ã‚ã‚‹ è¦ç´ æ•°$n$ã®é…åˆ—ã®éƒ¨åˆ†é…åˆ—ã‚’å…¨éƒ¨æ±‚ã‚ãŸã„ï¼éƒ¨åˆ†é…åˆ—ã®ç·æ•°ã¯$2^n$ï¼\n[1, 2, 3] -\u0026gt; [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []] å†å¸°ã§æ±‚ã‚ã‚‹ lst[i:]ã®éƒ¨åˆ†é…åˆ—ã®ãã‚Œãã‚Œã«lst[i]ãŒå…¥ã‚‹ãƒ»å…¥ã‚‰ãªã„ã® 2 æŠï¼\nlst = [1, 2, 3] def subsets(lst): if len(lst) == 0: return [[]] x = subsets(lst[1:]) return x + [[lst[0]] + ele for ele in x] print(subsets(lst)) ãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ 000ï¼Œ001ï¼Œ010ï¼Œ011ï¼Œ100ï¼Œ101ï¼Œ110ï¼Œ111ã§ã©ã®è¦ç´ ã‚’éƒ¨åˆ†é…åˆ—ã«å…¥ã‚Œã‚‹ã‹å…¥ã‚Œãªã„ã‹ã‚’æ±ºã‚ã‚‹ï¼\nlst = [1, 2, 3] def subsets(lst): ret = [] for i in range(1 \u0026lt;\u0026lt; len(lst)): sub = [] for j in range(len(lst)): if i \u0026amp; (1 \u0026lt;\u0026lt; j): sub.append(lst[j]) ret.append(sub) return ret print(subsets(lst)) ","date":1616588440,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616588440,"objectID":"ab5364f63ad4ac4cfc2ffbd5c1529f29","permalink":"/ja/post/all-subsets-from-a-list-in-two-ways/","publishdate":"2021-03-24T21:20:40+09:00","relpermalink":"/ja/post/all-subsets-from-a-list-in-two-ways/","section":"post","summary":"é…åˆ—ã®éƒ¨åˆ†é…åˆ—ã‚’å…¨éƒ¨æ±‚ã‚ã‚‹ è¦ç´ æ•°$n$ã®é…åˆ—ã®éƒ¨åˆ†é…åˆ—ã‚’å…¨éƒ¨æ±‚ã‚ãŸã„ï¼éƒ¨åˆ†é…åˆ—ã®ç·æ•°ã¯$2^n$ï¼ [1, 2, 3] -\u0026gt; [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []] å†å¸°ã§æ±‚","tags":[],"title":"All Subsets From a List in Two Ways","type":"post"},{"authors":[],"categories":[],"content":"ã“ã® 60 å•ã‚’ Python ã§è§£ãï¼\n01: Two Sum $O(n^2)$ã§ã¯ãªã„ç­”ãˆã«ã—ãŸã„ã®ã§ï¼Œã©ã†ã™ã‚‹ã‹ï¼\n ç­”ãˆ class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: table = dict() for idx, num in enumerate(nums): complement = target - num if complement in table.keys(): return [idx, table[complement]] else: table[num] = idx  02: Add Two Numbers å†å¸°çš„ã«æ›¸ãï¼å†å¸°çš„ã«ï¼\n ç­”ãˆ # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: def _recurse(l1: ListNode, l2: ListNode, carry: int) -\u0026gt; ListNode: # base case if l1 is None and l2 is None and carry == 0: return None val = carry if l1 is not None: val += l1.val if l2 is not None: val += l2.val result = ListNode(val=val%10, next=None) if l1 is not None or l2 is not None: next_l1 = None next_l2 = None if l1 is not None: next_l1 = l1.next if l2 is not None: next_l2 = l2.next next_carry = val // 10 result.next = _recurse(next_l1, next_l2, next_carry) return result return _recurse(l1, l2, 0) ãƒªã‚¹ãƒˆãŒã€Œæ¡ã®å¤§ãã„é †ã€ã«ãªã£ã¦ã„ã‚‹å ´åˆã¯ãƒªã‚¹ãƒˆã‚’é€†è»¢ã•ã›ã¦ã“ã®å•é¡Œã«å¸°ç€ã•ã›ã‚‹ã‹ï¼Œã‚¹ã‚¿ãƒƒã‚¯ã‚’ 2 ã¤ä½¿ã†æ–¹æ³•ãŒã‚ã‚‹ï¼\nãƒªã‚¹ãƒˆã‚’é€†è»¢ã•ã›ã‚‹è§£æ³•\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: def reverse(root): if root is None or root.next is None: return root reversed_head = reverse(root.next) root.next.next = root root.next = None return reversed_head def rec(l1, l2, carry): if l1 is None and l2 is None and carry == 0: return None val = carry val += l1.val if l1 is not None else 0 val += l2.val if l2 is not None else 0 ret = ListNode(val=val % 10, next=None) l1_next = l1.next if l1 is not None else None l2_next = l2.next if l2 is not None else None ret.next = rec(l1_next, l2_next, val // 10) return ret return reverse(rec(reverse(l1), reverse(l2), 0)) 2 ã¤ã®ã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½¿ã†è§£æ³•ï¼šã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½¿ã†ã“ã¨ã§æ•°å­—ã‚’å°ã•ã„æ¡ã‹ã‚‰æ‰±ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ï¼\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: stack1 = [] stack2 = [] while l1 is not None: stack1.append(l1.val) l1 = l1.next while l2 is not None: stack2.append(l2.val) l2 = l2.next carry = 0 head = None while len(stack1) != 0 or len(stack2) != 0 or carry != 0: val = carry val += stack1.pop() if stack1 else 0 val += stack2.pop() if stack2 else 0 carry = val // 10 head_new = ListNode(val=val % 10, next=head) head = head_new return head  03: Longest Substring Without Repeating Characters é¡Œæ„ã¯ã€Œä¸ãˆã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã«å«ã¾ã‚Œã‚‹ï¼Œãƒ¦ãƒ‹ãƒ¼ã‚¯ãªæ–‡å­—ã«ã‚ˆã‚‹é€£ç¶šã™ã‚‹éƒ¨åˆ†æ–‡å­—åˆ—ã®ä¸­ã§ï¼Œæœ€é•·ã®ã‚‚ã®ã®é•·ã•ã‚’æ±‚ã‚ã‚ˆã€\n ç­”ãˆ ã“ã‚Œã¯ã—ã‚ƒãã¨ã‚Šæ³•ï¼ã™ã§ã«è¦‹ãŸã“ã¨ã®ã‚ã‚‹æ–‡å­—ãŒå‡ºã¦ããŸæ¬¡ç‚¹ã§ï¼Œãã‚Œã‚’å«ã‚€ç¯„å›²ã‚’ä¼¸ã°ã—ã¦ã‚‚ç­”ãˆã«ãªã‚‰ãªã„ã®ã§ï¼Œèµ°æŸ»ç¯„å›²ã®å·¦ç«¯ã‚’å³ç«¯ã®éš£ã«æ›´æ–°ã™ã‚‹ï¼$O(n)$ï¼\nclass Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: # ã—ã‚ƒãã¨ã‚Šæ³• start = 0 max_len = 0 seen = dict() # {char: occurrence idx} for curr, char in enumerate(s): if char in seen and start \u0026lt;= seen[char]: start = seen[char] + 1 else: max_len = max(max_len, curr - start + 1) seen[char] = curr return max_len  04: ZigZag Conversion è¦³å¯Ÿã™ã‚‹ï¼\nrow = 0 | 0 -(+6)-\u0026gt; 6 row = 1 | 1 -(+4)-\u0026gt; 5 -(+2)-\u0026gt; 7 ... row = 2 | 2 -(+2)-\u0026gt; 4 -(+4)-\u0026gt; 8 10 row = 3 | 3 -(+6)-\u0026gt; 9  ç­”ãˆ class Solution: def convert(self, s: str, numRows: int) -\u0026gt; str: if numRows == 1: return s interval = 2 * numRows - 2 ans = \u0026#34;\u0026#34; for row in range(numRows): for index in range(row, len(s), interval): ans += s[index] if not (row == 0 or row == numRows - 1): if index + (interval - row * 2) \u0026lt; len(s): ans += s[index + (interval - row * 2)] return ans  05: String to Integer (atoi) ä¸€æ–‡å­—ãšã¤è¦‹ã¦ã„ãï¼\n ç­”ãˆ class Solution: def myAtoi(self, s: str) -\u0026gt; int: s = s.strip() int_part = \u0026#34;\u0026#34; for char in s: if char == \u0026#34;.\u0026#34;: break # 123.4... if char.isdigit() or char in [\u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;]: if char in [\u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;] and 0 \u0026lt; len(int_part): break # 12345+... int_part += char else: break # char is alphabet ans = 0 digit = 0 for char in int_part[::-1]: if char == \u0026#34;-\u0026#34;: ans *= -1 #-123 elif char == \u0026#34;+\u0026#34;: continue # +123 else: ans += int(char) * (10 **digit) digit += 1 if -2 ** 31 \u0026lt;= ans and ans \u0026lt; 2 ** 31: return ans elif ans \u0026lt; -2 ** 31: return -2 ** 31 else: return 2 ** 31 - 1  06: Valid Parentheses é–‰ã˜ã‚«ãƒƒã‚³ã«å¯¾å¿œã™ã‚‹ã®ã¯ï¼Œæœ€ç›´è¿‘ã®é–‹ãã‚«ãƒƒã‚³ãªã®ã§ï¼ŒFIFOï¼ã ã‹ã‚‰ stack ã§ã†ã¾ãæ›¸ã‘ã‚‹ï¼\n ç­”ãˆ class Solution: def isValid(self, s: str) -\u0026gt; bool: stack = [] for p in s: if p in [\u0026#34;(\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;[\u0026#34;]: stack.append(p) continue else: if len(stack) == 0: return False q = stack.pop() if q in [\u0026#34;)\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;]\u0026#34;]: return False else: if q+p in [\u0026#34;()\u0026#34;, \u0026#34;{}\u0026#34;, \u0026#34;[]\u0026#34;]: continue else: stack.append(q) stack.append(p) if len(stack) == 0: return True else: return False  07: Generate Parentheses $n$å€‹ã®()ã‚’æ­£ã—ãä¸¦ã¹ã‚‹ã¨ãã®å…¨é€šã‚Šã‚’å‡ºåŠ›ã™ã‚‹ï¼\n ç­”ãˆ ã¾ãšå·¦ã‚«ãƒƒã‚³ãŒè¶³ã‚Šãªã„ã‹ã‚‰ä¸¦ã¹ã¦ï¼Œå·¦ã‚«ãƒƒã‚³æ›¸ãã™ããŸã‚‰å³ã‚«ãƒƒã‚³æ›¸ã„ã¦é–‰ã˜ãªãã‚ƒ\u0026hellip;\nclass Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: ret = [] def rec(left, right, sofar): if left == n and right == n: ret.append(sofar) return if left \u0026lt; n: rec(left + 1, right, sofar + \u0026#34;(\u0026#34;) if right \u0026lt; left: rec(left, right + 1, sofar + \u0026#34;)\u0026#34;) rec(0, 0, \u0026#34;\u0026#34;) return ret  08: Next Permutation 0125330ã®ç›´å¾Œã®é †åˆ—ã¯0130235ï¼ç›´å¾Œã®é †åˆ—ã¯å¾ŒåŠã ã‘ã„ã˜ã‚ŠãŸã„ï¼\n ç­”ãˆ class Solution: def nextPermutation(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; i = len(nums) - 1 while 0 \u0026lt; i and nums[i - 1] \u0026gt;= nums[i]: i -= 1 if i == 0: nums.reverse() return i -= 1 pivot = nums[i] j = len(nums) - 1 while pivot \u0026gt;= nums[j]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i + 1:] = reversed(nums[i + 1:])  09: Search in Rotated Sorted Array æ˜‡é †ã«ãªã£ã¦ã„ã‚‹ã¨ãã¯äºŒåˆ†æ¢ç´¢ã‚’ä½¿ã£ã¦ã»ã—ã„ã¨ã„ã†å‡ºé¡Œæ„å›³ã‚’æ±²ã¿å–ã‚ŠãŸã„ï¼\n ç­”ãˆ class Solution: def search(self, A: List[int], target: int) -\u0026gt; int: n = len(A) left, right = 0, n - 1 if n == 0: return -1 while left \u0026lt;= right: mid = left + (right - left) // 2 if A[mid] == target: return mid if A[mid] \u0026gt;= A[left]: if A[left] \u0026lt;= target \u0026lt; A[mid]: right = mid - 1 else: left = mid + 1 else: if A[mid] \u0026lt; target \u0026lt;= A[right]: left = mid + 1 else: right = mid - 1 return -1 ã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ã«è½ã¨ã—è¾¼ã‚€ã“ã¨ã§è§£ãã»ã†ãŒé ­ãŒæ•´ç†ã•ã‚Œã¦è‰¯ã„ï¼ã“ã“ã§ã¯æ¬¡ã®å›³ã®ã‚ˆã†ã«is_ok(mid)ã‚’è¨­è¨ˆã—ã¦ã„ã‚‹ï¼\n   is_ok(mid)ã®æŒ™å‹•   class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: if nums[0] == target: return 0 def is_ok(mid): if nums[0] \u0026lt; target: return target \u0026lt;= nums[mid] or nums[mid] \u0026lt; nums[0] else: return target \u0026lt;= nums[mid] and nums[mid] \u0026lt; nums[0] ng = -1 ok = len(nums) while 1 \u0026lt; abs(ng - ok): mid = (ng + ok) // 2 if is_ok(mid): ok = mid else: ng = mid if ok \u0026lt; 0 or len(nums) \u0026lt;= ok or nums[ok] != target: return -1 else: return ok  10: Search Insert Position ã€Œè¦ç´ ãŒæ˜‡é †ã«ä¸¦ã‚“ã§ã„ã‚‹ã€ã¨æ¥ã‚Œã°\u0026hellip;\n ç­”ãˆ è¦ç´ ãŒæ˜‡é †ã«ä¸¦ã‚“ã§ã„ã‚‹ã®ã§ï¼ŒäºŒåˆ†æ¢ç´¢ï¼\nclass Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: return bisect_left(nums, target) ã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ã§ã¯ã“ã†ãªã‚‹ï¼\nclass Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: def is_ok(mid): return target \u0026lt;= nums[mid] ng = -1 ok = len(nums) while 1 \u0026lt; abs(ng - ok): mid = (ng + ok) // 2 if is_ok(mid): ok = mid else: ng = mid return ok åˆ¥è§£ã¨ã—ã¦ä¸€ã¤ãšã¤è¦‹ã¦ã„ãã®ã§ã‚‚è§£ã‘ã‚‹ï¼$O(n)$ï¼\nclass Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: pos = 0 for ele in nums: if target \u0026lt;= ele: return pos else: pos += 1 return pos  11: Combination Sum å…¨é€šã‚ŠãŒã„ãã¤ã‚ã‚‹ã®ã‹ã¯ã‚ã‹ã‚‰ãªã„ã‘ã©ï¼ŒçŒªçªçŒ›é€²ã«èª¿ã¹ã‚‹ï¼candidates[:]ã‚’ä½¿ã†å ´åˆï¼Œcandidates[1:]ã‚’ä½¿ã†å ´åˆï¼Œcandidates[2:]ã‚’ä½¿ã†å ´åˆ\u0026hellip;\n ç­”ãˆ class Solution: def combinationSum(self, candidates: List[int], target: int) -\u0026gt; List[List[int]]: ret = [] def rec(nums, remain, sofar): if remain \u0026lt; 0: return if remain == 0: ret.append(sofar) return for i in range(len(nums)): rec(nums[i:], remain - nums[i], sofar + [nums[i]]) rec(candidates, target, []) return ret  12: Permutations é›†åˆ$A$ã‹ã‚‰ä¸€ã¤é¸ã‚“ã§ï¼Œæ®‹ã‚Šã‹ã‚‰ä¸€ã¤é¸ã‚“ã§\u0026hellip;\n ç­”ãˆ class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] def _recurse(nums, sofar): if len(nums) == 0: ans.append(sofar) return for i in range(len(nums)): _recurse(nums[:i]+nums[i+1:], sofar + [nums[i]]) _recurse(nums, []) return ans  13: Group Anagrams  ç­”ãˆ class Solution: def groupAnagrams(self, strs: List[str]) -\u0026gt; List[List[str]]: table = dict() for s in strs: ss = \u0026#34;\u0026#34;.join(sorted(s)) if ss not in table: table[ss] = [s] else: table[ss].append(s) return list(table.values())  14: Pow(x, n) myPow = powã¯æµçŸ³ã«ãƒãƒ¼ãƒˆã‹ï¼å‡ºé¡Œæ„å›³ã¯ç¹°ã‚Šè¿”ã—è‡ªä¹—æ³•ï¼\n ç­”ãˆ å†å¸°ã§æ›¸ã„ãŸç­”ãˆ\nclass Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n == 0: return 1.0 if n \u0026lt; 0: return 1/self.myPow(x, -n) if n % 2 == 1: return x * self.myPow(x, n - 1) return self.myPow(x * x, n // 2) ç¹°ã‚Šè¿”ã—ã§æ›¸ã„ãŸç­”ãˆ\nclass Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n == 0: return 1.0 if n \u0026lt; 0: x = 1 / x n = -n ans = 1 while n != 0: if n \u0026amp; 1: ans *= x x *= x n \u0026gt;\u0026gt;= 1 return ans  15: Maximum Subarray  ç­”ãˆ æœ€å¤§éƒ¨åˆ†é…åˆ—å•é¡Œï¼šä¸ãˆã‚‰ã‚ŒãŸé…åˆ—ã«å¯¾ã—ã¦ï¼Œãã®éƒ¨åˆ†é…åˆ—ã®ã†ã¡è¦ç´ ã®å’ŒãŒæœ€å¤§ã¨ãªã‚‹ã¨ãã®ãã®æœ€å¤§å’Œã‚’æ±‚ã‚ã‚‹å•é¡Œ\nå…¥åŠ›ï¼š ${a_i}_{i=0}^{n-1}$\nå‡ºåŠ›ï¼š $x = \\max \\sum_{k=i}^j a_k \\mathrel{\\bigg|} 0\\leq i \\leq j \\lt n$\n  $i$ï¼Œ$j$ã«ã¤ã„ã¦å…¨æ¢ç´¢ã™ã‚Œã°$O(n^3)$ï¼š$x = \\max_{0\\leq i \u0026lt; n} \\max_{i \\leq j \u0026lt; n} \\sum_{k=i}^j a_k$\n  $\\sum_{k=i}^j a_k$ã‚’ç´¯ç©å’Œã‚’ä½¿ã£ã¦æ±‚ã‚ã‚Œã°$O(n^2)$\n  $i$ã¨$j$ã®æœ€å¤§å€¤ã‚’å–ã‚‹é †ç•ªã‚’é€†ã«ã—ã¦$x = \\max_{0\\leq j \u0026lt; n} \\max_{0 \\leq i \u0026lt; j} \\sum_{k=i}^j a_k$ã¨å¤‰å½¢ã™ã‚‹ã¨$s_j = \\max_{0 \\leq i \u0026lt; j} \\sum_{k=i}^j a_k$ã¨ã—ã¦$x = \\max_{0\\leq j \u0026lt; n} s_j$ã¨ãªã£ã¦ï¼Œ$s_j$ã«ã¤ã„ã¦ä»¥ä¸‹ãŒæˆç«‹ã™ã‚‹ã®ã§$O(n)$ï¼\n  $$ \\begin{align} s_{j} \u0026amp;= \\max_{0 \\leq i \\leq j} \\sum_{k=i}^j a_k\\\\\\\n\u0026amp;= \\max (\\max_{0 \\leq i \\leq j-1} \\sum_{k=i}^j a_k, \\max_{j \\leq i \\leq j} \\sum_{k=i}^j a_k) \\\\\\\n\u0026amp;= \\max (\\max_{0 \\leq i \\leq j-1} \\sum_{k=i}^{j-1} a_k + a_j, a_j) \\\\\\\n\u0026amp;= \\max( s_{j-1} + a_j, a_j) \\end{align} $$\nclass Solution: def maxSubArray(self, nums: List[int]) -\u0026gt; int: s = 0 ans = -10**5 for j in range(len(nums)): s = max(s + nums[j], nums[j]) ans = max(ans, s) return ans ç›´æ¥çš„ã«dpã§æ›¸ãã¨ã“ã†ãªã‚‹ï¼\nclass Solution: def maxSubArray(self, nums: List[int]) -\u0026gt; int: # dp[i]: nums[i]ãŒå³ç«¯è¦ç´ ã¨ãªã‚‹ã‚ˆã†ãªé€£ç¶šã™ã‚‹éƒ¨åˆ†é…åˆ—ã®å’Œã®æœ€å¤§å€¤ # dp[i+1] = max(dp[i] + nums[i], nums[i]) dp = [float(\u0026#34;-inf\u0026#34;)] * len(nums) dp[0] = nums[0] for i in range(len(nums) - 1): dp[i + 1] = max(dp[i] + nums[i + 1], nums[i + 1]) return max(dp)  16: Unique Paths ä¸­å­¦å—é¨“ã®é“ã®æ•°ãˆä¸Šã’å•é¡Œ\n ç­”ãˆ class Solution: def uniquePaths(self, m: int, n: int) -\u0026gt; int: # dp[i][j]: number of unique paths to (i, j) # dp[i][j] = dp[i][j-1] + dp[i-1][j] dp = [[1 for _ in range(n)] for _ in range(m)] for i in range(1, m, 1): for j in range(1, n, 1): dp[i][j] = dp[i][j-1] + dp[i-1][j] return dp[m-1][n-1]  17: Unique Paths II ã“ã‚Œã‚‚ä¸­å­¦å—é¨“ã§é »å‡ºã®ã‚„ã¤ï¼\n ç­”ãˆ class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -\u0026gt; int: if not obstacleGrid: return 0 H = len(obstacleGrid) W = len(obstacleGrid[0]) obstacleGrid[0][0] = 1 - obstacleGrid[0][0] for h in range(1, H): obstacleGrid[h][0] = obstacleGrid[h-1][0] * (1 - obstacleGrid[h][0]) for w in range(1, W): obstacleGrid[0][w] = obstacleGrid[0][w-1] * (1 - obstacleGrid[0][w]) for h in range(1, H): for w in range(1, W): obstacleGrid[h][w] = (obstacleGrid[h-1][w] + obstacleGrid[h][w-1]) * (1 - obstacleGrid[h][w]) return obstacleGrid[H-1][W-1]  18: Subsets å…¨æ¢ç´¢\n ç­”ãˆ  å†å¸°ã§æ›¸ãï¼š$n$å€‹ã®æ•°å­—ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹ã™ã¹ã¦ã®éƒ¨åˆ†é…åˆ—ã¯ï¼Œ$n-1$å€‹ã®æ•°å­—ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹ã™ã¹ã¦ã®éƒ¨åˆ†é…åˆ—ã®ãã‚Œãã‚Œã«$n$å€‹ç›®ã®æ•°å­—ã‚’å…¥ã‚Œã‚‹ã‹å…¥ã‚Œãªã„ã‹ã§è¨ˆç®—ã§ãã‚‹  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: def _recurse(nums): if len(nums) == 0: return [[]] sub = _recurse(nums[1:]) return sub + [s + [nums[0]] for s in sub] return _recurse(nums)  bit å…¨æ¢ç´¢ã§æ›¸ã  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] for i in range(1 \u0026lt;\u0026lt; len(nums)): sub = [] for j in range(len(nums)): if i \u0026amp; 1 \u0026lt;\u0026lt; j: sub.append(nums[j]) ans.append(sub) return ans  ç¹°ã‚Šè¿”ã—ã§æ›¸ã  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [[]] for num in nums: ans += [[num] + sub for sub in ans] return ans  19: Remove Duplicates from Sorted List II ä¸€ã¤ãšã¤è¦‹ã¦ã„ãï¼\n ç­”ãˆ # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def deleteDuplicates(self, head: ListNode) -\u0026gt; ListNode: dummy_head = ListNode(val=-101, next=head) prev = dummy_head current = head while current is not None and current.next is not None: while current.val != current.next.val: current = current.next prev = prev.next if current.next is None: return dummy_head.next while current is not None and current.next is not None and current.val == current.next.val: current = current.next prev.next = current.next current = current.next if current is None: return dummy_head.next return dummy_head.next  20: Remove Duplicates from Sorted List ä¸€å€‹é£›ã°ã—\n ç­”ãˆ # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def deleteDuplicates(self, head: ListNode) -\u0026gt; ListNode: current = head while current is not None and current.next is not None: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head  21: Validate Binary Search Tree inorder ã§é ‚ç‚¹ã«è¨ªå•ã—ãŸã¨ãã«æ˜‡é †ã«ãªã£ã¦ã„ã‚Œã°æ­£ã—ã„äºŒåˆ†æ¢ç´¢æœ¨\n ç­”ãˆ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isValidBST(self, root: TreeNode) -\u0026gt; bool: inordered = [] def _inorder_traversal(root): if root is None: return if root.left is not None: _inorder_traversal(root.left) inordered.append(root.val) if root.right is not None: _inorder_traversal(root.right) _inorder_traversal(root) for i in range(0, len(inordered)-1, 1): if inordered[i] \u0026gt;= inordered[i+1]: return False return True å·¦ã®éƒ¨åˆ†æœ¨ã®æœ€å¤§å€¤ \u0026lt; ã“ã®ãƒãƒ¼ãƒ‰ã®å€¤ \u0026lt; å³ã®éƒ¨åˆ†æœ¨ã®æœ€å°å€¤ã‚’å†å¸°çš„ã«ç¢ºã‹ã‚ã‚‹æ–¹æ³•ã‚‚ã‚ã‚‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isValidBST(self, root: TreeNode) -\u0026gt; bool: def _isValidBST(root, larger_than, less_than): if root is None: return True if root.val \u0026lt;= larger_than or less_than \u0026lt;= root.val: return False return _isValidBST(root.left, larger_than, min(less_than, root.val)) and _isValidBST(root.right, max(larger_than, root.val), less_than) return _isValidBST(root, float(\u0026#39;-inf\u0026#39;), float(\u0026#39;inf\u0026#39;))  22: Binary Tree Level Order Traversal  ç­”ãˆ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: def _levelOrder(root, lsts, level): if root is None: return lst = None if len(lsts) == level: lst = list() lsts.append(lst) else: lst = lsts[level] lst.append(root.val) _levelOrder(root.left, lsts, level+1) _levelOrder(root.right, lsts, level+1) return lsts return _levelOrder(root, [], 0) BFS ã£ã½ãã‚‚ã§ãã‚‹ï¼suspendedã«levelæ®µç›®ã®é ‚ç‚¹ã®ã¿ãŒå…¨éƒ¨å…¥ã£ã¦ã„ã‚‹ã‚ˆã†ã«æ›´æ–°ã™ã‚‹ï¼suspendedã«è¿½åŠ ã—ãªãŒã‚‰æ¬¡ã®é ‚ç‚¹ã«è¡Œã‹ãªã„ã‚ˆã†ã«ã™ã‚‹ï¼\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if root is None: return [] suspended = [] suspended.append(root) lsts = [] level = 0 while len(suspended) != 0: if len(lsts) == level: lsts.append([]) next_suspended = [] for u in suspended: lsts[level].append(u.val) if u.left is not None: next_suspended.append(u.left) if u.right is not None: next_suspended.append(u.right) suspended = next_suspended level += 1 return lsts  23: Binary Tree Zigzag Level Order Traversal ä¸€ã¤å‰ã®ã‚’ã¡ã‚‡ã£ã¨ã ã‘ã‚¤ã‚¸ã‚‹ï¼\n ç­”ãˆ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def zigzagLevelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if root is None: return [] suspended = [] suspended.append(root) lsts = [] level = 0 order_flag = -1 while len(suspended) != 0: if len(lsts) == level: lsts.append([]) next_suspended = [] for u in suspended: lsts[level].append(u.val) if u.right is not None: next_suspended.append(u.right) if u.left is not None: next_suspended.append(u.left) suspended = next_suspended lsts[level] = lsts[level][::order_flag] order_flag = -order_flag level += 1 return lsts  24: Maximum Depth of Binary Tree æœ¨ã®æ·±ã•ã¯è‘‰ãƒãƒ¼ãƒ‰ã‹ã‚‰æˆ»ã£ã¦ããªãŒã‚‰è¨ˆç®—ã™ã‚‹ï¼\n ç­”ãˆ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -\u0026gt; int: def _recurse(root): if root is None: return 0 if root.left is not None and root.right is not None: return max(_recurse(root.left), _recurse(root.right)) + 1 if root.left is None and root.right is not None: return _recurse(root.right) + 1 if root.left is not None and root.right is None: return _recurse(root.left) + 1 return 1 return _recurse(root)  25: Construct Binary Tree from Preorder and Inorder Traversal preorderã‹ã‚‰inorderã‚’å·¦å³ã«åˆ†å‰²ã§ãã‚‹ï¼ã“ã‚Œã‚’ç¹°ã‚Šè¿”ã™ï¼\n ç­”ãˆ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -\u0026gt; TreeNode: if len(inorder) != 0: idx = inorder.index(preorder.pop(0)) root = TreeNode(val=inorder[idx]) root.left = self.buildTree(preorder, inorder[0:idx]) root.right = self.buildTree(preorder, inorder[idx+1:]) return root  26: Convert Sorted Array to Binary Search Tree å·¦å³ã®éƒ¨åˆ†æœ¨ã®é«˜ã•ãŒåŒã˜ãã‚‰ã„ã«ã—ãŸã„ã®ã§ï¼Œã ã„ãŸã„å¤§ãã•çš„ã«çœŸã‚“ä¸­ãã‚‰ã„ã®è¦ç´ ã‹ã‚‰æ ¹ã«ã™ã‚‹ï¼è¦ç´ ãŒã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã®ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§çœŸã‚“ä¸­è¾ºã‚Šã‹ã‚‰æ ¹ã‚’ä½œã‚‹ï¼\n ç­”ãˆ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sortedArrayToBST(self, nums: List[int]) -\u0026gt; TreeNode: def _recurse(nums, low, high): if high \u0026lt; low: return None middle = (low + high) // 2 root = TreeNode(val=nums[middle]) root.left = _recurse(nums, low, middle-1) root.right = _recurse(nums, middle+1, high) return root return _recurse(nums, 0, len(nums)-1)  27: Minimum Depth of Binary Tree  ç­”ãˆ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def minDepth(self, root: TreeNode) -\u0026gt; int: def _recurse(root): if root is None: return 0 if root.left is not None and root.right is not None: return min(_recurse(root.left), _recurse(root.right)) + 1 if root.left is None: return _recurse(root.right) + 1 if root.right is None: return _recurse(root.left) + 1 return 1 return _recurse(root)  28: Path Sum å…¨æ¢ç´¢\n ç­”ãˆ  å†å¸°ã‚’ä½¿ã£ãŸ DFS  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum(self, root: TreeNode, targetSum: int) -\u0026gt; bool: results = [] def _recurse(root, remaining): if root is None: return if root.left is None and root.right is None and root.val == remaining: results.append(True) return remaining -= root.val _recurse(root.left, remaining) _recurse(root.right, remaining) _recurse(root, targetSum) return any(results)  stack ã‚’ä½¿ã£ãŸ DFS  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum(self, root: TreeNode, targetSum: int) -\u0026gt; bool: if root is None: return False suspended = list() suspended.append((root, root.val)) while len(suspended) != 0: u, sofar = suspended.pop() if u.left is None and u.right is None and sofar == targetSum: return True if u.left is not None: suspended.append((u.left, sofar + u.left.val)) if u.right is not None: suspended.append((u.right, sofar + u.right.val)) return False  queue ã‚’ä½¿ã£ãŸ BFS  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum(self, root: TreeNode, targetSum: int) -\u0026gt; bool: if root is None: return False suspended = list() suspended.append((root, root.val)) while len(suspended) != 0: u, sofar = suspended.pop(0) if u.left is None and u.right is None and sofar == targetSum: return True if u.left is not None: suspended.append((u.left, sofar + u.left.val)) if u.right is not None: suspended.append((u.right, sofar + u.right.val)) return False  29: Best Time to Buy and Sell Stock æœ€å°ã®æ—¥ã‚’ä¿å­˜ã—ãªãŒã‚‰èˆã‚ã‚‹ï¼\n ç­”ãˆ class Solution: def maxProfit(self, prices: List[int]) -\u0026gt; int: profit = 0 min_sofar = prices[0] for i in range(1, len(prices), 1): profit = max(profit, prices[i] - min_sofar) min_sofar = min(min_sofar, prices[i]) return profit å•é¡Œã‚’ã¡ã‚‡ã£ã¨ã ã‘å¼„ã£ã¦ï¼Œå‰æ—¥ã‹ã‚‰ã®å€¤æ®µã®å·®ã‚’æ ¼ç´ã—ãŸé…åˆ—ãŒæ¸¡ã•ã‚Œã¦åˆ©ç›Šã®æœ€å¤§å€¤ã‚’æ±‚ã‚ã‚ˆã†ã¨ã™ã‚‹ã¨ï¼Œã“ã‚Œã¯æœ€å¤§éƒ¨åˆ†é…åˆ—å’Œå•é¡Œï¼\nKadane ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§è§£ã‘ã‚‹ï¼Kadane ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯å…¨æ¢ç´¢ã®é †åºã‚’æ›¿ãˆã‚‹ã“ã¨ã§å‰æ—¥ã¾ã§ã®æœ€å¤§åˆ©ç›Šã‚’ä½¿ã£ã¦å½“æ—¥ã¾ã§ã®æœ€å¤§åˆ©ç›Šã‚’ä½æ•°æ™‚é–“ã§è¨ˆç®—ã§ãã¦ï¼Œå…¨ä½“ã¨ã—ã¦$O(n)$ã«ãªã‚‹ã¨ã„ã†ã‚„ã¤ï¼DPï¼\nclass Solution: def maxProfit(self, priceDiff: List[int]) -\u0026gt; int: max_profit = 0 max_current = 0 for i in range(1, len(priceDiff), 1): max_current += (priceDiff[i] - priceDiff[i-1]) max_current = max(0, max_current) max_profit = max(max_profit, max_current) return max_profit  30: Best Time to Buy and Sell Stock II ä»Šæ—¥ã‚ˆã‚Šæ˜æ—¥ã®ã»ã†ãŒé«˜å€¤ãªã‚‰ï¼Œä»Šæ—¥è²·ã£ã¦æ˜æ—¥å£²ã‚ã†ï¼\n ç­”ãˆ class Solution: def maxProfit(self, prices: List[int]) -\u0026gt; int: return sum(max(0, prices[i+1] - prices[i]) for i in range(len(prices) - 1))  31: Word Ladder ã‚°ãƒªãƒƒãƒ‰ã‚°ãƒ©ãƒ•ã®æ–‡å­—åˆ—ç‰ˆã ã¨æ€ãˆã‚Œã°å¤§ä¸ˆå¤«ï¼ã‚°ãƒªãƒƒãƒ‰ã‚°ãƒ©ãƒ•ã®ãƒã‚¹ç›®ã« 1 æ–‡å­—ã ã‘é•ã†æ–‡å­—åˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ã‚°ãƒ©ãƒ•ä¸Šã®ãƒã‚¹ç›®ã‚’è¸ã‚“ã§ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸ï¼è¨€ã†ãªã‚Œã° 26 æ¬¡å…ƒã‚°ãƒªãƒƒãƒ‰ã‚°ãƒ©ãƒ•ã‹ï¼\n ç­”ãˆ class Solution: def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -\u0026gt; int: not_visited_yet = set(wordList) suspended = list() not_visited_yet.add(beginWord) suspended.append((beginWord, 1)) while len(suspended) != 0: word, length = suspended.pop(0) if word == endWord: return length for i in range(len(word)): for char in \u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39;: next_candidate = word[:i] + char + word[i+1:] if next_candidate in not_visited_yet: not_visited_yet.remove(next_candidate) suspended.append((next_candidate, length + 1)) return 0  32: Word Break wordDictå†…ã®æ–‡å­—åˆ—ã®é‡è¤‡ã‚’è¨±ã™çµ„ã¿åˆã‚ã›ã‚’å…¨éƒ¨æ±‚ã‚ã¦sã¨ä¸€è‡´ã™ã‚‹ã‹ã‚’èª¿ã¹ã¦ã‚‚$O(2^n)$ã§åŸç†çš„ã«ã¯è§£ã‘ã‚‹ãŒ1 \u0026lt;= len(wordDict) \u0026lt;= 1000ãªã®ã§é–“ã«åˆã‚ãªã„ï¼ ãã“ã§sã«ã¤ã„ã¦è€ƒãˆã‚‹ï¼ã€Œ$i$æ–‡å­—ç›®ã‚ˆã‚Šå‰ã®éƒ¨åˆ†æ–‡å­—åˆ—s[:i]ã‚’å®Ÿç¾ã§ãã‚‹ã‹ã€ã¯ã€Œ$j$ï¼ˆ$j \u0026lt; i$ï¼‰æ–‡å­—ç›®ã‚ˆã‚Šå‰ã®éƒ¨åˆ†æ–‡å­—åˆ—s[:j]ã‚’å®Ÿç¾ã§ãã¦ï¼Œã‹ã¤æ®‹ã‚Šã®s[j:i]ãŒwordDictå†…ã«ã‚ã‚‹ã‹ã€ã§æ±‚ã¾ã‚‹ï¼DPï¼\n ç­”ãˆ class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; bool: # dp[i]: whether s[:i] can be build from words in wordDict words = set(wordDict) # for lookup in O(1) dp = [True] for i in range(1, len(s)+1): dp += [any(dp[j] and s[j:i] in words for j in range(i))] return dp[len(s)] ã€ŒwordDictå†…ã«ã‚ã‚‹æœ€é•·ã®æ–‡å­—åˆ—ã®é•·ã•ã€ä»¥ä¸Šã®séƒ¨åˆ†æ–‡å­—åˆ—ãŒwordDictå†…ã«ã‚ã‚‹ã¯ãšãŒãªã„ã®ã§ãã‚Œã‚’çœãã¨åŠ¹ç‡ãŒè‰¯ããªã‚‹ï¼\nclass Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; bool: # dp[i]: whether s[:i] can be build from words in wordDict words = set(wordDict) # for lookup in O(1) max_len = max(map(len, wordDict)) dp = [True] for i in range(1, len(s)+1): dp += [any(dp[j] and s[j:i] in words for j in range(max(0, i - max_len), i))] return dp[len(s)]  33: Linked List Cycle äºŒäººèµ°ã‚‰ã›ã‚‹ï¼å‡ºé€¢ãˆã°ãƒ«ãƒ¼ãƒ—ã‚ã‚Šï¼è¶³ã®æ—©ã„ã»ã†ãŒå´–ã‹ã‚‰è½ã¡ã‚Œã°ãƒ«ãƒ¼ãƒ—ãªã—ï¼\n ç­”ãˆ # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: if head is None: return False slower = head faster = head while faster.next is not None and faster.next.next is not None: slower = slower.next faster = faster.next.next if slower is faster: return True return False  34: Linked List Cycle II äºŒäººèµ°ã‚‰ã›ã‚‹ï¼1 å‘¨å›å·®ã¤ã‘ã‚‰ã‚ŒãŸã¨ã“ã‚ã§åˆã‚ã¦å‡ºä¼šã†ï¼\n ç­”ãˆ # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def detectCycle(self, head: ListNode) -\u0026gt; ListNode: if head is None: return None faster = head slower = head has_loop = False while faster.next is not None and faster.next.next is not None: slower = slower.next faster = faster.next.next if slower is faster: has_loop = True slower = head break if has_loop: while slower is not faster: slower = slower.next faster = faster.next return slower else: return None  35: Find Minimum in Rotated Sorted Array äºŒåˆ†æ¢ç´¢ã£ã½ã„ã“ã¨ã‚’ã™ã‚‹ï¼æ˜‡é †ã«ãªã£ãŸã‚‚ã®ã‚’å›è»¢ã•ã›ã‚‹ã¨ãã®æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•ã‚’æãçœŸã‚“ä¸­ã¨å·¦å³ã®æ¯”è¼ƒã§ã©ã“ã«æœ€å°å€¤ãŒã‚ã‚‹ã‹ãŒã‚ã‹ã‚‹ï¼\n ç­”ãˆ class Solution: def findMin(self, nums: List[int]) -\u0026gt; int: left, right = 0, len(nums) - 1 while left \u0026lt; right: middle = (left + right) // 2 if nums[middle] \u0026lt; nums[right]: right = middle else: left = middle + 1 return nums[left] å…ƒã®é…åˆ—ãŒæ˜‡é †ã«ä¸¦ã‚“ã§ã‚ã‚‹ã®ã§ã€Œå…ˆé ­è¦ç´ ã‚ˆã‚Šå°ã•ããªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä½ç½®ã«ã‚ã‚‹è¦ç´ ãŒã»ã—ã„ã€ã¨å•é¡Œã‚’è¨€ã„æ›ãˆã‚‰ã‚Œã‚Œã°ï¼Œã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ã«è½ã¨ã—è¾¼ã‚ã‚‹ï¼\nclass Solution: def findMin(self, nums: List[int]) -\u0026gt; int: def is_ok(mid): return nums[mid] \u0026lt; nums[0] ng = -1 ok = len(nums) while 1 \u0026lt; abs(ok - ng): mid = (ok + ng) // 2 if is_ok(mid): ok = mid else: ng = mid return nums[ok] if ok != len(nums) else nums[0]  36: House Robber [2,1,1,2]ã¨ã„ã†ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å¿˜ã‚Œã¦ã¯ãªã‚‰ãªã„ï¼\n ç­”ãˆ dp[i]ï¼šiç•ªç›®ã¾ã§ã®å®¶ã‹ã‚‰ç›—ã‚ã‚‹ãŠé‡‘ã®æœ€å¤§å€¤ dp[i] = max(dp[i-2] + nums[i], dp[i-1])\nclass Solution: def rob(self, nums: List[int]) -\u0026gt; int: # dp[i]: nums[:i+1]ã§ã®ç›—ã‚ã‚‹ãŠé‡‘ã®æœ€å¤§å€¤ # dp[i] = max(dp[i-1], dp[i-2] + nums[i]) if len(nums) \u0026lt; 3: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) return dp[-1]  37: Number of Islands ã‚°ãƒªãƒƒãƒ‰ã‚°ãƒ©ãƒ•ã®å…¨æ¢ç´¢ï¼æ‹™è‘—è¨˜äº‹ã¯ã“ã“ï¼\n ç­”ãˆ queue ã‚’ä½¿ã† BFS ã®ç­”ãˆ\nclass Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)] H = len(grid) W = len(grid[0]) has_visited = set() suspended = list() ans = 0 for h in range(H): for w in range(W): if (h, w) in has_visited or grid[h][w] == \u0026#34;0\u0026#34;: continue has_visited.add((h, w)) suspended.append((h, w)) ans += 1 while len(suspended) != 0: (_h, _w) = suspended.pop(0) for (dh, dw) in dirs: next_h = _h + dh next_w = _w + dw if 0 \u0026lt;= next_h \u0026lt; H and 0 \u0026lt;= next_w \u0026lt; W and grid[next_h][next_w] == \u0026#34;1\u0026#34; and (next_h, next_w) not in has_visited: has_visited.add((next_h, next_w)) suspended.append((next_h, next_w)) return ans stack ã‚’ä½¿ã† DFS ã®ç­”ãˆ\nclass Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)] H = len(grid) W = len(grid[0]) has_visited = set() suspended = list() ans = 0 for h in range(H): for w in range(W): if (h, w) in has_visited or grid[h][w] == \u0026#34;0\u0026#34;: continue has_visited.add((h, w)) suspended.append((h, w)) ans += 1 while len(suspended) != 0: (_h, _w) = suspended.pop() for (dh, dw) in dirs: next_h = _h + dh next_w = _w + dw if 0 \u0026lt;= next_h \u0026lt; H and 0 \u0026lt;= next_w \u0026lt; W and grid[next_h][next_w] == \u0026#34;1\u0026#34; and (next_h, next_w) not in has_visited: has_visited.add((next_h, next_w)) suspended.append((next_h, next_w)) return ans å†æ°—ã‚’ã¤ã‹ã† DFS ã®ç­”ãˆ\nclass Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)] H = len(grid) W = len(grid[0]) has_visited = set() ans = 0 def dfs(h, w): has_visited.add((h, w)) for (dh, dw) in dirs: nh = h + dh nw = w + dw if 0 \u0026lt;= nh \u0026lt; H and 0 \u0026lt;= nw \u0026lt; W and grid[nh][nw] == \u0026#34;1\u0026#34; and (nh, nw) not in has_visited: dfs(h + dh, w + dw) for h in range(H): for w in range(W): if (h, w) in has_visited or grid[h][w] == \u0026#34;0\u0026#34;: continue ans += 1 dfs(h, w) return ans  38: Reverse Linked List  ç­”ãˆ é…ã„ï¼\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -\u0026gt; ListNode: if head is None: return None if head.next is None: return ListNode(val=head.val) reversed_head = self.reverseList(head.next) reversed_tail = reversed_head while reversed_tail.next is not None: reversed_tail = reversed_tail.next reversed_tail.next = ListNode(val=head.val) return reversed_head è³¢ãï¼\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -\u0026gt; ListNode: if head is None or head.next is None: return head reversed_head = self.reverseList(head.next) head.next.next = head head.next = None return reversed_head ç¹°ã‚Šè¿”ã—ã§ï¼\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -\u0026gt; ListNode: prev = None curr = head while curr is not None: tmp = curr.next curr.next = prev prev = curr curr = tmp return prev  39: Minimum Size Subarray Sum  ç­”ãˆ åŠ›æŠ€ãªã‚‰éƒ¨åˆ†åˆ—ã‚’å…¨éƒ¨å–ã£ã¦è¨ˆç®—ã™ã‚‹ã®ã§$O(n^3)$ã§é–“ã«åˆã‚ãªã„ï¼\nç´¯ç©å’Œã‚’ä½¿ã£ã¦éƒ¨åˆ†åˆ—ã®å’Œã‚’$O(1)$ã§æ±‚ã‚ã¦å…¨ä½“ã§$O(n^2)$ï¼ãŸã ã“ã‚Œã ã¨ Python ã ã¨é–“ã«åˆã‚ãªã„ï¼\nclass Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: accum = [nums[0]] for num in nums[1:]: accum.append(accum[-1] + num) ans = 10 ** 9 for i in range(0, len(nums), 1): for j in range(i, len(nums), 1): added = accum[j] - accum[i] + nums[i] if target \u0026lt;= added: ans = min(ans, (j - i + 1)) return ans if ans != 10 ** 9 else 0 éƒ¨åˆ†å’Œã®å¤§ãã•ã«ã¤ã„ã¦ï¼Œéƒ¨åˆ†åˆ—ã®é•·ã•ãŒé•·ããªã‚Œã°ãªã‚‹ã»ã©éƒ¨åˆ†å’Œã¯å˜èª¿ã«å¢—åŠ ã™ã‚‹ã®ã§ï¼Œtargetä»¥ä¸Šã¨ãªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯äºŒåˆ†æ¢ç´¢ã§æ¢ã›ã‚‹ï¼å…¨ä½“ã¨ã—ã¦ã¯$O(n \\log n)$\nclass Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: accum = [nums[0]] for num in nums[1:]: accum.append(accum[-1] + num) def is_ok(lst, mid, key): if key \u0026lt;= lst[mid]: return True return False def binary_search(lst, key): ng = -1 ok = len(lst) while 1 \u0026lt; abs(ok - ng): mid = (ok + ng) // 2 if is_ok(lst, mid, key): ok = mid else: ng = mid return ok ans = 10 ** 9 for i in range(0, len(nums), 1): accum_j = target + accum[i] - nums[i] j = binary_search(accum[i:], accum_j) + i if j == len(accum): continue ans = min(ans, (j - i + 1)) return ans if ans != 10 ** 9 else 0 ã‚‚ã£ã¨è³¢ã„ã‚„ã‚Šæ–¹ãŒã‚ã‚‹ï¼éƒ¨åˆ†åˆ—ã®å’Œã¯ï¼Œã€Œéƒ¨åˆ†åˆ—ãŒé•·ã‘ã‚Œã°é•·ã„ã»ã©å¤§ãããªã‚‹ã€ã®ã§ï¼Œä¸€åº¦éƒ¨åˆ†åˆ—ã®å’ŒãŒtargetä»¥ä¸Šã«ãªã£ãŸã‚‰ãã‚Œä»¥ä¸Šãã®éƒ¨åˆ†åˆ—ã‚’ä¼¸ã°ã—ã¦æ¢ã—ã¦ã‚‚ç­”ãˆã«é–¢ä¿‚ãªã„ï¼éƒ¨åˆ†åˆ—ã®æœ«ç«¯ã®ä½ç½®ãŒæ—©ã€…ã«ç¢ºå®šã§ãã‚‹ã®ã§ï¼Œéƒ¨åˆ†åˆ—ã®å…ˆé ­ã‚’å›ã™ã ã‘ã§æ±‚ã¾ã‚‹ï¼$O(n)$ï¼ã“ã‚Œã¯ä¸–ã®ä¸­ã§ã¯å°ºå–æ³•ã¨å‘¼ã°ã‚Œã¦ã„ã‚‹ãã†ã ï¼è‹±èªã§ã¯ sliding window ã¨å‘¼ã°ã‚Œã¦ã„ã‚‹ã®ã‹ï¼Ÿ\nclass Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: ans = float(\u0026#34;inf\u0026#34;) left = 0 accum = 0 for right in range(len(nums)): accum += nums[right] while target \u0026lt;= accum: ans = min(ans, right - left + 1) accum -= nums[left] left += 1 return ans if ans != float(\u0026#34;inf\u0026#34;) else 0  40: House Robber II  ç­”ãˆ nums[0]ã¨nums[-1]ã‚’åŒæ™‚ã«è¥²ãˆãªã„ã®ã§ï¼Œnums[1:]ã‚’å¯¾è±¡ã«ã—ãŸã¨ãã¨nums[:-1]ã‚’å¯¾è±¡ã«ã—ãŸã¨ãã‚’åˆ¥å€‹ã«è¨ˆç®—ã—ã¦å¤§ãã„æ–¹ã‚’å–ã‚Œã°ã„ã„ï¼\nclass Solution: def rob(self, nums: List[int]) -\u0026gt; int: if len(nums) \u0026lt; 3: return max(nums) def _rob(nums): # dp[i]: nums[:i+1]ã¾ã§ã§ç›—ã‚ã‚‹ãŠé‡‘ã®æœ€å¤§å€¤ if len(nums) \u0026lt; 3: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) return dp[len(nums) - 1] return max(_rob(nums[1:]), _rob(nums[:len(nums) - 1]))  41: Meeting Rooms è¤‡æ•°ã® MTG ã®é–‹å§‹æ™‚åˆ»ã¨çµ‚äº†æ™‚åˆ»ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ãï¼Œå…¨ã¦ã® MTG äºˆå®šãŒãƒ€ãƒ–ã‚‰ãªã„ã‹ã©ã†ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼\n ç­”ãˆ # Definition for an interval # class Interval(object): # def __init__(self, s=0, e=0): # self.start = s # self.end = e class Solution: def canAttendMeetings(self, intervals: List[Interval]) -\u0026gt; bool: intervals.sort(key=lambda x: x.start) for i in range(0, len(intervals) - 1, 1): if intervals[i].end \u0026gt; intervals[i + 1].start: return False return True  42: Meeting Rooms II è¤‡æ•°ã® MTG ã®é–‹å§‹æ™‚åˆ»ã¨çµ‚äº†æ™‚åˆ»ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ãï¼Œå¿…è¦æœ€å°é™ã® MTG éƒ¨å±‹ã®æ•°ã‚’è¨ˆç®—ã›ã‚ˆï¼\n ç­”ãˆ # Definition for an interval # class Interval(object): # def __init__(self, s=0, e=0): # self.start = s # self.end = e class Solution: def minMeetingRooms(self, intervals: List[Interval]) -\u0026gt; int: intervals.sort(key=lambda x: x.start) heap = [] for mtg in intervals: if len(heap) != 0 and heap[0] \u0026lt;= mtg.start: heapq.heappop(heap) heapq.heappush(heap, mtg.end) else: heapq.heappush(heap, mtg.end) return len(heap)  43: Paint Fence $N$æœ¬ã®æŸ±ã‚’$K$è‰²ã§å¡—ã‚Šåˆ†ã‘ã‚‹ï¼ã“ã®ã¨ãï¼Œé€£ç¶šã—ã¦åŒã˜è‰²ã®æŸ±ã¯$2$æœ¬ã‚ˆã‚Šå¤šããªã£ã¦ã¯ãªã‚‰ãªã„ï¼å¡—ã‚Šåˆ†ã‘æ–¹ã®ç·æ•°ã‚’æ±‚ã‚ã‚ˆï¼\n ç­”ãˆ æŸ±ã‚’å·¦ã‹ã‚‰å³ã«å¡—ã£ã¦ã„ãã“ã¨ã‚’è€ƒãˆã‚‹ï¼å·¦ã‹ã‚‰pos - 2ï¼Œpos - 1ï¼Œposã®ä½ç½®ã«ã‚ã‚‹æŸ±ã®è‰²ã®å¡—ã‚Šæ–¹ã¯\n ã€Œpos - 2ï¼Œpos - 1ãŒé€£ç¶šã—ã¦åŒã˜è‰² Xï¼ŒposãŒ X ä»¥å¤–ã€ã§posã«ä½¿ãˆã‚‹è‰²ã¯$K - 1$è‰² ã€Œpos - 2ãŒè‰² Xï¼Œpos - 1ï¼ŒposãŒé€£ç¶šã—ã¦ X ä»¥å¤–ã®è‰²ã€ã§posã«ä½¿ãˆã‚‹è‰²ã¯$K - 1$è‰²  class Solution: def numWays(self, n: int, k: int) -\u0026gt; int: if n == 1: return k if n == 2: reteurn k ** 2 # dp[i]: å·¦ã‹ã‚‰iç•ªç›®ã¾ã§ã®æŸ±ã®å¡—ã‚Šåˆ†ã‘æ–¹ dp = [0, k, k ** 2] for i in range(2, n): dp += [(dp[-2] + dp[-1]) * (k - 1)] return dp[n]  44: Move Zeroes  ç­”ãˆ class Solution: def moveZeroes(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; last_non_zero_at = 0 for i in range(0, len(nums), 1): if nums[i] != 0: nums[last_non_zero_at], nums[i] = nums[i], nums[last_non_zero_at] last_non_zero_at += 1 é$0$è¦ç´ ã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆã¨ã„ã†ã‚„ã‚Šæ–¹ã§ã‚‚ã„ã„ï¼\nclass Solution: def moveZeroes(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; non_zero = 0 for num in nums: if num != 0: nums[non_zero] = num non_zero += 1 for i in range(non_zero, len(nums)): nums[i] = 0  45: Longest Increasing Subsequence  ç­”ãˆ åŠ›æŠ€ã§ã‚„ã‚‹ãªã‚‰å…¨ã¦ã®éƒ¨åˆ†åˆ—ã‚’å–ã‚Šä¸Šã’ã¦é•·ã•ã®æœ€å°å€¤ã‚’æ±‚ã‚ã‚‹ï¼$O(2^n)$ï¼\nå†å¸°ã‚’ä½¿ã£ã¦å…¨æ¢ç´¢ï¼å½“ç„¶ TLEï¼\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: def check(seq): for i in range(0, len(seq)-1, 1): if seq[i] \u0026gt;= seq[i+1]: return False return True lens = [] def _recurse(pos, seq): if pos == len(nums): if check(seq): lens.append(len(seq)) return _recurse(pos + 1, seq) _recurse(pos + 1, seq + [nums[pos]]) _recurse(0, []) return max(lens) bit å…¨æ¢ç´¢ï¼ã“ã‚Œã‚‚å½“ç„¶ TLEï¼\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: def check(seq): for i in range(0, len(seq)-1, 1): if seq[i] \u0026gt;= seq[i+1]: return False return True ans = 0 for i in range(1 \u0026lt;\u0026lt; len(nums)): seq = [] for j in range(len(nums)): if i \u0026amp; (1 \u0026lt;\u0026lt; j): seq.append(nums[j]) if check(seq): ans = max(ans, len(seq)) return ans DP ã§è§£ãã¨$O(n^2)$\ndp[i]ï¼šnums[i]ã§çµ‚ã‚ã‚‹æœ€é•·éƒ¨åˆ†å¢—åŠ åˆ—ã®é•·ã• dp[i]ã¯dp[0]ï¼Œdp[1]ï¼Œdp[2]ï¼Œ\u0026hellip;dp[i-1]ã‚’ä½¿ã£ã¦è¨ˆç®—ã§ãã‚‹ï¼dp[i]ã¯ã€Œnums[i]ãŒnums[j]ä»¥ä¸Šã§ã‚ã‚‹ã‚ˆã†ãªjã®ä¸­ã§ã®æœ€å¤§ã®dp[j]ã« 1 è¶³ã—ãŸã‚‚ã®ã€\nfor j in range(0, i): if nums[j] \u0026lt; nums[i]: dp[i] = max(dp[i], dp[j] + 1) class Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: # dp[i]: nums[i]ã§çµ‚ã‚ã‚‹æœ€å¤§å¢—åŠ éƒ¨åˆ†åˆ—ã®é•·ã• # dp[i] = { # nums[j] \u0026lt; nums[i]ã‚’æº€ãŸã™ã‚ˆã†ãªj(0 \u0026lt; j \u0026lt; i)ã«å¯¾ã—ã¦ # æœ€å¤§ã®dp[j] + 1 # } dp = [0 for _ in range(len(nums))] for i in range(len(nums)): dp[i] = 1 # é•·ã•1ã®å¢—åŠ éƒ¨åˆ†åˆ—ï¼š[nums[i]] for j in range(i): if nums[j] \u0026lt; nums[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) æ·»å­—ã‚’é€†è»¢ã•ã›ãŸ DP ã‚’è€ƒãˆã‚‹ã¨$O(n \\log n)$ã§è§£ã‘ã‚‹ï¼\ndp[i]ï¼šé•·ã•i + 1ã®å¢—åŠ éƒ¨åˆ†åˆ—ã®å³ç«¯è¦ç´ ã®æœ€å°å€¤ å…¨ã¦ã®éƒ¨åˆ†åˆ—ã‚’å–ã‚Šå‡ºã—ã¦dpã‚’åŸ‹ã‚ãŸã‚ã¨ã®ã“ã¨ã‚’è€ƒãˆã‚‹ã¨ï¼Œdpã¯å˜èª¿ã«å¢—åŠ ã™ã‚‹ã‚ˆã†ãªæ•°åˆ—ã«ãªã£ã¦ã„ã‚‹ã¯ãšï¼ã“ã‚Œã¯åˆ¥ã«å…¨ã¦ã®éƒ¨åˆ†åˆ—ã‚’åˆ—æŒ™ã—çµ‚ã‚ã£ã¦ã‹ã‚‰ã§ãªãã¦ã‚‚ï¼Œè¦ç´ ã‚’ä¸€ã¤ãšã¤è¦‹ã¦æœ€é©ãªdpã®ä½ç½®ã«ç½®ãã“ã¨ã§ã‚‚å¾—ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ã¤ã¾ã‚Šï¼Œè¦ç´ ã‚’ä¸€ã¤ãšã¤è¦‹ãªãŒã‚‰ï¼ŒäºŒåˆ†æ¢ç´¢ã§ãã®è¦ç´ ãŒå…¥ã‚‹ä½ç½®ã‚’æ±‚ã‚ã¦dpã‚’æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: # dp[i]: minimum of the last element of an increasing subsequence which length is i+1 dp = [float(\u0026#34;inf\u0026#34;)] * len(nums) for num in nums: dp[bisect_left(dp, num)] = num return bisect_left(dp, float(\u0026#34;inf\u0026#34;)) äºŒåˆ†æ¢ç´¢ã‚’è‡ªåˆ†ã§å®Ÿè£…ã—ãŸã‚‰ã“ã†ï¼\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: # dp[i]: é•·ã•i+1ã®å¢—åŠ éƒ¨åˆ†åˆ—ã®çµ‚ç«¯è¦ç´ ã®æœ€å°å€¤ dp = [float(\u0026#34;inf\u0026#34;)] * len(nums) def binary_search(nums, key): ok = len(nums) ng = -1 def is_ok(mid): return key \u0026lt;= nums[mid] while 1 \u0026lt; abs(ng - ok): mid = (ng + ok) // 2 if is_ok(mid): ok = mid else: ng = mid return ok for num in nums: dp[binary_search(dp, num)] = num return binary_search(dp, float(\u0026#34;inf\u0026#34;))  46: Coin Change  ç­”ãˆ class Solution: def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: # dp[i][j]: iç•ªç›®ã¾ã§ã®ã‚³ã‚¤ãƒ³ã‚’ä½¿ã£ã¦jå††ã‚’å®Ÿç¾ã™ã‚‹ã¨ãã®æœ€å°æšæ•° # dp[i][j] = min(dp[i-1][j], dp[i][j-coins[i]] + 1) coins = [-1] + coins INF = 10 ** 9 dp = [[INF for _ in range(amount + 1)] for _ in range(len(coins))] for i in range(len(coins)): dp[i][0] = 0 for i in range(1, len(coins)): for j in range(amount + 1): if 0 \u0026lt;= j-coins[i]: dp[i][j] = min(dp[i-1][j], dp[i][j-coins[i]] + 1) else: dp[i][j] = dp[i-1][j] return dp[-1][-1] if dp[-1][-1] != INF else -1 DP é…åˆ—ã¯äºŒæ¬¡å…ƒã§ãªãã¦ã‚‚å¤§ä¸ˆå¤«ã ã£ãŸï¼\nclass Solution: def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: # dp[i]: iå††æ”¯æ‰•ã†ã¨ãã®æœ€å°æšæ•° dp = [float(\u0026#39;inf\u0026#39;) for _ in range(amount+1)] dp[0] = 0 for i in range(1, amount+1): dp[i] = min([dp[i-coin] if 0 \u0026lt;= i-coin else float(\u0026#39;inf\u0026#39;) for coin in coins]) + 1 return dp[amount] if dp[amount] != float(\u0026#39;inf\u0026#39;) else -1  47: Number of Connected Components in an Undirected Graph  ç­”ãˆ å•é¡Œæ–‡ãŒè¦‹ã‚Œãªã„ã®ã§æ¨™æº–å…¥åŠ›çµŒç”±ã§ã‚°ãƒ©ãƒ•ã‚’å…¥åŠ›ã•ã‚ŒãŸã¨æƒ³å®šã—ã¦è§£ãï¼ã‚ã‚‹é ‚ç‚¹ã‹ã‚‰å§‹ã‚ã‚‹ DFS ã‚’ï¼æœªè¨ªå•ã®é ‚ç‚¹ãŒãªããªã‚‹ã¾ã§ç¹°ã‚Šè¿”ã™ï¼\n# graph: # 0 # / | \\ # 1--2 3 # | \\ # 4 6 # 5--7 N, M = map(int, input().split()) G = [[] for _ in range(N)] for _ in range(M): u, v = map(int, input().split()) G[u].append(v) G[v].append(u) def connected_component(graph): cc = 0 has_visited = set() for n in range(len(graph)): if n not in has_visited: cc += 1 suspended = [n] while len(suspended) != 0: u = suspended.pop() if u in has_visited: continue has_visited.add(u) for v in graph[u]: suspended.append(v) return cc print(connected_component(G))  48: Top K Frequent Elements å¤§ãã„é †ã«$K$å€‹ï¼Œå°ã•ã„é †ã«$K$å€‹ã¯è‰²ã€…ã‚„ã‚Šæ–¹ãŒã‚ã‚‹ï¼æ‹™è‘—ã¯ã“ã¡ã‚‰\n ç­”ãˆ ç´ ç›´ã«æ›¸ã„ã¦ã‚‚é€šã‚‹ï¼\nclass Solution: def topKFrequent(self, nums: List[int], k: int) -\u0026gt; List[int]: table = dict() for num in nums: if num in table: table[num] += 1 else: table[num] = 0 ordered = list(table.items()) ordered.sort(key=lambda x: x[1], reverse=True) return [x[0] for x in ordered[:k]] heapq.nlargestã‚’ä½¿ã†ï¼\nclass Solution: def topKFrequent(self, nums: List[int], k: int) -\u0026gt; List[int]: cnt = [(freq, num) for num, freq in Counter(nums).items()] return [num for _, num in heapq.nlargest(k, cnt)] ã“ã®å•é¡ŒãŒå¾©ç¿’ã«ãªã‚‹ï¼\n 49: Intersection of Two Arrays python ãŒå‰ã„ï¼\n ç­”ãˆ class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: return list(set(nums1).intersection(set(nums2)))  50: Find K Pairs with Smallest Sums  ç­”ãˆ åŠ›æŠ€ 1ï¼šãƒ†ãƒ¼ãƒ–ãƒ«å…¨éƒ¨è¨ˆç®—ã™ã‚‹ï¼\nclass Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; List[List[int]]: return sorted(itertools.product(nums1, nums2), key=sum)[:k] åŠ›æŠ€ 2ï¼šãƒ†ãƒ¼ãƒ–ãƒ«å…¨éƒ¨è¨ˆç®—ã™ã‚‹ï¼\nclass Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; List[List[int]]: return map(list, sorted(itertools.product(nums1, nums2), key=sum)[:k]) åŠ›æŠ€ 3ï¼šgenerator ã‚’ä½¿ã£ã¦å¿…è¦ãªåˆ†ã ã‘è¨ˆç®—ã™ã‚‹ï¼\nclass Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; List[List[int]]: return map(list, heapq.nsmallest(k, itertools.product(nums1, nums2), key=sum)) åŠ›æŠ€ 4ï¼šã“ã‚Œã‚‚ generator\nclass Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; List[List[int]]: return heapq.nsmallest(k, ([u, v] for u in nums1 for v in nums2), key=sum) ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ 1 è¡Œã”ã¨è¨ˆç®—ã™ã‚‹ generator\nclass Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; List[List[int]]: streams = map(lambda u: ([u+v, u, v] for v in nums2), nums1) stream = heapq.merge(*streams) return [ret[1:] for ret in itertools.islice(stream, k)] ãƒ†ãƒ¼ãƒ–ãƒ«ã®å·¦ç«¯ã®æ–¹ã ã‘æ¬²ã—ã„ã¨ã„ã†ã®ã‚’å„ªå…ˆåº¦ä»˜ãã‚­ãƒ¥ãƒ¼ã‚’ä½¿ã£ã¦ã†ã¾ãå®Ÿè£…ã™ã‚‹ï¼\nclass Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; List[List[int]]: queue = [] def push(i, j): if i \u0026lt; len(nums1) and j \u0026lt; len(nums2): heapq.heappush(queue, [nums1[i] + nums2[j], i, j]) push(0, 0) ans = [] while len(queue) != 0 and len(ans) \u0026lt; k: _, i, j = heapq.heappop(queue) ans.append([nums1[i], nums2[j]]) push(i, j + 1) if j == 0: push(i + 1, j) return ans  51: First Unique Character in a String  ç­”ãˆ class Solution: def firstUniqChar(self, s: str) -\u0026gt; int: for idx, char in enumerate(s): if char in s[:idx] + s[idx+1:]: continue else: return idx return -1  52: Is Subsequence iteråŒ–ã™ã‚‹ã“ã¨ã§ï¼Œè¦‹ã¤ã‹ã‚‹ã¾ã§æ–‡å­—ã‚’åãå‡ºã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚‹ï¼\n ç­”ãˆ class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: t = iter(t) for ch in s: if ch not in t: return False return True class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: t = iter(t) return all(char in t for char in s)  53: Subarray Sum Equals K  ç­”ãˆ åŠ›æŠ€ï¼$O(n^3)$ï¼TLEï¼\nclass Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: ans = 0 for start in range(len(nums)): for end in range(start + 1, len(nums) + 1): subsum = 0 for num in nums[start:end]: subsum += num if subsum == k: ans += 1 return ans ç´¯ç©å’Œã‚’ä½¿ã£ã¦subsumã‚’æ±‚ã‚ã¦$O(n^2)$ï¼TLEï¼\nclass Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: ans = 0 accum = [0] for num in nums: accum += [accum[-1] + num] for start in range(len(nums)): for end in range(start + 1, len(nums) + 1): subsum = accum[end] - accum[start] if subsum == k: ans += 1 return ans subsumã‚’æ±‚ã‚ãªãŒã‚‰æ·»ãˆå­—ã‚’å›ã™ï¼$O(n^2)$ï¼TLEï¼\nclass Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: ans = 0 for start in range(len(nums)): subsum = 0 for end in range(start, len(nums)): subsum += nums[end] if subsum == k: ans += 1 return ans çµå±€éƒ¨åˆ†åˆ—ã®å€‹æ•°ã ã‘ã‚«ã‚¦ãƒ³ãƒˆã—ãŸã„ã®ã§ã‚ã‚Œã°ï¼Œéƒ¨åˆ†åˆ—ã®æœ€åˆã¨æœ€å¾Œã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ã„ã‚‰ãªãã¦ï¼Œåˆè¨ˆãŒã„ãã‚‰ã«ãªã‚‹éƒ¨åˆ†åˆ—ãŒä½•å€‹ã‚ã‚‹ã‹ãŒé‡è¦ï¼\nclass Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: ans = 0 subsum = 0 table = dict() # subsum: freq table[0] = 1 for num in nums: subsum += num if subsum - k in table: ans += table[subsum - k] table[subsum] = table.get(subsum, 0) + 1 return ans  54: Merge Two Binary Trees  ç­”ãˆ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def mergeTrees(self, root1: TreeNode, root2: TreeNode) -\u0026gt; TreeNode: if root1 is None: return root2 if root2 is None: return root1 root1.val += root2.val root1.left = self.mergeTrees(root1.left, root2.left) root1.right = self.mergeTrees(root1.right, root2.right) return root1  55: Max Area of Island  ç­”ãˆ DFS ã§å…¨æ¢ç´¢ï¼\nclass Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -\u0026gt; int: H = len(grid) W = len(grid[0]) dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)] has_visited = set() def traverse(h, w): area = 0 suspended = list() suspended.append((h, w)) while len(suspended) != 0: h_, w_ = suspended.pop() has_visited.add((h_, w_)) area += 1 for (dh, dw) in dirs: nh = h_ + dh nw = w_ + dw if 0 \u0026lt;= nh \u0026lt; H and 0 \u0026lt;= nw \u0026lt; W and (nh, nw) not in has_visited and grid[nh][nw] == 1: has_visited.add((nh, nw)) suspended.append((nh, nw)) return area max_area = 0 for h in range(H): for w in range(W): if grid[h][w] == 1: area = traverse(h, w) max_area = max(max_area, area) return max_area BFS ã§å…¨æ¢ç´¢\nclass Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -\u0026gt; int: H = len(grid) W = len(grid[0]) dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)] has_visited = set() def traverse(h, w): area = 0 suspended = list() suspended.append((h, w)) while len(suspended) != 0: h_, w_ = suspended.pop(0) has_visited.add((h_, w_)) area += 1 for (dh, dw) in dirs: nh = h_ + dh nw = w_ + dw if 0 \u0026lt;= nh \u0026lt; H and 0 \u0026lt;= nw \u0026lt; W and (nh, nw) not in has_visited and grid[nh][nw] == 1: has_visited.add((nh, nw)) suspended.append((nh, nw)) return area max_area = 0 for h in range(H): for w in range(W): if grid[h][w] == 1: area = traverse(h, w) max_area = max(max_area, area) return max_area å†å¸°ã§ DFSï¼å†å¸°é–¢æ•°ã¯åœ°ç‚¹(i, j)ã‚’ç«¯ç‚¹ã¨ã—ãŸåœŸåœ°ã®é¢ç©ã‚’è¿”ã™ï¼ä¸Šä¸‹å·¦å³ã®åœŸåœ°ã¯ã¤ãªãŒã£ã¦ã„ãªã„ã®ã§ä¸Šä¸‹å·¦å³ã‹ã‚‰å§‹ã‚ãŸåœŸåœ°ã®é¢ç©ã®åˆè¨ˆã« 1 è¶³ã›ã°è‰¯ã„ï¼\nclass Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -\u0026gt; int: H = len(grid) W = len(grid[0]) dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)] has_visited = set() def area_from(h, w): if (h \u0026lt; 0 or H \u0026lt;= h) or (w \u0026lt; 0 or W \u0026lt;= w) or (h, w) in has_visited or grid[h][w] == 0: return 0 has_visited.add((h, w)) return 1 + sum(area_from(h + dh, w + dw) for (dh, dw) in dirs) return max(area_from(h, w) for h in range(H) for w in range(W))  56: Kth Largest Element in a Stream å¤§ãã„æ–¹ã‹ã‚‰æ•°ãˆã¦$k$ç•ªç›®ã®è¦ç´ ã¯ï¼Œæ˜‡é †ã«ä¸¦ã¶é•·ã•$k$ã®å„ªå…ˆåº¦ä»˜ãã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ï¼\n ç­”ãˆ class KthLargest: def __init__(self, k: int, nums: List[int]): self.queue = nums self.k = k heapq.heapify(self.queue) while k \u0026lt; len(self.queue): heapq.heappop(self.queue) def add(self, val: int) -\u0026gt; int: if len(self.queue) \u0026lt; self.k: heapq.heappush(self.queue, val) elif self.queue[0] \u0026lt; val: heapq.heappop(self.queue) heapq.heappush(self.queue, val) return self.queue[0] # Your KthLargest object will be instantiated and called as such: # obj = KthLargest(k, nums) # param_1 = obj.add(val)  57: Split BST  ç­”ãˆ class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def splitBST(root, v): inordered = [] def inorder_traverse(root): if root is None: return inorder_traverse(root.left) inordered.append(root.val) inorder_traverse(root.right) inorder_traverse(root) idx = inordered.index(v) def build_bst(i, j): if j \u0026lt; i: return None mid = (i + j) // 2 root = TreeNode(inordered[mid]) root.left = build_bst(i, mid-1) root.right = build_bst(mid+1, j) return root return [build_bst(0, idx), build(idx, len(inordered)-1)]  58: K-th Symbol in Grammar $i+1$è¡Œç›®ã®ãƒ“ãƒƒãƒˆåˆ—$s_{i+1}$ã¯$i$åˆ—ç›®ã®ãƒ“ãƒƒãƒˆåˆ—$s_i$ã¨ãã®ãƒ“ãƒƒãƒˆåè»¢ã—ãŸã‚‚ã®ã‚’é€£çµã—ãŸã‚‚ã®ã«ãªã£ã¦ã„ã‚‹ï¼ã“ã‚Œã‚’ä½¿ã£ã¦çœŸé¢ç›®ã«æ–‡å­—åˆ—ã‚’å…¨éƒ¨æ±‚ã‚ã‚‹ã¨æ™‚é–“ã‹ã‹ã‚‹ï¼$s_{i+1}$ã®å‰åŠã¯$s_i$ã¨åŒã˜ãªã®ã§ï¼Œå•é¡Œã®ã‚µã‚¤ã‚ºã‚’åŠåˆ†ã«ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\n ç­”ãˆ class Solution: def kthGrammar(self, N: int, K: int) -\u0026gt; int: if N == 1: return 0 half = 1 \u0026lt;\u0026lt; (N - 2) if K \u0026lt;= half: return self.kthGrammar(N - 1, K) else: return self.kthGrammar(N - 1, K - half) ^ 1  59: Unique Email Addresses  ç­”ãˆ class Solution: def numUniqueEmails(self, emails: List[str]) -\u0026gt; int: table = dict() for email in emails: (local, domain) = email.split(\u0026#34;@\u0026#34;) local = local.replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;) idx = local.find(\u0026#34;+\u0026#34;) if idx == -1: idx = len(local) local = local[:idx] if domain in table: table[domain].add(local) else: table[domain] = {local} ans = 0 for ls in table.values(): ans += len(list(ls)) return ans +ã®å‡¦ç†ã‚’å…ˆã«ã—ãŸã»ã†ãŒåŠ¹ç‡çš„ã‚‰ã—ã„ï¼\nclass Solution: def numUniqueEmails(self, emails: List[str]) -\u0026gt; int: canonicals = set() for email in emails: (local, domain) = email.split(\u0026#34;@\u0026#34;) local = local.split(\u0026#34;+\u0026#34;)[0].replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;) canonicals.add(local + \u0026#34;@\u0026#34; + domain) return len(canonicals)  60: Capacity To Ship Packages Within D Days  ç­”ãˆ ç„¡é™ã«ç©ã‚ã‚‹èˆ¹ãŒã‚ã‚Œã°ç¢ºå®Ÿã«$D$æ—¥ä»¥å†…ã«é‹ã¹ã‚‹ï¼é€†ã«è¨±å®¹ç©è¼‰é‡ãŒ$0$ãªã‚‰çµ¶å¯¾ã«é‹ã¹ãªã„ï¼ã€Œã‚ã‚‹æ¡ä»¶ã‚’æº€ãŸã™æœ€å°å€¤ã€ã¨æ¥ã‚Œã°ï¼ŒäºŒåˆ†æ¢ç´¢ã®å‡ºç•ªï¼\nclass Solution: def shipWithinDays(self, weights: List[int], D: int) -\u0026gt; int: def is_ok(mid): elapsed = 1 loaded = 0 for weight in weights: loaded += weight if mid \u0026lt; loaded: elapsed += 1 loaded = weight return elapsed \u0026lt;= D ng = max(weights) - 1 # å¸¸ã«æ¡ä»¶ã‚’æº€ãŸã•ãªã„ ok = sum(weights) + 1 # å¸¸ã«æ¡ä»¶ã‚’æº€ãŸã™ while 1 \u0026lt; abs(ng - ok): mid = (ng + ok) // 2 if is_ok(mid): ok = mid else: ng = mid return ok  ","date":1616385276,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616385276,"objectID":"c18cee1f0c9199d9ebe9e647b51b6c06","permalink":"/ja/post/leetcode-60-questions/","publishdate":"2021-03-22T12:54:36+09:00","relpermalink":"/ja/post/leetcode-60-questions/","section":"post","summary":"ã“ã® 60 å•ã‚’ Python ã§è§£ãï¼ 01: Two Sum $O(n^2)$ã§ã¯ãªã„ç­”ãˆã«ã—ãŸã„ã®ã§ï¼Œã©ã†ã™ã‚‹ã‹ï¼ ç­”ãˆ class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: table = dict() for idx, num in enumerate(nums): complement = target - num if complement in table.keys(): return","tags":["leetcode","python"],"title":"Leetcode 60 Questions","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ äºŒåˆ†æœ¨ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œæœ€å°ã®æ·±ã•ã‚’æ±‚ã‚ã‚ˆï¼\nç­”ãˆ class BinaryTreeNode: def __init__(self, key): self.key = key self.right = None self.left = None def minimum_depth(root): # base case if root is None: return 0 if root.left is not None and root.right is not None: return min(minimum_depth(root.left), minimum_depth(root.right)) + 1 elif root.left is None and root.right is not None: return minimum_depth(root.right) + 1 elif root.left is not None and root.right is None: return minimum_depth(root.left) + 1 else: # root.left is None and root.right is None return 1 ","date":1616325860,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616325860,"objectID":"2b373208cb0d3c55a118d80e365d307b","permalink":"/ja/post/minimum-depth-of-binary-tree/","publishdate":"2021-03-21T20:24:20+09:00","relpermalink":"/ja/post/minimum-depth-of-binary-tree/","section":"post","summary":"å•é¡Œ äºŒåˆ†æœ¨ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œæœ€å°ã®æ·±ã•ã‚’æ±‚ã‚ã‚ˆï¼ ç­”ãˆ class BinaryTreeNode: def __init__(self, key): self.key = key self.right = None self.left = None def minimum_depth(root): # base case if root is None: return 0 if root.left is not None and root.right is not None: return min(minimum_depth(root.left), minimum_depth(root.right)) + 1 elif root.left is None","tags":[],"title":"Minimum Depth of Binary Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé…åˆ—lstã¨å€¤xãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œå’ŒãŒxã«æœ€ã‚‚è¿‘ããªã‚‹ 2 è¦ç´ ã®ãƒšã‚¢ã‚’lstã‹ã‚‰æ±‚ã‚ã‚ˆï¼\nç­”ãˆ åŸç†çš„ã«ã¯$O(n^2)$ã§è§£ã‘ã‚‹ãŒï¼ŒlstãŒæ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ã†ã¾ãä½¿ãˆã°$O(n)$ã§è§£ã‘ã‚‹ï¼\n $O(n^2)$  def solve(lst, x): diff = 10 ** 9 ans = (-1, -1) for i in range(len(lst)): for j in range(i+1, len(lst), 1): if abs(x - (lst[i] + lst[j])) \u0026lt; diff: diff = abs(x - (lst[i] + lst[j])) ans = (lst[i], lst[j]) return ans  $O(n)$  def solve(lst, x): diff = 10 ** 9 ans = (-1, -1) low = 0 high = len(lst) - 1 while low \u0026lt; high: s = lst[low] + lst[high] if abs(x - s) \u0026lt; diff: ans = (lst[low], lst[high]) diff = abs(x - s) if s \u0026lt; x: low += 1 else: high -= 1 return ans ","date":1616314461,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616314461,"objectID":"7aa86252723463524ab369205d2fdd3b","permalink":"/ja/post/closest-pair-from-sorted-list/","publishdate":"2021-03-21T17:14:21+09:00","relpermalink":"/ja/post/closest-pair-from-sorted-list/","section":"post","summary":"å•é¡Œ æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé…åˆ—lstã¨å€¤xãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œå’ŒãŒxã«æœ€ã‚‚è¿‘ããªã‚‹ 2 è¦ç´ ã®ãƒšã‚¢ã‚’lstã‹ã‚‰æ±‚ã‚ã‚ˆï¼ ç­”ãˆ åŸç†çš„ã«ã¯$O(n^2)$ã§","tags":[],"title":"Closest Pair From Sorted List","type":"post"},{"authors":[],"categories":[],"content":"åŸºæœ¬çš„ãªã‚½ãƒ¼ãƒˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å¾©ç¿’\nBubble Sort éš£ã‚Šåˆã†è¦ç´ åŒå£«ã®æ¯”è¼ƒã‚’ç¹°ã‚Šè¿”ã™ã“ã¨ã§ï¼Œæœ€å¤§è¦ç´ ã‚’é †æ¬¡ç¢ºå®šã•ã›ã¦ã„ãï¼\ndef bubble_sort(lst): for idx in range(len(lst) - 1, 0, -1): for j in range(0, idx, 1): if lst[j+1] \u0026lt; lst[j]: lst[j], lst[j+1] = lst[j+1], lst[j] return lst Insertion Sort ãƒˆãƒ©ãƒ³ãƒ—ã‚²ãƒ¼ãƒ ã§æ‰‹æœ­ã‚’ã‚½ãƒ¼ãƒˆã™ã‚‹ã¨ãã‚’ã‚¤ãƒ¡ãƒ¼ã‚¸ã™ã‚‹ï¼å·¦ã®ã‚«ãƒ¼ãƒ‰ã‹ã‚‰ï¼Œãã®ã‚«ãƒ¼ãƒ‰ãŒæŒ¿å…¥ã•ã‚Œã‚‹ã¹ãä½ç½®ã‚’æ¢ã—å‡ºã—ã¦ãã“ã«æŒ¿ã‚Œã‚‹ï¼ã‚«ãƒ¼ãƒ‰ã‚’ç§»å‹•ã—ãªãŒã‚‰æŒ¿å…¥ä½ç½®ã‚’æ¢ã™ï¼\ndef insertion_sort(lst): for i in range(0, len(lst), 1): key = lst[i] j = i - 1 while -1 \u0026lt; j and key \u0026lt; lst[j]: lst[j+1] = lst[j] j -= 1 lst[j+1] = key return lst Merge Sort åˆ†å‰²çµ±æ²»æ³•ï¼\ndef merge_sort(lst): return _merge_sort(lst, 0, len(lst)-1) def _merge_sort(lst, left, right): if left == right: return [lst[left]] middle = (left + right) // 2 lhs = _merge_sort(lst, left, middle) rhs = _merge_sort(lst, middle+1, right) return __merge(lhs, rhs) def __merge(a, b): ret = [] i = 0 j = 0 while i \u0026lt; len(a) and j \u0026lt; len(b): if a[i] \u0026lt; b[j]: ret.append(a[i]) i += 1 else: ret.append(b[j]) j += 1 if i \u0026lt; len(a): ret += a[i:] else: ret += b[j:] return ret Heap Sort ãƒ’ãƒ¼ãƒ—ã‚’ä½¿ã£ã¦æœ€å¤§å€¤ã‚’èª¿ã¹ç¶šã‘ã‚‹ã“ã¨ã§ã‚½ãƒ¼ãƒˆã™ã‚‹ï¼\ndef heap_sort(lst): for i in range(len(lst)-1, 0, -1): _heapify(lst, 0, i) lst[0], lst[i] = lst[i], lst[0] return lst def _heapify(lst, left, right): parent = (left + right) // 2 while parent != -1: left_child = 2 * parent + 1 right_child = 2 * parent + 2 if right \u0026lt; left_child: # no child pass elif right \u0026lt; right_child: # only left child if lst[parent] \u0026lt; lst[left_child]: lst[parent], lst[left_child] = lst[left_child], lst[parent] else: # both child largest = right_child if lst[left_child] \u0026lt; lst[right_child] else left_child if lst[parent] \u0026lt; lst[largest]: lst[parent], lst[largest], lst[largest], lst[parent] parent -= 1 Quick Sort åˆ†å‰²çµ±æ²»æ³•ï¼\ndef quick_sort(lst): # base case if len(lst) == 0: return [] pivot = lst[0] # better strategy exists left = [] # less than pivot right = [] # more than pivot counter = 0 # number of elements that equal to pivot for ele in lst: if ele \u0026lt; pivot: left.append(ele) elif ele == pivot: counter += 1 else: # pivot \u0026lt; ele right.append(ele) left = quick_sort(left) right = quick_sort(right) return left + [pivot] * counter + right ","date":1616300773,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616300773,"objectID":"0bda1d507c35927975823d924db6664e","permalink":"/ja/post/sort-algorithms/","publishdate":"2021-03-21T13:26:13+09:00","relpermalink":"/ja/post/sort-algorithms/","section":"post","summary":"åŸºæœ¬çš„ãªã‚½ãƒ¼ãƒˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å¾©ç¿’ Bubble Sort éš£ã‚Šåˆã†è¦ç´ åŒå£«ã®æ¯”è¼ƒã‚’ç¹°ã‚Šè¿”ã™ã“ã¨ã§ï¼Œæœ€å¤§è¦ç´ ã‚’é †æ¬¡ç¢ºå®šã•ã›ã¦ã„ãï¼ def bubble_sort(lst): for idx in range(len(lst) - 1, 0, -1): for j in range(0, idx, 1): if","tags":[],"title":"Sort Algorithms","type":"post"},{"authors":[],"categories":[],"content":"ä½•ã‚‚è¦‹ãªã„ã§ Dijkstra æ³•ã‚’æ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚ŠãŸã„ ä½•ã‚‚è¦‹ãªã„ã§ Dijkstra æ³•ã‚’æ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚ŠãŸã„ï¼Œã®ã§ï¼Œç·´ç¿’ã™ã‚‹ï¼ ã¨ã„ã£ã¦ã‚‚ãŸã ãŸã æš—è¨˜ã™ã‚‹ã®ã¯å¿œç”¨ãŒåŠ¹ã‹ãªã„ã®ã§ï¼ŒDFSãƒ»BFS ã¨æ¯”è¼ƒã—ã¦è¦šãˆã‚‹ã“ã¨ã«ã™ã‚‹ï¼\nã‚°ãƒ©ãƒ•ä¸Šã®æ¢ç´¢ã®ä¸€èˆ¬å½¢ ã€Œç™ºè¦‹ã—ãŸã‘ã©ã¾ã æœªè¨ªå•ã€ã®é ‚ç‚¹ãƒªã‚¹ãƒˆã‹ã‚‰æ¬¡ã«è¨ªå•ã™ã‚‹é ‚ç‚¹ã®é¸ã³æ–¹ã®é•ã„ã«ã‚ˆã£ã¦æ€§æ ¼ãŒå¤‰ã‚ã‚‹ï¼\ndef traversal(graph, start, select_func): has_visited = set() suspended = list() has_visited.add(start) suspended.append(start) while len(suspended) != 0: u = select_func(suspended) # ã“ã“ã§æ¢ç´¢ã®æ€§æ ¼ãŒæ±ºã¾ã‚‹ has_visited.add(u) for v in graph[u]: if v in has_visited: continue else: suspended.append(v) select_funcã§suspendedã‚’ stack ã¿ãŸã„ã«æ‰±ã†ã¨ DFSï¼ select_funcã§suspendedã‚’ queue ã¿ãŸã„ã«æ‰±ã†ã¨ BFSï¼\nsuspendedã‚’å„ªå…ˆåº¦ä»˜ãã‚­ãƒ¥ãƒ¼ã¨ã—ã¦æ‰±ãˆã° Dijkstra æ³• from heapq from heappush, heappop INF = 10 ** 9 def dijkstra(graph, start): has_visited = set() suspended = list() dist = [INF for _ in range(N)] has_visited.add(start) suspended.append((0, start)) dist[start] = 0 while len(suspended) != 0: d, u = heappop(suspended) # suspendedã‚’å„ªå…ˆåº¦ä»˜ãã‚­ãƒ¥ãƒ¼ã¨ã—ã¦æ‰±ã† has_visited.add(u) for (v, cost) in graph[u]: if v not in has_visited and dist[u] + cost \u0026lt; dist[v]: dist[v] = dist[u] + cost heappush(suspended, (dist[v], v)) return dist ã¤ã„ã§ã« Prim æ³• æœ€å°å…¨åŸŸæœ¨ã‚’è¨ˆç®—ã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼é ‚ç‚¹ä¸€ã¤ã‹ã‚‰ãªã‚‹æœ¨ã‹ã‚‰å§‹ã‚ã¦ï¼Œæœ¨ã«å«ã¾ã‚Œã¦ã„ãªã„é ‚ç‚¹ã¨æœ¨ã«å«ã¾ã‚Œã‚‹é ‚ç‚¹ã‚’çµã¶è¾ºã®ã†ã¡ï¼Œé‡ã•ã®æœ€å°ã®ã‚‚ã®ã‚’æ¡ç”¨ã—æœ¨ã«å«ã¾ã‚Œã‚‹é ‚ç‚¹ã‚’å¢—ã‚„ã™ï¼Œã¨ã„ã†ã“ã¨ã‚’ç¹°ã‚Šè¿”ã™ï¼Dijkstra æ³•ã«é›°å›²æ°—ä¼¼ã¦ã„ã‚‹ï¼\nfrom heapq import heapify, heappush, heappop def prim(graph): has_used = set() has_used.add(0) suspended = [(cost, 0, v) for v, cost in graph[0]] heapify(suspended) mst = [] mst_weight = 0 while len(suspended) != 0: cost, u, v = heappop(suspended) if u in has_used and v in has_used: continue has_used.add(u) has_used.add(v) mst.append((u, v)) mst_weight += cost for w, cost in graph[u]: if w in has_used: continue heappush(suspended, (cost, u, w)) for w, cost in graph[v]: if w in has_used: continue heappush(suspended, (cost, v, w)) suspended = list(set(suspended)) heaepify(suspended) return mst, mst_weight ","date":1616246827,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616246827,"objectID":"eda99d67bf0495fbcad11e95ae90fea0","permalink":"/ja/post/dijkstra-algorithm/","publishdate":"2021-03-20T22:27:07+09:00","relpermalink":"/ja/post/dijkstra-algorithm/","section":"post","summary":"ä½•ã‚‚è¦‹ãªã„ã§ Dijkstra æ³•ã‚’æ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚ŠãŸã„ ä½•ã‚‚è¦‹ãªã„ã§ Dijkstra æ³•ã‚’æ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚ŠãŸã„ï¼Œã®ã§ï¼Œç·´ç¿’ã™ã‚‹ï¼ ã¨ã„ã£ã¦ã‚‚ãŸã ãŸã æš—è¨˜ã™ã‚‹ã®ã¯å¿œç”¨ãŒåŠ¹ã‹ãªã„ã®","tags":[],"title":"Dijkstra Algorithm","type":"post"},{"authors":[],"categories":[],"content":"äºŒåˆ†æ¢ç´¢æœ¨ äºŒåˆ†æœ¨ã®ä¸­ã§ã‚‚ï¼Œå·¦ã®å­ä¾› \u0026lt;= è‡ªåˆ† \u0026lt; å³ã®å­ä¾›ã¨ãªã£ã¦ã„ã‚‹ã‚ˆã†ãªæœ¨ï¼\né ‚ç‚¹ã®æŒ¿å…¥é †åºã«ã‚ˆã£ã¦å‡ºæ¥ä¸ŠãŒã‚‹æœ¨ã¯è¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ã‚‹ï¼\nå®Ÿè£… class BinarySearchTreeNode: def __init__(self, key): self.key = key self.right = None self.left = None def insert(self, key): if self.key == key: return if self.key \u0026lt; key: if self.right is None: self.right = BinarySearchTreeNode(key) else: self.right.insert(key) else: # key \u0026lt; self.key: if self.left is None: self.left = BinarySearchTreeNode(key) else: self.left.insert(key) # ref: https://stackoverflow.com/questions/34012886/print-binary-tree-level-by-level-in-python def display(self): lines, *_ = self._display() for line in lines: print(line) def _display(self): \u0026#34;\u0026#34;\u0026#34;Returns list of strings, width, height, and horizontal coordinate of the root.\u0026#34;\u0026#34;\u0026#34; # No child. if self.right is None and self.left is None: line = \u0026#39;%s\u0026#39; % self.key width = len(line) height = 1 middle = width // 2 return [line], width, height, middle # Only left child. if self.right is None: lines, n, p, x = self.left._display() s = \u0026#39;%s\u0026#39; % self.key u = len(s) first_line = (x + 1) * \u0026#39; \u0026#39; + (n - x - 1) * \u0026#39;_\u0026#39; + s second_line = x * \u0026#39; \u0026#39; + \u0026#39;/\u0026#39; + (n - x - 1 + u) * \u0026#39; \u0026#39; shifted_lines = [line + u * \u0026#39; \u0026#39; for line in lines] return [first_line, second_line] + shifted_lines, n + u, p + 2, n + u // 2 # Only right child. if self.left is None: lines, n, p, x = self.right._display() s = \u0026#39;%s\u0026#39; % self.key u = len(s) first_line = s + x * \u0026#39;_\u0026#39; + (n - x) * \u0026#39; \u0026#39; second_line = (u + x) * \u0026#39; \u0026#39; + \u0026#39;\\\\\u0026#39; + (n - x - 1) * \u0026#39; \u0026#39; shifted_lines = [u * \u0026#39; \u0026#39; + line for line in lines] return [first_line, second_line] + shifted_lines, n + u, p + 2, u // 2 # Two children. left, n, p, x = self.left._display() right, m, q, y = self.right._display() s = \u0026#39;%s\u0026#39; % self.key u = len(s) first_line = (x + 1) * \u0026#39; \u0026#39; + (n - x - 1) * \u0026#39;_\u0026#39; + s + y * \u0026#39;_\u0026#39; + (m - y) * \u0026#39; \u0026#39; second_line = x * \u0026#39; \u0026#39; + \u0026#39;/\u0026#39; + (n - x - 1 + u + y) * \u0026#39; \u0026#39; + \u0026#39;\\\\\u0026#39; + (m - y - 1) * \u0026#39; \u0026#39; if p \u0026lt; q: left += [n * \u0026#39; \u0026#39;] * (q - p) elif q \u0026lt; p: right += [m * \u0026#39; \u0026#39;] * (p - q) zipped_lines = zip(left, right) lines = [first_line, second_line] + [a + u * \u0026#39; \u0026#39; + b for a, b in zipped_lines] return lines, n + m + u, max(p, q) + 2, n + u // 2 é«˜ã•ãŒæœ€å°ã®äºŒåˆ†æ¢ç´¢æœ¨ æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸkeyã®é…åˆ—ã‚’æ¸¡ã•ã‚ŒãŸã¨ãã«ï¼Œãã‚Œã‚‰ã‚’æ ¼ç´ã™ã‚‹äºŒåˆ†æ¢ç´¢æœ¨ã®ã†ã¡æœ€ã‚‚é«˜ã•ã®å°ã•ã„ã‚‚ã®ã‚’ä½œã‚‹ï¼\nè€ƒãˆæ–¹ã¨ã—ã¦ã¯ï¼Œé«˜ã•ãŒæœ€å°ã«ãªã‚‹ã¨ãï¼Œå·¦å³ã®æœ¨ã®é«˜ã•ãŒç­‰ã—ã„ã®ã§ï¼Œkeyã®çœŸã‚“ä¸­ãã‚‰ã„ã®å¤§ãã•ã®ã‚‚ã®ã‹ã‚‰æ ¼ç´ã—ã¦ã„ãã¨ã§ããã†ã¨ã„ã†æ„Ÿã˜ï¼\ndef build_minimum_height_bst(keys): return _build_minimum_height_bst(keys, 0, len(keys) - 1) def _build_minimum_height_bst(keys, start, end): if end \u0026lt; start: return None middle = (start + end) // 2 root = BinarySearchTreeNode(keys[middle]) root.left = _build_minimum_height_bst(keys, start, middle - 1) root.right = _build_minimum_height_bst(keys, middle + 1, end) return root æ·±ã•ã”ã¨ã®keyã®ãƒªã‚¹ãƒˆ äºŒåˆ†æ¢ç´¢æœ¨ã‹ã‚‰[ [æ·±ã•0ã®keyã®ãƒªã‚¹ãƒˆ], [æ·±ã•1ã®keyã®ãƒªã‚¹ãƒˆ], ...]ã‚’ä½œã‚‹ï¼äºŒåˆ†æ¢ç´¢æœ¨ã‚’æ¨ªä¸²ã«è¦‹ã‚‹æ„Ÿã˜ï¼\ndef list_of_depths(root, lsts, level): if root is None: return lst = None if len(lsts) == level: # æ·±ã•0ã®ãƒªã‚¹ãƒˆã®å­˜åœ¨ã«æ³¨æ„ lst = [] lsts.append(lst) else: lst = lsts[level] lst.append(root.key) list_of_depths(root.left, lsts, level + 1) list_of_depths(root.right, lsts, level + 1) return lsts BFS ã£ã½ãã‚‚ã§ãã‚‹ï¼$n$æ®µç›®ã‚’è¦‹çµ‚ã‚ã£ãŸæ®µéšã§$n+1$æ®µç›®ãŒsuspendedã«å…¥ã£ã¦ã„ã‚‹ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ï¼\ndef list_of_depths(root): if root is None: return [] suspended = [] suspended.append(root) lsts = [] level = 0 while len(suspended) != 0: if len(lsts) == level: lsts.append([]) next_suspended = [] for u in suspended: lsts[level].append(u.key) if u.left is not None: next_suspended.append(u.left) if u.right is not None: next_suspended.append(u.right) suspended = next_suspended level += 1 return lsts ã€Œãã®æœ¨ã¯å®Œå…¨ã«ãƒãƒ©ãƒ³ã‚¹ã—ã¦ã„ã‚‹ã‹ï¼Ÿã€ ã“ã“ã§ã¯ã€Œãã®æœ¨ã«å«ã¾ã‚Œã‚‹ã©ã®é ‚ç‚¹ã‚’æ ¹ã¨ã—ãŸéƒ¨åˆ†æœ¨ã‚’è€ƒãˆã¦ã‚‚ãã®å·¦å³ã®éƒ¨åˆ†æœ¨ãŒãƒãƒ©ãƒ³ã‚¹ã—ã¦ã„ã‚‹çŠ¶æ…‹ã€ã‚’ã€Œå®Œå…¨ã«ãƒãƒ©ãƒ³ã‚¹ã—ã¦ã„ã‚‹ã€ã¨ã™ã‚‹ï¼å·¦å³ã®éƒ¨åˆ†æœ¨ã®é«˜ã•ã®å·®ãŒ 1 ä»¥ä¸‹ã«ãªã£ã¦ã„ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ï¼è¦ã™ã‚‹ã«æœ¨ã®é«˜ã•ã‚’æ±‚ã‚ã‚‰ã‚Œã¾ã™ã‹ã¨ã„ã†å•é¡Œï¼ã‚ã‚‹é ‚ç‚¹ã‚’æ ¹ã¨ã™ã‚‹æœ¨ã®é«˜ã•ã¯ï¼Œãã®é ‚ç‚¹ã®å·¦å³ã®å­ä¾›ã‚’æ ¹ã¨ã™ã‚‹éƒ¨åˆ†æœ¨ã®ã‚µã‚¤ã‚ºã®å¤§ãã„æ–¹+1 ãªã®ã§å†å¸°çš„ã«æ›¸ã‘ã‚‹ï¼\ndef get_height(root): # base case if root is None: return -1 left = get_height(root.left) right = get_height(root.right) return max(left, right) + 1 def is_balanced(root): if root is None: return true diff = abs(get_height(root.left) - get_height(root.right)) if 1 \u0026lt; diff: return False else: return is_balanced(root.left) and is_balanced(root.right) ãŸã ã“ã‚Œã ã¨åŠ¹ç‡ãŒæ‚ªã„ï¼ä¸€éƒ¨ãŒãƒãƒ©ãƒ³ã‚¹ã—ã¦ãªã„äº‹å®ŸãŒç™ºè¦šã—ãŸæ™‚ç‚¹ã§ãã‚Œä»¥ä¸Šã®æœ¨ã®é«˜ã•ã‚’çœŸé¢ç›®ã«è¨ˆç®—ã™ã‚‹å¿…è¦ãŒãªããªã‚‹ã®ã§ï¼Œå·¥å¤«ã™ã‚‹ä½™åœ°ãŒã‚ã‚‹ï¼\nãã®äºŒåˆ†æœ¨ã¯äºŒåˆ†æ¢ç´¢æœ¨ï¼Ÿ ä¸ãˆã‚‰ã‚ŒãŸäºŒåˆ†æœ¨ãŒäºŒåˆ†æ¢ç´¢æœ¨ã«ãªã£ã¦ã„ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ï¼æ ¹ã‹ã‚‰ inorder ã§èµ°æŸ»ã—ãŸçµæœãŒæ˜‡é †ã«ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚Œã°ãã®æœ¨ã¯äºŒåˆ†æ¢ç´¢æœ¨ã®å®šç¾©ã‚’æº€ãŸã™ï¼\nclass Integer: def __init__(self, num): self.num = num last_visited = None def is_valid(root): if root is None: return True if not is_valid(root.left): return False if last_visited is not None and root.key \u0026lt;= last_visited.num: return False if not is_valid(root.right): return False return True def inorder(root): if root is None: return inorder(root.left) print(root.key) inorder(root.right) def preorder(root): if root is None: return print(root.key) preorder(root.left) preorder(root.right) def postorder(root): if root is None: return postorder(root.left) postorder(root.right) print(root.key) é–“é †èµ°æŸ»é †ã§æ¬¡ã®é ‚ç‚¹ã¯ã©ã‚Œã‹ æ³¨ç›®é ‚ç‚¹ã®å³ã®éƒ¨åˆ†æœ¨ãŒå­˜åœ¨ã™ã‚‹ãªã‚‰ï¼Œãã®éƒ¨åˆ†æœ¨ã®æœ€ã‚‚å·¦å´ã®é ‚ç‚¹ãŒæ¬¡ã«è¨ªå•ã™ã‚‹é ‚ç‚¹ã«ãªã‚‹ï¼ æ³¨ç›®é ‚ç‚¹ã®å³ã®éƒ¨åˆ†æœ¨ãŒå­˜åœ¨ã—ãªã„ãªã‚‰ï¼Œæ³¨ç›®é ‚ç‚¹ã®è¦ªã«ã¨ã£ã¦æ³¨ç›®é ‚ç‚¹ãŒå·¦å´ã®å­ãªã‚‰ï¼Œãã®è¦ªè‡ªèº«ãŒæ¬¡ã®é ‚ç‚¹ï¼\ndef left_most_child(root): if root is None: return None while root.left is not None: root = root.left return root def inorder_successor(root): if root is None: return None if root.right is not None: return left_most_child(root.right) else: q = root x = root.parent while x is not None and q is not x.left: q = x x = q.parent return x ","date":1616226834,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616226834,"objectID":"acd26e94c6534e50c408d2b84e074017","permalink":"/ja/post/binary-search-tree/","publishdate":"2021-03-20T16:53:54+09:00","relpermalink":"/ja/post/binary-search-tree/","section":"post","summary":"äºŒåˆ†æ¢ç´¢æœ¨ äºŒåˆ†æœ¨ã®ä¸­ã§ã‚‚ï¼Œå·¦ã®å­ä¾› \u0026lt;= è‡ªåˆ† \u0026lt; å³ã®å­ä¾›ã¨ãªã£ã¦ã„ã‚‹ã‚ˆã†ãªæœ¨ï¼ é ‚ç‚¹ã®æŒ¿å…¥é †åºã«ã‚ˆã£ã¦å‡ºæ¥ä¸ŠãŒã‚‹æœ¨ã¯è¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ã‚‹ï¼ å®Ÿè£… class BinarySearchTreeNode: def __init__(self, key):","tags":[],"title":"Binary Search Tree","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ æœ‰å‘ã‚°ãƒ©ãƒ•ã¨ 2 é ‚ç‚¹ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã® 2 é ‚ç‚¹é–“ã«ãƒ‘ã‚¹ãŒã‚ã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼\nç­”ãˆ æ¢ç´¢ã™ã‚‹ã ã‘\nN = int(input()) # number of nodes M = int(input()) # number of edges start = int(input()) goal = int(input()) G = [[] for _ in range(N)] for _ in range(M): u, v = map(int, input(),split()) G[u].append(v) # G[v].append(u) # for undirected has_visited = set() def DFS(graph, node): has_visited.add(node) for neighbor in graph[node]: if neighbor in has_visited: continue else: DFS(graph, neighbor) DFS(G, start) if goal in has_visited: print(\u0026#34;reachable\u0026#34;) else: print(\u0026#34;unreachable\u0026#34;) ","date":1616226424,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616226424,"objectID":"779edfc3fa3770d0f21239ce6189cd12","permalink":"/ja/post/route-between-nodes/","publishdate":"2021-03-20T16:47:04+09:00","relpermalink":"/ja/post/route-between-nodes/","section":"post","summary":"å•é¡Œ æœ‰å‘ã‚°ãƒ©ãƒ•ã¨ 2 é ‚ç‚¹ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã® 2 é ‚ç‚¹é–“ã«ãƒ‘ã‚¹ãŒã‚ã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼ ç­”ãˆ æ¢ç´¢ã™ã‚‹ã ã‘ N = int(input()) # number of nodes M = int(input()) # number of edges start = int(input()) goal = int(input()) G = [[] for","tags":[],"title":"Route Between Nodes","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ç‰‡é€£çµãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®ãƒªã‚¹ãƒˆãŒãƒ«ãƒ¼ãƒ—ã—ã¦ã„ã‚‹ã‹åˆ¤å®šã—ï¼Œã—ã¦ã„ã‚‹ãªã‚‰ã©ã“ã§ãƒ«ãƒ¼ãƒ—ã—ã¦ã„ã‚‹ã®ã‹ã‚’æ±‚ã‚ã‚ï¼\nç­”ãˆ 2 ã¤ã®ãƒã‚¤ãƒ³ã‚¿ï¼\ndef check_loop(head): faster = head slower = head while faster is not None and faster.next_node is not None: faster = faster.next_node.next_node slower = slower.next_node if faster is slower: break # there is a loop! if faster is None or faster.next_node is None: return (False, None) slower = head while slower is not faster: slower = slower.next_node faster = faster.next_node return (True, slower) ","date":1616146739,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616146739,"objectID":"3bb4fc3c2a0a56de8a497b4c4a155d89","permalink":"/ja/post/find-loop-in-linked-list/","publishdate":"2021-03-19T18:38:59+09:00","relpermalink":"/ja/post/find-loop-in-linked-list/","section":"post","summary":"å•é¡Œ ç‰‡é€£çµãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®ãƒªã‚¹ãƒˆãŒãƒ«ãƒ¼ãƒ—ã—ã¦ã„ã‚‹ã‹åˆ¤å®šã—ï¼Œã—ã¦ã„ã‚‹ãªã‚‰ã©ã“ã§ãƒ«ãƒ¼ãƒ—ã—ã¦ã„ã‚‹ã®ã‹ã‚’æ±‚ã‚ã‚ï¼ ç­”ãˆ 2 ã¤ã®ãƒã‚¤ãƒ³ã‚¿ï¼ def check_loop(head):","tags":[],"title":"Find Loop in Linked List","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ 2 ã¤ã®ç‰‡é€£çµãƒªã‚¹ãƒˆã®é ­ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã® 2 ã¤ã®ãƒªã‚¹ãƒˆãŒã©ã“ã‹ã§äº¤ã‚ã£ã¦ã„ã‚‹ã‹ï¼Œäº¤ã‚ã£ã¦ã„ã‚‹ãªã‚‰äº¤ã‚ã£ã¦ã„ã‚‹ãƒãƒ¼ãƒ‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Œï¼\nè§£ç­” äº¤ã‚ã£ã¦ã„ã‚‹ã‹å¦ã‹ã¯ä¸¡æ–¹ã®ãƒªã‚¹ãƒˆã®ãŠå°»ãŒåŒã˜ãƒãƒ¼ãƒ‰ãªã®ã‹ã§åˆ¤å®šã§ãã‚‹ï¼\nã©ã“ã§äº¤ã‚ã£ã¦ã„ã‚‹ã®ã‹ã¯ï¼Œ2 ã¤ã®ãƒªã‚¹ãƒˆã®é•·ã•ã®å·®ãŒã‚ã‹ã‚Œã°ç°¡å˜ã«ã‚ã‹ã‚‹ï¼\ndef check_intersection(ll0, ll1): ll0_tail = ll0 ll0_len = 0 ll1_tail = ll1 ll1_len = 0 while ll0_tail.next_node is not None: ll0_tail = ll0_tail.next_node ll0_len += 1 while ll1_tail.next_node is not None: ll1_tail = ll1_tail.next_node ll1_len += 1 if ll0_tail is not ll1_tail: return (False, None) diff = abs(ll0_len - ll1_len) longer = None shorter = None if ll0_len \u0026lt; ll1_len: longer = ll1 shorter = ll0 else: longer = ll0 shorter = ll1 for _ in range(diff): longer = longer.next_node while longer is not shorter: longer = longer.next_node shorter = shorter.next_node return (True, longer) ","date":1616145446,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616145446,"objectID":"8a37e06886d3dad63af5cc796eba8e92","permalink":"/ja/post/find-intersection-of-two-linked-lists/","publishdate":"2021-03-19T18:17:26+09:00","relpermalink":"/ja/post/find-intersection-of-two-linked-lists/","section":"post","summary":"å•é¡Œ 2 ã¤ã®ç‰‡é€£çµãƒªã‚¹ãƒˆã®é ­ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã® 2 ã¤ã®ãƒªã‚¹ãƒˆãŒã©ã“ã‹ã§äº¤ã‚ã£ã¦ã„ã‚‹ã‹ï¼Œäº¤ã‚ã£ã¦ã„ã‚‹ãªã‚‰äº¤ã‚ã£ã¦ã„ã‚‹ãƒãƒ¼ãƒ‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Œï¼ è§£ç­” äº¤ã‚","tags":[],"title":"Find Intersection of Two Linked Lists","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ç‰‡é€£çµãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®ãƒªã‚¹ãƒˆãŒé ­ã‹ã‚‰èª­ã‚“ã§ã‚‚ãŠå°»ã‹ã‚‰èª­ã‚“ã§ã‚‚åŒã˜ã‹ã‚’åˆ¤å®šã™ã‚‹\nç­”ãˆ é€†è»¢ã•ã›ãŸãƒªã‚¹ãƒˆã‚’ä½œã£ã¦å„è¦ç´ ã‚’ç¢ºèª\ndef reverse_linked_list(head): # base case if head.next_node is None: return LinkedListNode(head.data, None) reversed_head = reverse_linked_list(head.next_node) reversed_tail = reversed_head while reversed_tail.next_node is not None: reversed_tail = reversed_tail.next_node reversed_tail.next_node = LinkedListNode(head.data, None) return reversed_head def check_palindrome(head): reversed_head = reverse_linked_list(head) pointer0 = head pointer1 = reversed_head while pointer0 is not None and pointer1 is not None: if pointer0.data != pointer1.data: return False pointer0 = pointer0.next_node pointer1 = pointer1.next_node return True åˆ¥è§£ï¼š2 ã¤ãƒã‚¤ãƒ³ã‚¿ + stack 2 ã¤ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ãˆã°çœŸã‚“ä¸­ã‚‰ã¸ã‚“ãŒå–ã‚Œã‚‹ï¼å‰åŠè¦ç´ ã®é€†é †ã§å¾ŒåŠè¦ç´ ãŒå‡ºã¦ãã‚Œã° Palindrome ãªã®ã§ãã‚Œã‚’ç¢ºèªã™ã‚‹ï¼å…¥ã‚ŒãŸé †ç•ªã®é€†é †ã§å–ã‚Šå‡ºã›ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯stack\ndef check_palindrome(head): faster = head slower = head stack = [] while faster is not None and faster.next_node is not None: stack.append(slower.data) slower = slower.next_node faster = faster.next_node.next_node if faster is not None: slower = slower.next_node # skip middle node while len(stack) != 0: data = stack.pop() if data != slower.data: return False slower = slower.next_node return True ","date":1616142831,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616142831,"objectID":"2ed826c53ef1b4ca992d530a221c2b7d","permalink":"/ja/post/check-if-a-linked-list-is-palindrome/","publishdate":"2021-03-19T17:33:51+09:00","relpermalink":"/ja/post/check-if-a-linked-list-is-palindrome/","section":"post","summary":"å•é¡Œ ç‰‡é€£çµãƒªã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œãã®ãƒªã‚¹ãƒˆãŒé ­ã‹ã‚‰èª­ã‚“ã§ã‚‚ãŠå°»ã‹ã‚‰èª­ã‚“ã§ã‚‚åŒã˜ã‹ã‚’åˆ¤å®šã™ã‚‹ ç­”ãˆ é€†è»¢ã•ã›ãŸãƒªã‚¹ãƒˆã‚’ä½œã£ã¦å„è¦ç´ ã‚’ç¢ºèª def reverse_linked_list(head): # base","tags":[],"title":"Check if a Linked List Is Palindrome","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ 2 ã¤ã®ãƒªã‚¹ãƒˆã‚’è¦ç´ ã”ã¨ã«è¶³ã—ä¸Šã’ã¦ 1 ã¤ã®ãƒªã‚¹ãƒˆã«ã™ã‚‹\nè¦ã™ã‚‹ã«ã“ã†ã„ã†ã“ã¨ï¼\n(0) (1) (1) + + + [7] -\u0026gt; [1] -\u0026gt; [6] + + + [5] -\u0026gt; [9] -\u0026gt; [2] | | | v v v [2] -\u0026gt; [1] -\u0026gt; [9] (0) (1) (1) (1) + + + + [7] -\u0026gt; [1] -\u0026gt; [6] -\u0026gt; [1] + + + | [5] -\u0026gt; [9] -\u0026gt; [6] | | | | | v v v v [2] -\u0026gt; [1] -\u0026gt; [3] -\u0026gt; [2] ç­†ç®—ã¿ãŸã„ï¼\nç­”ãˆ ã€Œç¹°ã‚Šä¸ŠãŒã‚Šã¨è¦ç´ ã‚’ 2 ã¤è¶³ã™ã€ã‚’å†å¸°çš„ã«ç¹°ã‚Šè¿”ã™ï¼\nclass LinkedListNode: def __init__(self, data, next_node): self.data = data self.next_node = next_node def sum_up_two_linked_lists(ll0, ll1, carry): # base case if ll0 is None and ll1 is None and carry == 0: return None data = carry if ll0 is not None: data += ll0.data if ll1 is not None: data += ll1.data result = LinkedListNode(-1, None) result.data = data if ll0 is not None or ll1 is not None: next_ll0 = None next_ll1 = None if ll0 is not None: next_ll0 = ll0.next_node if ll1 is not None: next_ll1 = ll1.next_node carry = result.data // 10 result.next_node = sum_up_two_linked_list(next_ll0, next_ll1, carry) return result é¡é¡Œ æ•°å­—ãŒé€†å‘ãã«ã¤ã„ã¦ã„ã‚‹ã¨\u0026hellip;\n(1) (1) (1) (0) + + + + [1] -\u0026gt; [6] -\u0026gt; [1] -\u0026gt; [7] | + + | | [6] -\u0026gt; [9] -\u0026gt; [5] | | | | v v v v [2] -\u0026gt; [3] -\u0026gt; [1] -\u0026gt; [2] é¡é¡Œç­”ãˆ å¤§å¤‰ãã†ãªã®ã§ç‰‡é€£çµãƒªã‚¹ãƒˆã‚’é€†è»¢ã•ã›ã¦å…ƒã®å•é¡Œã«å¸°ç€ã•ã›ã‚‹ï¼\n# reverseã—ãŸãƒªã‚¹ãƒˆã®headã‚’è¿”ã™ def reverse_linked_list(head): # base case if head.next_node is None: return LinkedListNode(head.data, None) reversed_head = reverse_linked_list(head.next_node) reversed_tail = reversed_head while reversed_tail.next_node is not None: reversed_tail = reversed_tail.next_node reversed_tail.next_node = LinkedListNode(head.data, None) return reversed_head reverse_linked_list( sum_up_two_linked_lists( reverse_linked_list(ll0), reverse_linked_list(ll1), 0, ) ) ","date":1616138353,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616138353,"objectID":"88ab9fb89e7223fbe927f0b5a162e1bc","permalink":"/ja/post/sum-up-two-lists/","publishdate":"2021-03-19T16:19:13+09:00","relpermalink":"/ja/post/sum-up-two-lists/","section":"post","summary":"å•é¡Œ 2 ã¤ã®ãƒªã‚¹ãƒˆã‚’è¦ç´ ã”ã¨ã«è¶³ã—ä¸Šã’ã¦ 1 ã¤ã®ãƒªã‚¹ãƒˆã«ã™ã‚‹ è¦ã™ã‚‹ã«ã“ã†ã„ã†ã“ã¨ï¼ (0) (1) (1) + + + [7] -\u0026gt; [1] -\u0026gt; [6] + + + [5] -\u0026gt; [9] -\u0026gt; [2] | | | v v v [2] -\u0026gt; [1] -\u0026gt; [9] (0)","tags":[],"title":"Sum Up Two Lists","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ ç‰‡é€£çµãƒªã‚¹ãƒˆã®ï¼Œå¾Œã‚ã‹ã‚‰kç•ªç›®ã®è¦ç´ ã‚’è¦‹ã¤ã‘ã‚‹ï¼\nclass LinkedListNode: def __init__(self, data, next_node): self.data = data self.next_node = next_node ç­”ãˆ ç‰‡é€£çµãƒªã‚¹ãƒˆã®é•·ã•LãŒä¸ãˆã‚‰ã‚Œã‚‹ãªã‚‰ï¼Œå‰ã‹ã‚‰L-kç•ªç›®ã‚’å–ã‚Œã°ã„ã„ï¼\nç‰‡é€£çµãƒªã‚¹ãƒˆã®é•·ã•ãŒä¸ãˆã‚‰ã‚Œãªã„ã¨ãã¯ãƒãƒ§ãƒƒãƒˆå·¥å¤«ã™ã‚‹ï¼\n å†å¸°ã§æ›¸ã  def find_kth_to_last(node, k): # base case if node is None: return 0 idx = find_kth_to_last(node.next_node, k) + 1 if idx == k: print(\u0026#34;{}th to last: {}\u0026#34;.format(idx, node.data)) return idx  ãƒã‚¤ãƒ³ã‚¿ 2 ã¤ç”¨æ„ã™ã‚‹ï¼ãƒã‚¤ãƒ³ã‚¿åŒå£«ãŒké›¢ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã—ã¦ãŠãã“ã¨ã§æ™‚é–“è¨ˆç®—é‡$O(n)$ï¼Œç©ºé–“è¨ˆç®—é‡$O(1)$ã§æ¸ˆã‚€ï¼  def find_kth_to_last(head, k): pointer0 = head pointer1 = head for _ in range(k): pointer0 = pointer0.next_node while pointer0 is not None: pointer0 = pointer0.next_node pointer1 = pointer1.next_node print(\u0026#34;{}th to last: {}\u0026#34;.format(k, pointer1.data)) ","date":1616135256,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616135256,"objectID":"b3108b7cff1b0f78f397b390da8e5305","permalink":"/ja/post/kth-to-last-in-linked-list/","publishdate":"2021-03-19T15:27:36+09:00","relpermalink":"/ja/post/kth-to-last-in-linked-list/","section":"post","summary":"å•é¡Œ ç‰‡é€£çµãƒªã‚¹ãƒˆã®ï¼Œå¾Œã‚ã‹ã‚‰kç•ªç›®ã®è¦ç´ ã‚’è¦‹ã¤ã‘ã‚‹ï¼ class LinkedListNode: def __init__(self, data, next_node): self.data = data self.next_node = next_node ç­”ãˆ ç‰‡é€£çµãƒªã‚¹ãƒˆã®é•·ã•LãŒä¸ãˆã‚‰ã‚Œã‚‹ãªã‚‰ï¼Œå‰ã‹ã‚‰L-kç•ªç›®ã‚’å–ã‚Œ","tags":[],"title":"$K$th to Last in Linked List","type":"post"},{"authors":[],"categories":[],"content":"ä¸€ã¤ãšã¤èˆã‚ãªãŒã‚‰ï¼Œé‡è¤‡ã—ã¦ã„ã‚‹ãªã‚‰ãƒã‚¤ãƒ³ã‚¿ã®ä»˜æ›¿ãˆã‚’ã™ã‚‹\nclass LinkedListNode: def __init__(self, data, next_node): self.data = data self.next_node = next_node def remove_dups_from_linked_list(head): table = set() prev = None curr = head while curr is not None: if curr.data not in table: table.add(curr.data) prev = curr else: prev.next_node = curr.next_node curr = curr.next_node ","date":1616125675,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616125675,"objectID":"9b3ac7f402a325c313833c76ed592740","permalink":"/ja/post/remove-dups-from-unsorted-linked-list/","publishdate":"2021-03-19T12:47:55+09:00","relpermalink":"/ja/post/remove-dups-from-unsorted-linked-list/","section":"post","summary":"ä¸€ã¤ãšã¤èˆã‚ãªãŒã‚‰ï¼Œé‡è¤‡ã—ã¦ã„ã‚‹ãªã‚‰ãƒã‚¤ãƒ³ã‚¿ã®ä»˜æ›¿ãˆã‚’ã™ã‚‹ class LinkedListNode: def __init__(self, data, next_node): self.data = data self.next_node = next_node def remove_dups_from_linked_list(head): table = set() prev = None curr = head while curr is not None: if curr.data not in table: table.add(curr.data) prev = curr else: prev.next_node = curr.next_node","tags":[],"title":"Remove Dups From Unsorted Linked List","type":"post"},{"authors":[],"categories":[],"content":"é€£çµãƒªã‚¹ãƒˆã‚’ç¹”ã‚Šè¾¼ã¿ãŸã„ é•·ã•ãŒå¶æ•°ã®é€£çµãƒªã‚¹ãƒˆã‚’çœŸã‚“ä¸­ã§åˆ‡æ–­ã—ã¦ç¹”ã‚Šè¾¼ã¿ãŸã„ï¼\nè¦ã™ã‚‹ã«ã“ã‚Œã‚’\n[10] -\u0026gt; [11] -\u0026gt; [12] -\u0026gt; [13] -\u0026gt; [14] -\u0026gt; [15] -\u0026gt; [20] -\u0026gt; [21] -\u0026gt; [22] -\u0026gt; [23] -\u0026gt; [24] -\u0026gt; [25] ã“ã†ã—ãŸã„\n[10] -\u0026gt; [20] -\u0026gt; [11] -\u0026gt; [21] -\u0026gt; [12] -\u0026gt; [22] -\u0026gt; [13] -\u0026gt; [23] -\u0026gt; [14] -\u0026gt; [24] -\u0026gt; [15] -\u0026gt; [25] ãƒ†ã‚¯ï¼šäºŒäººèµ°ã‚‰ã›ã‚‹  äºŒå€ã®é€Ÿã•ã§èµ°ã‚‹ãƒã‚¤ãƒ³ã‚¿ã‚’ç”¨æ„ã™ã‚Œã°çœŸã‚“ä¸­ã§åˆ‡ã‚‹ã“ã¨ãŒã§ãã‚‹  class LinkedListNode: def __init__(self, data, next_node): self.data = data self.next_node = next_node def waven(head): faster = head slower = head while faster is not None: faster = faster.next_node.next_node slower = slower.next_node faster= head while slower is not None: next_faster = faster.next_node next_slower = slower.next_node faster.next_node = slower if next_slower is not None: slower.next_node = next_faster faster = next_faster slower = next_slower return head  waven linked list ã£ã¦è‹±èªã¯é–“é•ã£ã¦ã„ãã†ï¼  ","date":1616086513,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616086513,"objectID":"0448e4b97070ebea52b42e0ad8e21b07","permalink":"/ja/post/waven-lined-list/","publishdate":"2021-03-19T01:55:13+09:00","relpermalink":"/ja/post/waven-lined-list/","section":"post","summary":"é€£çµãƒªã‚¹ãƒˆã‚’ç¹”ã‚Šè¾¼ã¿ãŸã„ é•·ã•ãŒå¶æ•°ã®é€£çµãƒªã‚¹ãƒˆã‚’çœŸã‚“ä¸­ã§åˆ‡æ–­ã—ã¦ç¹”ã‚Šè¾¼ã¿ãŸã„ï¼ è¦ã™ã‚‹ã«ã“ã‚Œã‚’ [10] -\u0026gt; [11] -\u0026gt; [12] -\u0026gt; [13] -\u0026gt; [14] -\u0026gt; [15] -\u0026gt; [20] -\u0026gt; [21] -\u0026gt; [22] -\u0026gt; [23] -\u0026gt; [24] -\u0026gt; [25] ã“","tags":[],"title":"Waven Lined List","type":"post"},{"authors":[],"categories":[],"content":"å•é¡Œ äºŒæ¬¡å…ƒé…åˆ—XãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã“ã§X[i][j] == 0ãªã‚‰ã°iè¡Œç›®å…¨ä½“ã¨jåˆ—ç›®å…¨ä½“ã‚’0ã«ã—ãŸã„ï¼\n1 2 3 1 2 0 4 5 0 -\u0026gt; 0 0 0 7 8 9 7 8 0 ä½•ã‚‚è€ƒãˆãšã«å·¦ä¸Šã‹ã‚‰å³ä¸‹ã«å‘ã‹ã£ã¦èµ°æŸ»ã—ãªãŒã‚‰0ã‚’è¦‹ã¤ã‘æ¬¡ç¬¬ãã®è¡Œã¨åˆ—ã‚’0ã«ã™ã‚‹ã£ã¦ã‚„ã£ã¦ã„ãã¨ï¼Œè¡Œåˆ—å…¨ä½“ãŒ0ã«ãªã£ã¦ã‹ãªã—ã„æ°—æŒã¡ã«ãªã‚‹ï¼\nè½ã¡ç€ã„ã¦çœŸé¢ç›®ã«ã‚„ã‚‹ èµ°æŸ»ã¨0åŸ‹ã‚ã‚’åˆ¥å€‹ã«ã‚„ã‚Œã°å…¨éƒ¨0ã«ã¯ãªã‚‰ãªã„ï¼\ndef set_zeros(table): ROW = len(table) COL = len(table[0]) row_with_zero = [False for _ in range(ROW)] col_with_zero = [False for _ in range(COL)] for r in range(ROW): for c in range(COL): if table[r][c] == 0: row_with_zero[r] = True col_with_zero[c] = True for r in range(ROW): if row_with_zero[r]: for c in range(COL): table[r][c] = 0 for c in range(COL): if col_with_zero[c]: for r in range(ROW): table[r][c] = 0 return table ","date":1616083669,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616083669,"objectID":"2053f2a99d9bd3aee8e3374d664813e4","permalink":"/ja/post/zero-matrix/","publishdate":"2021-03-19T01:07:49+09:00","relpermalink":"/ja/post/zero-matrix/","section":"post","summary":"å•é¡Œ äºŒæ¬¡å…ƒé…åˆ—XãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼ã“ã“ã§X[i][j] == 0ãªã‚‰ã°iè¡Œç›®å…¨ä½“ã¨jåˆ—ç›®å…¨ä½“ã‚’0ã«ã—ãŸã„ï¼ 1 2 3 1 2 0 4 5 0 -\u0026gt; 0 0 0 7 8 9 7 8 0 ä½•ã‚‚è€ƒ","tags":[],"title":"Zero Matrix","type":"post"},{"authors":[],"categories":[],"content":"äºŒæ¬¡å…ƒé…åˆ—ã‚’å›è»¢ã—ãŸã„ é ­ãŒæ··ä¹±ã—ã¦ã—ã¾ã†ã®ã§ã¾ã¨ã‚ã‚‹ï¼\nåæ™‚è¨ˆå›ã‚Šã« 90 åº¦å›è»¢  å›è»¢å¾Œã®è¡Œåˆ—ã‚’å·¦ä¸Šã‹ã‚‰å³ä¸‹ã¸åŸ‹ã‚ã¦ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸ ã¤ã¾ã‚Šå›è»¢å‰ã®è¡Œåˆ—ã®å³ä¸Šã‹ã‚‰å·¦ä¸‹ã¸æ‹¾ã£ã¦ã„ã åƒ•ã®é ­çš„ã«ã¯ï¼Œå›è»¢å¾Œã®è¡Œåˆ—ã®åº§æ¨™ã®è»Œè·¡ã‚’æ­£ã¨ã—ã¦å›è»¢å‰ã®ä½ç½®ã‚’å‚ç…§ã™ã‚‹æ–¹ãŒæ›¸ãã‚„ã™ã„ã¿ãŸã„ï¼  def rotate_counterclockwise(table): ROW = len(table[0]) # å›è»¢å¾Œã®è¡Œæ•°ã¯å›è»¢å‰ã®åˆ—æ•° COL = len(table) # å›è»¢å¾Œã®åˆ—æ•°ã¯å›è»¢å‰ã®è¡Œæ•° rotated = [[0 for _ in range(COL)] for _ in range(ROW)] for r in range(ROW): for c in range(COL): rotated[r][c] = table[c][ROW - r - 1] return rotated æ™‚è¨ˆå›ã‚Šã« 90 åº¦å›è»¢  å›è»¢å¾Œã®è¡Œåˆ—ã‚’å·¦ä¸Šã‹ã‚‰å³ä¸‹ã¸åŸ‹ã‚ã¦ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸ ã¤ã¾ã‚Šå›è»¢å‰ã®è¡Œåˆ—ã®å·¦ä¸‹ã‹ã‚‰å³ä¸Šã¸æ‹¾ã£ã¦ã„ã  def rotate_clockwise(table): ROW = len(table[0]) # å›è»¢å¾Œã®è¡Œæ•°ã¯å›è»¢å‰ã®åˆ—æ•° COL = len(table) # å›è»¢å¾Œã®åˆ—æ•°ã¯å›è»¢å‰ã®è¡Œæ•° rotated = [[0 for _ in range(COL)] for _ in range(ROW)] for r in range(ROW): for c in range(COL): rotated[r][c] = table[COL - c - 1][r] return rotated ã‹ã£ã“ã„ã„æ›¸ãæ–¹  zipã‚’ä½¿ã†ã¨å·¦ 90 åº¦å›è»¢ã¯ã‹ã£ã“ã‚ˆãã‹ã‘ã‚‹ zipã§å›è»¢å¾Œã®è¡Œåˆ—ã‚’è¡Œã”ã¨ã«ä¸‹ã‹ã‚‰é›†ã‚ãŸã‚‚ã®ãŒå–ã‚Œã‚‹ã®ã§ï¼Œæœ€å¾Œã«ãã‚Œã‚’é€†é †ã«ã™ã‚‹ ref: https://stackoverflow.com/questions/8421337/rotating-a-two-dimensional-array-in-python  def rotate_counterclockwise(table): return [list(row) for row in zip(*table)][::-1]  è±†çŸ¥è­˜ï¼šå·¦ 90 åº¦å›è»¢ x 3 == å³ 90 åº¦å›è»¢  ","date":1616080414,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1616080414,"objectID":"7c6a930ffdfee961247d52b6c76bcb0b","permalink":"/ja/post/rotate-2d-array/","publishdate":"2021-03-19T00:13:34+09:00","relpermalink":"/ja/post/rotate-2d-array/","section":"post","summary":"äºŒæ¬¡å…ƒé…åˆ—ã‚’å›è»¢ã—ãŸã„ é ­ãŒæ··ä¹±ã—ã¦ã—ã¾ã†ã®ã§ã¾ã¨ã‚ã‚‹ï¼ åæ™‚è¨ˆå›ã‚Šã« 90 åº¦å›è»¢ å›è»¢å¾Œã®è¡Œåˆ—ã‚’å·¦ä¸Šã‹ã‚‰å³ä¸‹ã¸åŸ‹ã‚ã¦ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸ ã¤ã¾ã‚Šå›è»¢å‰ã®è¡Œåˆ—ã®","tags":[],"title":"2æ¬¡å…ƒé…åˆ—ã‚’å›è»¢ã—ãŸã„","type":"post"},{"authors":[],"categories":[],"content":"100 lockers ref: http://mathforum.org/library/drmath/view/56747.html\nã‚ã‚‹é§…ã« 100 å€‹ã®ãƒ­ãƒƒã‚«ãƒ¼ãŒè¨­ç½®ã•ã‚ŒãŸï¼å„ãƒ­ãƒƒã‚«ãƒ¼ã«ã¯ç•ªå·ãŒ$1$ï¼Œ$2$ï¼Œ$3$\u0026hellip;ï¼Œ$99$ï¼Œ$100$ã¨æŒ¯ã‚‰ã‚Œã¦ãŠã‚Šï¼Œã™ã¹ã¦ã®æ‰‰ãŒé–‰ã˜ã¦ã„ã‚‹ï¼ä»Šã‹ã‚‰ç§ã¯$i$ï¼ˆ$i = 1, 2, \u0026hellip;, 99, 100$ï¼‰å›ä»¥ä¸‹ã®è¡Œå‹•ã‚’ã™ã‚‹ï¼\n $i$ã®å€æ•°ã®ç•ªå·ã®ãƒ­ãƒƒã‚«ãƒ¼ã‚’ï¼Œé–‹ã„ã¦ã„ã‚Œã°é–‰ã‚ï¼Œé–‰ã¾ã£ã¦ã„ã‚Œã°é–‹ã‘ã‚‹  ã“ã®è¡Œå‹•ã¯ã‚ã¾ã‚Šã«å¥‡äººãªã®ã§ï¼Œã‚„ã‚ŠãŸããªã„ï¼ãŒï¼Œã‚„ã£ãŸã‚ã¨ã«é–‹ã„ã¦ã„ã‚‹æ‰‰ãŒã©ã‚Œãªã®ã‹ã¯ã©ã†ã—ã¦ã‚‚çŸ¥ã‚ŠãŸã„ï¼å›ã«æ•™ãˆã¦ã»ã—ã„ï¼\n  åˆæœŸçŠ¶æ…‹ã§ã¯æ‰‰ã¯å…¨ã¦é–‰ã˜ã¦ã„ã‚‹ã®ã§ï¼Œå¥‡æ•°å›æ“ä½œã®å¯¾è±¡ã«ãªã‚‹ã¨æ‰‰ãŒé–‹ã„ã¦ã„ã‚‹ã“ã¨ã«ãªã‚‹ï¼ã“ã“ã§æ‰‰$n$ã¯$n$ã®ç´„æ•°å›ç›®ã«æ“ä½œã®å¯¾è±¡ã«ãªã‚‹ï¼ã¨ã„ã†ã“ã¨ã¯æœ€å¾Œã«æ®‹ã£ã¦ã„ã‚‹ã®ã¯æ‰‰ã®ç•ªå·ã®ç´„æ•°ãŒå¥‡æ•°å€‹ã®æ‰‰ã§ã‚ã‚‹ï¼ç´„æ•°ãŒå¥‡æ•°å€‹ã¨ãªã‚‹ã‚ˆã†ãªæ•°å­—ã¯ï¼Œå¹³æ–¹æ•°ã—ã‹ãªã„ï¼ã‚ˆã£ã¦ï¼Œæœ€å¾Œã«é–‹ã„ã¦ã„ã‚‹æ‰‰ã¯$1$ï¼Œ$4$ï¼Œ$9$ï¼Œ$16$ï¼Œ$25$ï¼Œ$36$ï¼Œ$49$ï¼Œ$64$ï¼Œ$81$ï¼Œ$100$ã® 10 ã®æ‰‰ï¼\n ","date":1608195386,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1608195386,"objectID":"8c222117c332f47ebd82743b87ad6519","permalink":"/ja/post/puzzle-100-lockers/","publishdate":"2020-12-17T17:56:26+09:00","relpermalink":"/ja/post/puzzle-100-lockers/","section":"post","summary":"100 lockers ref: http://mathforum.org/library/drmath/view/56747.html ã‚ã‚‹é§…ã« 100 å€‹ã®ãƒ­ãƒƒã‚«ãƒ¼ãŒè¨­ç½®ã•ã‚ŒãŸï¼å„ãƒ­ãƒƒã‚«ãƒ¼ã«ã¯ç•ªå·ãŒ$1$ï¼Œ$2$ï¼Œ$3$\u0026hellip;ï¼Œ$99$ï¼Œ$100$ã¨æŒ¯ã‚‰ã‚Œã¦ãŠã‚Šï¼Œ","tags":["puzzle"],"title":"Puzzle: 100 Lockers","type":"post"},{"authors":[],"categories":[],"content":"Ants on a Polygon ref: https://www.geeksforgeeks.org/puzzle-21-3-ants-and-triangle/\n$n$è§’å½¢ã®æ‹¡å¼µç‚¹ã« ğŸœ ãŒã„ã‚‹ï¼ç§ã®æ›ã‘å£°ã§ ğŸœ ã¯ä¸€æ–‰ã«ã©ã¡ã‚‰ã‹ã®è¾ºã‚’é¸ã‚“ã§æ­©ãå‡ºã™ï¼ğŸœ ãŒè¾ºä¸Šã§è¡çªã™ã‚‹ç¢ºç‡ã‚’æ±‚ã‚ã‚ˆï¼\n  $n$åŒ¹ã® ğŸœ ãŒå…¨éƒ¨åŒã˜æ–¹å‘ã‚’é¸ã¹ã°è¡çªã¯ã—ãªã„ï¼ã™ã¹ã¦ã® ğŸœ ãŒæ™‚è¨ˆå›ã‚Šã®æã‚’é¸ã¶ç¢ºç‡ã¯\n$$ \\frac{1}{2^n} $$\nåŒã˜ã‚ˆã†ã«ï¼Œã™ã¹ã¦ã® ğŸœ ãŒåæ™‚è¨ˆå›ã‚Šã®æã‚’é¸ã¶ç¢ºç‡ã¯\n$$ \\frac{1}{2^n} $$\nã™ã¹ã¦ã® ğŸœ ãŒåŒã˜æ–¹å‘ã‚’é¸ã¶ç¢ºç‡ã¯\n$$ 2 \\times \\frac{1}{2^n} = \\frac{1}{2^{n-1}} $$\nã‚ˆã£ã¦è¡çªã™ã‚‹ç¢ºç‡ã¯\n$$ 1 - \\frac{1}{2^{n-1}} $$\n ","date":1608194790,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1608194790,"objectID":"2920f67c3c4f181fbf6334a96a44dbb1","permalink":"/ja/post/puzzle-ants-on-a-polygon/","publishdate":"2020-12-17T17:46:30+09:00","relpermalink":"/ja/post/puzzle-ants-on-a-polygon/","section":"post","summary":"Ants on a Polygon ref: https://www.geeksforgeeks.org/puzzle-21-3-ants-and-triangle/ $n$è§’å½¢ã®æ‹¡å¼µç‚¹ã« ğŸœ ãŒã„ã‚‹ï¼ç§ã®æ›ã‘å£°ã§ ğŸœ ã¯ä¸€æ–‰ã«ã©ã¡ã‚‰ã‹ã®è¾ºã‚’é¸ã‚“ã§æ­©ãå‡ºã™ï¼ğŸœ ãŒè¾ºä¸Šã§è¡çªã™ã‚‹ç¢ºç‡ã‚’æ±‚ã‚ã‚ˆï¼ $n$åŒ¹ã® ğŸœ ãŒ","tags":["Puzzle"],"title":"Puzzle: Ants on a Polygon","type":"post"},{"authors":[],"categories":[],"content":"The heavy pill ref: https://www.geeksforgeeks.org/puzzle-10-identical-bottles-pills/\nç›®ã®å‰ã« 10 ç¨®é¡ã®éŒ å‰¤ã®ç“¶ãŒç½®ã‹ã‚Œã¦ã„ã‚‹ï¼ãã‚Œãã‚Œã®ç“¶ã«ã¯ååˆ†ãªé‡ã®éŒ å‰¤ãŒå…¥ã£ã¦ã„ã‚‹ï¼å„ç“¶ã«ã¯ç•ªå·ãŒæŒ¯ã‚‰ã‚Œã¦ãŠã‚Šï¼Œãã‚Œãã‚Œ1/2/3/4/5/6/7/8/9/10ã§ã‚ã‚‹ï¼ã“ã‚Œã‚‰ã®éŒ å‰¤ã®ã†ã¡ï¼Œã‚ã‚‹ä¸€ã¤ã®ç“¶ã«å«ã¾ã‚Œã¦ã„ã‚‹éŒ å‰¤ã¯é‡ã•ãŒ 1.1g ã§ä»–ã®éŒ å‰¤ã¯ 1g ã§ã‚ã‚‹ï¼æ¸¬ã‚Šã‚’ 1 å›ã ã‘ç”¨ã„ã¦ã€Œã©ã®ç“¶ã«å«ã¾ã‚Œã‚‹éŒ å‰¤ãŒé‡ã• 1.1g ã®éŒ å‰¤ã§ã‚ã‚‹ã‹ã€ã‚’æ±‚ã‚ãŸã„ï¼ã©ã®ã‚ˆã†ã«ã™ã‚Œã°ã‚ˆã„ã ã‚ã†ã‹ï¼\n  $i = 1, 2, \u0026hellip;, 9, 10$ã«å¯¾ã—ã¦ï¼Œç“¶$i$ã‹ã‚‰$i$ç²’ã®éŒ å‰¤ã‚’å–ã‚Šå‡ºã—æ¸¬ã‚Šã«è¼‰ã›ã‚‹ï¼æ¸¬ã‚Šã®æŒ‡ã™åˆè¨ˆé‡é‡$X$ã‚’èª­ã¿å–ã‚‹ï¼ç•ªå·$(X-55)/0.1$ã®ç“¶ãŒ 1.1g ã®éŒ å‰¤ã®ç“¶ã§ã‚ã‚‹ï¼\n ","date":1608193843,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1608193843,"objectID":"ff803954e1197e89856b0aae25446b7e","permalink":"/ja/post/puzzle-heavy-pill/","publishdate":"2020-12-17T17:30:43+09:00","relpermalink":"/ja/post/puzzle-heavy-pill/","section":"post","summary":"The heavy pill ref: https://www.geeksforgeeks.org/puzzle-10-identical-bottles-pills/ ç›®ã®å‰ã« 10 ç¨®é¡ã®éŒ å‰¤ã®ç“¶ãŒç½®ã‹ã‚Œã¦ã„ã‚‹ï¼ãã‚Œãã‚Œã®ç“¶ã«ã¯ååˆ†ãªé‡ã®éŒ å‰¤ãŒå…¥ã£ã¦ã„ã‚‹ï¼å„ç“¶ã«ã¯ç•ªå·ãŒæŒ¯ã‚‰ã‚Œã¦ãŠã‚Šï¼Œãã‚Œãã‚Œ1/2/3","tags":["puzzle"],"title":"Puzzle: Heavy Pill","type":"post"},{"authors":[],"categories":[],"content":"å¿˜ã‚Œãªã„ã‚ˆã†ã«ãƒ¡ãƒ¢  0xF = 0b1111ï¼š0xä¸€æ–‡å­—ã¯ 4bits 0xFF = 0b1111 1111ï¼š0xäºŒæ–‡å­—ã¯ 8bitsï¼ˆ1byteï¼‰  if (n \u0026amp; (n-1)) == 0 if n = xxxxx 1000 then n - 1 = xxxxx 0111 ------------------------ n \u0026amp; (n - 1) = ????? 0000 ãªã®ã§ï¼Œif (n \u0026amp; (n-1)) == 0ãŒ true ãªã‚‰?????ãŒ00000ã§ã‚ã‚Šï¼Œã¤ã¾ã‚ŠxxxxxãŒ00000ã§ã‚ã‚‹ã‹ã‚‰ï¼Œ\nn = 00000 1000 ã¨ã„ã†ã“ã¨ã«ãªã‚‹ï¼\nif (n \u0026amp; (n-1)) == 0ã¯ã€ŒnãŒ 2 ã®ã¹ãä¹—ã§ã‚ã‚‹ã‹ã€ã‚’ç¢ºèªã—ã¦ã„ã‚‹ï¼\n","date":1608102089,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1608102089,"objectID":"07f403fbece781ade8533256cfc92f28","permalink":"/ja/post/check-n-is-power-of-2/","publishdate":"2020-12-16T16:01:29+09:00","relpermalink":"/ja/post/check-n-is-power-of-2/","section":"post","summary":"`n`ãŒ2ã®ã¹ãä¹—ã§ã‚ã‚‹ã‹","tags":["ãƒ“ãƒƒãƒˆ","bit manipulation","atcoder","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°","ç«¶ãƒ—ãƒ­"],"title":"if (n \u0026 (n-1)) == 0","type":"post"},{"authors":[],"categories":[],"content":"${}_n \\mathrm{C} _r$ã®å®šç¾© ç•°ãªã‚‹$n$å€‹ã®ã‚‚ã®ã‹ã‚‰$r$å€‹ã‚’é¸ã¶çµ„ã¿åˆã‚ã›ã®ç·æ•°ï¼\nã„ã‚ã‚“ãªå®Ÿè£…  å†å¸°çš„ã«è¨ˆç®—ã™ã‚‹  long long combination(long long n, long long r) { if (n == r || r == 0) return 1; else return combination(n - 1, r - 1) + combination(n - 1, r); }  ãƒ‘ã‚¹ã‚«ãƒ«ã®ä¸‰è§’å½¢ã‚’ç”¨ã„ã‚‹  äºŒæ¬¡å…ƒé…åˆ—ã®ä¸‹åŠåˆ†ã‚’ãƒ‘ã‚¹ã‚«ãƒ«ã®ä¸‰è§’å½¢ã®ãƒ«ãƒ¼ãƒ«ã«å¾“ã£ã¦åŸ‹ã‚ã¦ã„ã å°ã•ã„ã¨ã“ã‚ã‹ã‚‰åŸ‹ã¾ã£ã¦ã„ãã®ã§ç›´æ¥å®šç¾©å¼ã©ãŠã‚Šã«è¨ˆç®—ã—ãŸã¨ãã«ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã™ã‚‹ã‚ˆã†ãªå¤§ãã„çµ„ã¿åˆã‚ã›ã‚’è¨ˆç®—ã§ãã‚‹ï¼  ABC185-Cã¯ã“ã‚Œã‚’ä½¿ã£ã¦ AC      vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; combination(long long n, long long r) { vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; table(n+1, vector\u0026lt;long long\u0026gt;(n+1, 0)); for (int i = 0; i \u0026lt; table.size(); i++) { table[i][0] = 1; table[i][i] = 1; } for (int j = 1; j \u0026lt; table.size(); j++) { for (int k = 1; k \u0026lt; j; k++) { table[j][k] = table[j - 1][k - 1] + table[j - 1][k]; // çœŸä¸Šã¨å·¦ä¸Šã®å’Œ  } } return table; // table[n][r]ãŒnCrã®å€¤ } ","date":1607904000,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1607904000,"objectID":"11e8f2a978c9250f3c268a05b691c109","permalink":"/ja/post/calc-combination/","publishdate":"2020-12-14T09:00:00+09:00","relpermalink":"/ja/post/calc-combination/","section":"post","summary":"ãƒ‘ã‚¹ã‚«ãƒ«ã®ä¸‰è§’å½¢ã§é«˜é€Ÿã«çµ„ã¿åˆã‚ã›è¨ˆç®—","tags":["çµ„ã¿åˆã‚ã›","combination","AtCoder","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°","ç«¶ãƒ—ãƒ­"],"title":"çµ„ã¿åˆã‚ã›ã‚’é«˜é€Ÿã«è¨ˆç®—ã™ã‚‹","type":"post"},{"authors":[],"categories":[],"content":"å…¨æ¢ç´¢ã‚’å†å¸°é–¢æ•°ã§ã‚„ã‚‹ã¨ãã® 2 æµæ´¾ å…¨æ¢ç´¢ã‚’å†å¸°é–¢æ•°ã§æ›¸ãã«ã¯ãŸã„ã¦ã„ 2 æµæ´¾ã‚ã‚‹ï¼\n çŠ¶æ…‹æƒ…å ±ã‚’é…ã£ã¦ã„ãå†å¸° çŠ¶æ…‹æƒ…å ±ã‚’é›†ã‚ã¦ã„ãå†å¸°  å…¨æ¢ç´¢ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„å•é¡Œã§ã¯ï¼Œæ¢ç´¢ã™ã¹ãçŠ¶æ…‹æ•°ãŒæŒ‡æ•°çš„ã«å¢—åŠ ã—ã¦ã—ã¾ã†ã®ã§ï¼Œå•é¡Œã®åˆ¶ç´„ãŒå°ã•ã‚ã§ã‚ã‚‹ã“ã¨ãŒå¤šã„ï¼å¤§ä½“ $10$ ã‹ã‚‰ $20$ ãã‚‰ã„ã ã¨å…¨æ¢ç´¢ã§ãã‚‹ï¼\néƒ¨åˆ†å’Œå•é¡Œ  ã€å•é¡Œã€‘ $n$å€‹ã®æ•´æ•°åˆ— $a_1, a_2, \u0026hellip; , a_{n-1}$ ã‹ã‚‰éƒ¨åˆ†é›†åˆã‚’ã†ã¾ãé¸ã‚“ã§ï¼Œãã®é›†åˆå†…ã®æ•°ã®å’Œã‚’ $W$ ã«ç­‰ã—ãã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹åˆ¤å®šã›ã‚ˆï¼\nã€åˆ¶ç´„ã€‘ $1 \\leq n \\leq 20$\n çŠ¶æ…‹æƒ…å ±ã‚’é…ã£ã¦ã„ãå†å¸° ã“ã®ã‚¿ã‚¤ãƒ—ã®å†å¸°ã§ã¯ å†å¸°çš„ãªæ¨¹å½¢å›³ã®æœ€å°å˜ä½ ã‚’ãã®ã¾ã¾å†å¸°é–¢æ•°ãŒè¡¨ç¾ã—ã¦ã„ã‚‹ã¨æ‰ãˆã‚‹ã¨ã‚ã‹ã‚Šã‚„ã™ã„ï¼\nrec(çŠ¶æ…‹ã‚’è¡¨ã™å¤‰æ•°) { if (çŠ¶æ…‹ãŒæ¨¹å½¢å›³ã®æœ«ç«¯ã§ã‚ã‚‹) { // ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ æ¡ä»¶ã«å¯¾ã—ã¦ã“ã®çŠ¶æ…‹ãŒå¦¥å½“ã§ã‚ã‚‹ã‹ã®ç¢ºèª return; } rec(æ¬¡ã®çŠ¶æ…‹1) rec(æ¬¡ã®é·ç§»2) } æ¨¹å½¢å›³ä¸Šã‚’æ·±ã•å„ªå…ˆæ¢ç´¢ã—ã¦ï¼Œæœ«ç«¯ã®çŠ¶æ…‹ã«ãŸã©ã‚Šç€ã„ã¦ã‹ã‚‰æ¡ä»¶ã¨ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã‚’ã™ã‚‹ï¼\nã“ã®æ–¹é‡ã§éƒ¨åˆ†å’Œå•é¡Œã‚’è§£ã„ã¦ã¿ã‚‹ï¼ã“ã“ã§ã¯çŠ¶æ…‹ã‚’\n(ä½•ç•ªç›®ã¾ã§ã®é …ã‚’ç”¨ã„ã‚‹ã‹, ãã®æ™‚ç‚¹ã§ã®éƒ¨åˆ†å’Œ) ã¨ã—ã¦è¡¨ç¾ã—ã¦ã„ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int N, W; vector\u0026lt;int\u0026gt; a; bool rec(int depth, int sum) { // æ¨¹å½¢å›³ã®æœ«ç«¯ã«åˆ°é”ã—ãŸã¨ã  if (depth == N) { if (sum == W) return true; else return false; } // a[depth]ã‚’éƒ¨åˆ†å’Œè¨ˆç®—ã«ç”¨ã„ã‚‹å ´åˆ  if (rec(depth+1, sum + a[depth])) return true; // a[depth]ã‚’éƒ¨åˆ†å’Œè¨ˆç®—ã«ç”¨ã„ãªã„å ´åˆ  if (rec(depth+1, sum)) return true; return false; } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; a.resize(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; a[i]; // çŠ¶æ…‹(0, 0)ã‹ã‚‰æ¨¹å½¢å›³ã‚’æœ«ç«¯ã«å‘ã‹ã£ã¦æ·±ã•å„ªå…ˆæ¢ç´¢  if (rec(0, 0)) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } çŠ¶æ…‹æƒ…å ±ã‚’é›†ã‚ã¦ã„ãå†å¸° é…ã£ã¦ã„ãå†å¸°ã¨ã®å¯¾æ¯”ã§è€ƒãˆã‚‹ã¨ï¼Œé›†ã‚ã¦ã„ãå†å¸°ã§ã¯çŠ¶æ…‹ã‚’\n(ä½•ç•ªç›®ä»¥é™ã®é …ã‚’ç”¨ã„ã‚‹ã‹, ãã®æ™‚ç‚¹ã§ã®Wã¨ã®å·®) ã§çŠ¶æ…‹ã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼ã€Œå®Ÿç¾ã—ãŸã„å’Œ W ã¨ã®å·®ã€ã§çŠ¶æ…‹ã‚’è¡¨ç¾ã™ã‚‹ã¨ã“ã‚ãŒé…ã‚‹å†å¸°ã¨ã¯é•ã£ã¦ã„ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int N, W; vector\u0026lt;int\u0026gt; a; bool rec(int idx, int remain) { // æ¨¹å½¢å›³ã®æœ«ç«¯ã«åˆ°é”ã—ãŸã¨ã: Nç•ªç›®ä»¥é™ã®é …ã‚’ç”¨ã„ã‚‹ã¨ãã®éƒ¨åˆ†å’Œã¯è‡ªæ˜  if (idx == N) { if (remain == 0) return true; else return false; } // a[idx]ã‚’éƒ¨åˆ†å’Œè¨ˆç®—ã«ç”¨ã„ã‚‹å ´åˆ  if (a[idx] \u0026lt;= remain \u0026amp;\u0026amp; rec(idx+1, remain - a[idx])) return true; // a[idx]ã‚’éƒ¨åˆ†å’Œè¨ˆç®—ã«ç”¨ã„ãªã„å ´åˆ  if (rec(idx+1, remain)) return true; return false; } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; a.resize(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; a[i]; // çŠ¶æ…‹(0, W)ã‹ã‚‰æ¨¹å½¢å›³ã‚’æœ«ç«¯ã«å‘ã‹ã£ã¦æ·±ã•å„ªå…ˆæ¢ç´¢  if (rec(0, W)) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } çŠ¶æ…‹ã®å®šç¾©æ¬¡ç¬¬ã§ã¯åˆ¥ã®æ›¸ãæ–¹ã‚‚ã§ãã‚‹ï¼çŠ¶æ…‹ã‚’\n(0ã‹ã‚‰ä½•ç•ªç›®ã¾ã§ã®é …ã‚’ç”¨ã„ãŸã‹, ãã®æ™‚ç‚¹ã§ã®Wã¨ã®å·®) ã¨ã™ã‚‹ã¨ï¼Œ\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int N, W; vector\u0026lt;int\u0026gt; a; bool rec(int idx, int remain) { // æ¨¹å½¢å›³ã®æœ«ç«¯ã«åˆ°é”ã—ãŸã¨ã: 0ç•ªç›®ã¾ã§ã®é …ã‚’ç”¨ã„ãŸæ™‚ã®éƒ¨åˆ†å’Œã¯è‡ªæ˜  if (idx == 0) { if (remain == 0) return true; else return false; } // a[idx-1]ã‚’éƒ¨åˆ†å’Œè¨ˆç®—ã«ç”¨ã„ã‚‹å ´åˆ  if (a[idx-1] \u0026lt;= remain \u0026amp;\u0026amp; rec(idx-1, remain - a[idx-1])) return true; // a[idx-1]ã‚’éƒ¨åˆ†å’Œè¨ˆç®—ã«ç”¨ã„ãªã„å ´åˆ  if (rec(idx-1, remain)) return true; return false; } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; a.resize(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; a[i]; // çŠ¶æ…‹(N, W)ã‹ã‚‰æ¨¹å½¢å›³ã‚’æœ«ç«¯ã«å‘ã‹ã£ã¦æ·±ã•å„ªå…ˆæ¢ç´¢  if (rec(N, W)) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } çŠ¶æ…‹æƒ…å ±ã‚’é›†ã‚ã¦ã„ãå†å¸°ã§ãƒ¡ãƒ¢åŒ– é›†ã‚ã¦ã„ãå†å¸°ã§ã¯ï¼Œã‚µã‚¤ã‚º $n$ ã®å•é¡Œã‚’è§£ããŸã‚ã« ã‚µã‚¤ã‚º $n-1$ ã®å•é¡Œã®çµæœã‚’åˆ©ç”¨ã™ã‚‹ã®ã ã‹ã‚‰ï¼Œãã‚Œã‚’é…åˆ—ãªã©ã«ãƒ¡ãƒ¢ã—ã¦ãŠã‘ã°å†å¸°è¨ˆç®—ã®ç„¡é§„ã‚’æ¸›ã‚‰ã›ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int N, W; vector\u0026lt;int\u0026gt; a; // dp[i][j]: iç•ªç›®ã¾ã§ã®é …ã‚’ç”¨ã„ã¦éƒ¨åˆ†å’ŒWã¨ã®å·®ã‚’jã«ã§ããŸã‹ // -1: ã¾ã è§£æ±ºã—ã¦ã„ãªã„ // 0: ã§ããªã„ // 1: ã§ãã‚‹ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; int rec(int idx, int remain) { // ã¾ãšãƒ¡ãƒ¢ã‚’ç¢ºèª  if (dp[idx][remain] != -1) return dp[idx][remain]; // ã™ã§ã«è¨ˆç®—ã—ã¦ã‚ã£ãŸã®ã§ãƒ¡ãƒ¢ã®å†…å®¹ã‚’è¿”ã™  // æ¨¹å½¢å›³ã®æœ«ç«¯ã«åˆ°é”ã—ãŸã¨ã: 0ç•ªç›®ã¾ã§ã®å·¥ã‚’ç”¨ã„ãŸæ™‚ã®éƒ¨åˆ†å’Œã¯è‡ªæ˜  if (idx == 0) { if (remain == 0) return true; else return false; } int ans = 0; // a[idx-1]ã‚’éƒ¨åˆ†å’Œè¨ˆç®—ã«ç”¨ã„ã‚‹å ´åˆ  if (a[idx-1] \u0026lt;= renaib \u0026amp;\u0026amp; rec(idx-1, remain - a[idx-1])) ans = 1; // a[idx-1]ã‚’éƒ¨åˆ†å’Œè¨ˆç®—ã«ç”¨ã„ãªã„å ´åˆ  if (rec(idx-1, remain)) ans = 1; return dp[idx][remain] = ans; } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; a.resize(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; a[i]; // dpãƒ†ãƒ¼ãƒ–ãƒ«åˆæœŸåŒ–  dp.assign(N+1, vector\u0026lt;int\u0026gt;(W+1, -1)); // çŠ¶æ…‹(N, W)ã‹ã‚‰æ¨¹å½¢å›³ã‚’æœ«ç«¯ã«å‘ã‹ã£ã¦æ·±ã•å„ªå…ˆæ¢ç´¢  if (rec(N, W) == 1) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } å†å¸°ã§ã¯ãªã bit å…¨æ¢ç´¢ã§ é …ã®é¸ã³æ–¹ã‚’ 2 é€²æ•°ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¦çŠ¶æ…‹ã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ï¼ãã†ã™ã‚Œã° bit å…¨æ¢ç´¢ã«ãªã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int N, W; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; vector\u0026lt;int\u0026gt; a(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; a[i]; for (int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++) { int tmpsum = 0; for (int i = 0; i \u0026lt; N; i++) { if (bit \u0026amp;\u0026amp; (1 \u0026lt;\u0026lt; i)) { tmpsum += a[i]; } } if (tmpsum == W) { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":1589287961,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1589287961,"objectID":"9fa535b48d7fdf0bb6a0f261eb3b188b","permalink":"/ja/post/partial-sums/","publishdate":"2020-05-12T21:52:41+09:00","relpermalink":"/ja/post/partial-sums/","section":"post","summary":"éƒ¨åˆ†å’Œå•é¡Œã§å…¨æ¢ç´¢ã«æ…£ã‚Œã‚‹","tags":["éƒ¨åˆ†å’Œå•é¡Œ","å…¨æ¢ç´¢","AtCoder","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°","ç«¶ãƒ—ãƒ­"],"title":"éƒ¨åˆ†å’Œå•é¡Œ","type":"post"},{"authors":[],"categories":[],"content":"2 ã¤ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ã† ã‚½ãƒ¼ãƒˆæ¸ˆã¿ ã®æ•´æ•°é…åˆ—ã‹ã‚‰ï¼Œå’ŒãŒ $X$ ã¨ãªã‚‹ã‚ˆã†ãª 2 è¦ç´ ã‚’é¸ã¶å•é¡Œã‚’è§£ãï¼\nãƒŠã‚¤ãƒ¼ãƒ–ãªã‚„ã‚Šæ–¹ã¯å…¨æ¢ç´¢ã§ $O(n^2)$ ã‹ã‹ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int x; cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a.begin(), a.end()); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (a[i] + a[j] == x) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; a[j] \u0026lt;\u0026lt; endl; } if (x \u0026lt; a[i] + a[j]) break; } } cout \u0026lt;\u0026lt; \u0026#34;non\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 2 ã¤ã®ãƒã‚¤ãƒ³ã‚¿ã§å·¦å³ã‹ã‚‰æ¢ã—ã«è¡Œãã¨ $O(n)$\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int x; cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a.begin(), a.end()); int i = 0, j = n-1; while (i \u0026lt; j) { if (a[i] + a[j] == x) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; a[j] \u0026lt;\u0026lt; endl; } else if (a[i] + a[j] \u0026lt; x) i++; else j--s; } return 0; } ","date":1589116164,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1589116164,"objectID":"95cf2e5b59da53e3f9cd6feaee61ff1d","permalink":"/ja/post/two-pointers/","publishdate":"2020-05-10T22:09:24+09:00","relpermalink":"/ja/post/two-pointers/","section":"post","summary":"2 ã¤ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ã† ã‚½ãƒ¼ãƒˆæ¸ˆã¿ ã®æ•´æ•°é…åˆ—ã‹ã‚‰ï¼Œå’ŒãŒ $X$ ã¨ãªã‚‹ã‚ˆã†ãª 2 è¦ç´ ã‚’é¸ã¶å•é¡Œã‚’è§£ãï¼ ãƒŠã‚¤ãƒ¼ãƒ–ãªã‚„ã‚Šæ–¹ã¯å…¨æ¢ç´¢ã§ $O(n^2)$ ã‹ã‹ã‚‹ï¼ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int","tags":["Two Pointers","ç«¶ãƒ—ãƒ­","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°"],"title":"Two Pointers","type":"post"},{"authors":[],"categories":[],"content":"è¤‡æ•°ã®è¦ç´ ã‚’ã¾ã¨ã‚ã¦ã‚½ãƒ¼ãƒˆ pair ã‚’ä½¿ã†ã¨ç°¡å˜ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, a(n); for (int i = 0; i \u0026lt; n; i++) { int no; string name; cin \u0026gt;\u0026gt; no \u0026gt;\u0026gt; name; cin \u0026gt;\u0026gt; no \u0026gt;\u0026gt; name; // ã‚½ãƒ¼ãƒˆã®å„ªå…ˆé †ä½ã¯ç¬¬1è¦ç´ ãƒ»ç¬¬2è¦ç´ ã®é †  sort(a.begin(), a.end()); for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; a[i].first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[i].second \u0026lt;\u0026lt; endl; } } return 0; } ã‚½ãƒ¼ãƒˆé †åºã®æŒ‡å®š std::sort() ã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯æ˜‡é †ï¼ greateré–¢æ•°ã‚’æ¯”è¼ƒé–¢æ•°ã¨ã—ã¦ä¸ãˆã‚‹ã¨é™é †ã«ã§ãã‚‹ï¼ã¾ãŸï¼Œç‹¬è‡ªã«æ¯”è¼ƒé–¢æ•°ã‚’è‡ªä½œã—ã¦ä¸ãˆã¦ã‚‚è‰¯ã„ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; void print_vector(vector\u0026lt;int\u0026gt; \u0026amp;v) { cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (int i = 0; i \u0026lt; v.size(); i++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; } bool less_mod3(int lhs, int rhs) { if ((lhs - rhs) % 3 != 0) return lhs % 3 \u0026lt; rhs % 3; else return lhs \u0026lt; rhs; } int main() { vector\u0026lt;int\u0026gt; a = {1, 4, -1, 3, 9, 5, 7}; sort(a.begin(), a.end()); print_vector(a); sort(a.begin(), a.end(), greater\u0026lt;int\u0026gt;()); print_vector(a); sort(a.begin(), a.end(), less_mod3); print_vector(a); return 0; } æ§‹é€ ä½“ã®ã‚½ãƒ¼ãƒˆ \u0026lt; æ¼”ç®—å­ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ‰ã™ã‚‹ã¨ã‚ˆã„ã‹ã‚‚ï¼ãŸã  pair ã¨ã‹ã®çµ„ã¿åˆã‚ã›ã§ç®¡ç†ã§ãã‚‹ãªã‚‰ãã£ã¡ã®ã»ã†ãŒæ‰‹é–“ã¯ã‹ã‹ã‚‰ãªã„æ„Ÿï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct Student { int no, math, english; bool operator\u0026lt;(const Student \u0026amp;s) const { if (math != s.math) return math \u0026gt; s.math; if (english != s.english) return english \u0026gt; s.english; return no \u0026lt; s.no; } } int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;Student\u0026gt; vec(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; vec[i].no \u0026gt;\u0026gt; vec[i].math \u0026gt;\u0026gt; vec[i].english; sort(vec.begin(), vec.end()); for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; vec[i].no \u0026lt;\u0026lt; endl; return 0; } æ¼”ç¿’  AIZU ONLINE JUDGE 0018 Sorting Five Numbers  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { vector\u0026lt;int\u0026gt; p(5); for (int i = 0; i \u0026lt; 5; i++) cin \u0026gt;\u0026gt; p[i]; sort(p.begin(), p.end(), greater\u0026lt;int\u0026gt;()); for (int i = 0; i \u0026lt; 5; i++) { if (i == 4) { cout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } return 0; }  AIZU ONLINE JUDGE 2198 Problem B: Moonlight Farm  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct Seed { string l; int p, a, b, c, d, e, f, s, m; double efficiency; void calc() { double duration = a + b + c + (d + e) * m; double gain = f * s * m - p; efficiency = gain / duration; } bool operator\u0026lt;(const Seed \u0026amp;s) const { return efficiency == s.efficiency ? (l \u0026lt; s.l) : efficiency \u0026gt; s.efficiency; } }; int main() { int n; while (cin \u0026gt;\u0026gt; n) { if (n == 0) break; vector\u0026lt;Seed\u0026gt; seeds(n); Seed s; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; s.l \u0026gt;\u0026gt; s.p \u0026gt;\u0026gt; s.a \u0026gt;\u0026gt; s.b \u0026gt;\u0026gt; s.c \u0026gt;\u0026gt; s.d \u0026gt;\u0026gt; s.e \u0026gt;\u0026gt; s.f \u0026gt;\u0026gt; s.s \u0026gt;\u0026gt; s.m; s.calc(); seeds.push_back(s); } sort(seeds.begin(), seeds.end()); for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; seeds[i].l \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;#\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } ","date":1589109543,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1589109543,"objectID":"6dc50be2d5089aef66707ba4068e5a07","permalink":"/ja/post/sorting/","publishdate":"2020-05-10T20:19:03+09:00","relpermalink":"/ja/post/sorting/","section":"post","summary":"è¤‡æ•°ã®è¦ç´ ã‚’ã¾ã¨ã‚ã¦ã‚½ãƒ¼ãƒˆ pair ã‚’ä½¿ã†ã¨ç°¡å˜ï¼ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, a(n); for (int i = 0; i \u0026lt; n; i++) { int no; string name; cin \u0026gt;\u0026gt; no \u0026gt;\u0026gt; name; cin \u0026gt;\u0026gt; no \u0026gt;\u0026gt; name; // ã‚½ãƒ¼ãƒˆã®å„ªå…ˆé †ä½ã¯ç¬¬1è¦","tags":["ã‚½ãƒ¼ãƒˆ","C++","ç«¶ãƒ—ãƒ­","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°","ãƒ¡ãƒ¢"],"title":"C++ã§ã‚½ãƒ¼ãƒˆã™ã‚‹","type":"post"},{"authors":[],"categories":[],"content":"ã‚¹ã‚¿ãƒƒã‚¯ã¨ã‚­ãƒ¥ãƒ¼ ã‚¹ã‚¿ãƒƒã‚¯ã¨ã‚­ãƒ¥ãƒ¼ã¯ã¨ã¦ã‚‚åŸºæœ¬çš„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ã‚¹ã‚¿ãƒƒã‚¯ã¨ã‚­ãƒ¥ãƒ¼ã®æœ¬è³ªã¯ ãƒ‡ãƒ¼ã‚¿ã‚’ã©ã®ã‚ˆã†ã«æ‰±ã†ã‹ ã¨ã„ã†éƒ¨åˆ†ï¼ã‚¹ã‚¿ãƒƒã‚¯ã‚„ã‚­ãƒ¥ãƒ¼ã¯é…åˆ—ã‚„é€£çµãƒªã‚¹ãƒˆã‚’ç”¨ã„ã¦ç”¨æ„ã«å®Ÿè£…ã§ãï¼Œé…åˆ—ã‚„é€£çµãƒªã‚¹ãƒˆã®ä¸Šæ‰‹ãªä½¿ã„æ–¹ã®éƒ¨åˆ†ãŒã‚¹ã‚¿ãƒƒã‚¯ã‚„ã‚­ãƒ¥ãƒ¼ã®æœ¬è³ªã§ã‚ã‚‹ã¨ã‚‚è¨€ãˆã‚‹ï¼ã¾ã‚ï¼Œçµ„ã¿è¾¼ã¿ç³»ãªã©è³‡æºãŒé™ã‚‰ã‚Œã¦ã„ã‚‹ç’°å¢ƒã§ã¯å®Ÿè£…æ–¹æ³•è‡ªä½“ã«æ³¨æ„ã‚’å‘ã‘ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚‹ï¼\nã‚¹ã‚¿ãƒƒã‚¯ ã‚¹ã‚¿ãƒƒã‚¯ã¯ã€Œãƒ‡ãƒ¼ã‚¿ã‚’Last-In-First-Outã¨ã„ã†ãƒãƒŠãƒ¼ã§æ‰±ã†ã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã‚‹ï¼ã‚¹ã‚¿ãƒƒã‚¯ã«ã¯ï¼Œã€Œãƒ‡ãƒ¼ã‚¿ã‚’ç©ã‚€ã€ã¨ã€Œãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã™ã€ã¨ã„ã†æ“ä½œãŒã§ãã‚‹ï¼ã“ã“ã§å¤§äº‹ãªã®ã¯ï¼Œ ä¸€ç•ªæœ€å¾Œã«è¿½åŠ ã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’ä¸€ç•ªæœ€åˆã«å–ã‚Šå‡ºã™ ã¨ã„ã†ã¨ã“ã‚ã§ã‚ã‚‹ï¼\nã‚­ãƒ¥ãƒ¼ ã‚­ãƒ¥ãƒ¼ã¯ã€Œãƒ‡ãƒ¼ã‚¿ã‚’First-In-First-Outã¨ã„ã†ãƒãƒŠãƒ¼ã§æ‰±ã†ã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã‚‹ï¼ã‚­ãƒ¥ãƒ¼ã«ã¯ã€Œãƒ‡ãƒ¼ã‚¿ã‚’å…¥ã‚Œã‚‹ã€ã¨ã€Œãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã™ã€ã¨ã„ã†æ“ä½œãŒã§ãï¼Œå¤§äº‹ãªã®ã¯ ä¸€ç•ªæœ€åˆã«è¿½åŠ ã—ãŸã‚¢ãƒ†ãƒ ã‚’ä¸€ç•ªæœ€åˆã«å–ã‚Šå‡ºã™ ã¨ã„ã†ã¨ã“ã‚ã§ã‚ã‚‹ï¼\nå®Ÿè£… ç°¡æ˜“çš„ãªå®Ÿè£…ã‚’ã—ã¦ã¿ã‚‹ï¼ã‚¹ã‚¿ãƒƒã‚¯ã¨ã‚­ãƒ¥ãƒ¼ã¯ã¨ã¦ã‚‚åŸºæœ¬çš„ã§å¤§äº‹ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ãªã®ã§ï¼Œå¤§æŠµã®å ´åˆã‚‚ã£ã¨ä½œã‚Šè¾¼ã¾ã‚ŒãŸå®Ÿè£…ãŒæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãªã©ã®å½¢ã§æä¾›ã•ã‚Œã¦ã„ã‚‹ã®ã§ï¼Œè‡ªå‰å®Ÿè£…ã‚ˆã‚Šãã£ã¡ã‚’ä½¿ã†ã»ã†ãŒå®‰å¿ƒæ„ŸãŒã‚ã‚‹ï¼ä»¥ä¸‹ã§ã¯é…åˆ—ã‚’ç”¨ã„ãŸå®Ÿè£…ã‚’ç¤ºã™ãŒï¼Œã»ã‹ã«ã‚‚é€£çµãƒªã‚¹ãƒˆã‚’ç”¨ã„ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ï¼\nã‚¹ã‚¿ãƒƒã‚¯ ã‚¹ã‚¿ãƒƒã‚¯ã‚’é…åˆ—ã‚’ç”¨ã„ã¦å®Ÿè£…ã™ã‚‹ï¼ã“ã“ã§ã¯ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸€ç•ªä¸Šã‚’æŒ‡ã™å¤‰æ•°topãŒå¿…è¦ã«ãªã‚Šï¼Œã“ã®topãŒã‚¹ã‚¿ãƒƒã‚¯ã®çœŸé«„ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAX = 1000000; int st[MAX]; int top = 0; void init() { top = 0; } bool is_empty() { return (top == 0); } bool is_full() { return (top == MAX); } void push(int v) { if (is_full()) { cout \u0026lt;\u0026lt; \u0026#34;error: stack is full\u0026#34; \u0026lt;\u0026lt; endl; return; } st[top] = v; top++; } int pop() { if (is_empty()) { cout \u0026lt;\u0026lt; \u0026#34;error: sstack is empty\u0026#34; \u0026lt;\u0026lt; endl; return -1; } top--; return st[top]; } int main() { init(); push(3); push(5); push(7); cout \u0026lt;\u0026lt; pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; pop() \u0026lt;\u0026lt; endl; push(9); cout \u0026lt;\u0026lt; pop() \u0026lt;\u0026lt; endl; return 0; } ã‚­ãƒ¥ãƒ¼ ã‚­ãƒ¥ãƒ¼ã‚’é…åˆ—ã‚’ç”¨ã„ã¦å®Ÿè£…ã™ã‚‹ï¼ã“ã“ã§ã¯ã‚­ãƒ¥ãƒ¼ã®é ­ã¨ãŠå°»ã®ç®¡ç†ãŒå¿…è¦ã«ãªã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAX = 1000000; int qu[MAX]; int tail = 0, head = 0; void init() { head = tail = 0; } bool is_empty() { return (head == tail); } bool is_full() { return (head == (tail+1)%MAX); } void enqueue(int v) { if (is_full()) { cout \u0026lt;\u0026lt; \u0026#34;error: queue is full\u0026#34; \u0026lt;\u0026lt; endl; return; } qu[tail] = v; tail++; if (tail == MAX) { tail == 0; } } int dequeue() { if (is_empty()) { cout \u0026lt;\u0026lt; \u0026#34;error: queue is empty\u0026#34; \u0026lt;\u0026lt; endl; return -1; } int res = qu[head]; head++; if (head == MAX) head = 0; return res; } int main() { init(); enqueue(3); enqueue(5); enqueue(7); cout \u0026lt;\u0026lt; dequeue() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; dequeue() \u0026lt;\u0026lt; endl; enqueue(9); cout \u0026lt;\u0026lt; dequeue() \u0026lt;\u0026lt; endl; return 0; } æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†  std::stack  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { stack\u0026lt;int\u0026gt; s; s.push(3); s.push(5); s.push(7); cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; s.pop(); cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; s.pop(); cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; s.pop(); s.push(9); cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; s.pop(); reteurn 0; }  std::queue  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { queue\u0026lt;int\u0026gt; q; q.push(3); q.push(5); q.push(7); cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; endl; q.pop(); cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; endl; q.pop(); cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; endl; q.pop(); q.push(9); cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; endl; q.pop(); return 0; } ã‚¹ã‚¿ãƒƒã‚¯ã‚„ã‚­ãƒ¥ãƒ¼ã§è§£æ±ºã§ãã‚‹å•é¡Œ ã‚«ãƒƒã‚³åˆ—ã®æ•´åˆæ€§ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç”¨ã„ã¦ç¢ºèªã™ã‚‹å•é¡Œ ((()(()))())(())ã®ã‚ˆã†ãªã‚«ãƒƒã‚³è¨˜å·ã®åˆ—ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼Œå·¦æ‹¬å¼§ã¨å³æ‹¬å¼§ã®å¯¾å¿œãŒãã¡ã‚“ã¨å–ã‚Œã¦ã„ã‚‹ã®ã‹ã‚’ç¢ºèªã™ã‚‹å•é¡Œã¯ï¼Œã‚¹ã‚¿ãƒƒã‚¯ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ãã‚Œã„ã«è§£ã‘ã‚‹ï¼\nã‚«ãƒƒã‚³åˆ—ã®ç‰¹å¾´ã¯ï¼Œã‚«ãƒƒã‚³åˆ—ã‚’å·¦ã‹ã‚‰èª­ã‚“ã§ã„ã£ãŸã¨ãã« ä¸€ç•ªæœ€å¾Œã«è¦‹ã¤ã‘ãŸå·¦æ‹¬å¼§ã«å¯¾å¿œã™ã‚‹ã®ã¯ï¼Œä¸€ç•ªæœ€åˆã«è¦‹ã¤ã‘ãŸå³æ‹¬å¼§ã§ã‚ã‚‹ ã¨ã„ã†ã¨ã“ã‚ã§ã‚ã‚‹ï¼ã“ã®æ€§è³ªãŒã¾ã•ã—ã LIFOã§ã‚ã‚Šï¼Œã‚¹ã‚¿ãƒƒã‚¯ã‚’ç”¨ã„ã‚‹ã¨ãã‚Œã„ã«è§£ã‘ã‚‹ç†ç”±ã§ã‚ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; bool check(const string \u0026amp;s) { stack\u0026lt;int\u0026gt; st; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ps; for (int i = 0; i \u0026lt; (int)s.size(); i++) { if (s[i] == \u0026#39;(\u0026#39;) st.push(i); else { if (st.empty()) { cout \u0026lt;\u0026lt; \u0026#34;error\u0026#34; \u0026lt;\u0026lt; endl; return false; } int t = st.top(); st.pop(); ps.push_back(make_pair(t, i)); } } if (!st.empty()) { cout \u0026lt;\u0026lt; \u0026#34;too many (\u0026#34; \u0026lt;\u0026lt; endl; return false; } sort(ps.begin(), ps.end()); for (auto p: ps) { cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { check(\u0026#34;((()(()))())(())\u0026#34;); return 0; } é€†ãƒãƒ¼ãƒ©ãƒ³ãƒ‰è¨˜æ³•ã§è¨˜è¿°ã•ã‚ŒãŸæ•°å¼ã®è¨ˆç®— é€†ãƒãƒ¼ãƒ©ãƒ³ãƒ‰è¨˜æ³•ã¨ã¯ï¼Œæ•°å¼ã®è¨˜æ³•ã®1ã¤ã§ï¼Œ\n$$ (1 + 2) \\times (3 - 4) $$\nã¨ã„ã†ä¸€èˆ¬çš„ãªã‚‚ã®ã«å¯¾ã—ã¦ï¼Œ\n$$ 1 \\space 2 \\space + 3 \\space 4 \\space - \\space \\times $$\nã¨ï¼Œ æ¼”ç®—å­ã‚’ï¼Œæ¼”ç®—å¯¾è±¡ã«å¯¾ã—ã¦å¾Œç½®ã™ã‚‹ ã‚ˆã†ãªè¨˜æ³•ã§ã‚ã‚‹ï¼\né€†ãƒãƒ¼ãƒ©ãƒ³ãƒ‰è¨˜æ³•ã®ç‰¹å¾´ã¯ï¼Œé€†ãƒãƒ¼ãƒ©ãƒ³ãƒ‰è¨˜æ³•ã§æ›¸ã‹ã‚ŒãŸæ•°å¼ã‚’å·¦ã‹ã‚‰å³ã¸èª­ã‚“ã§ã„ãæ™‚ã«ï¼Œæœ€åˆã«é­é‡ã™ã‚‹æ¼”ç®—å­ã®é©ç”¨å…ˆãŒï¼Œä¸€ç•ªæœ€å¾Œã«é­é‡ã™ã‚‹æ•°å­—ã§ã‚ã‚‹ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ï¼ã“ã®ç‰¹å¾´ãŒã‚¹ã‚¿ãƒƒã‚¯ã®ãƒ‡ãƒ¼ã‚¿ã®æ‰±ã„æ–¹ã¨ç¬¦åˆã™ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { string s; stack\u0026lt;int\u0026gt; st; while (cin \u0026gt;\u0026gt; s) { if (s == \u0026#34;|\u0026#34;) break; int a, b; if (s == \u0026#34;+\u0026#34;) { b = st.top(); st.pop(); a = st.top(); st.pop(); st.push(a + b); } else if (s == \u0026#34;-\u0026#34;) { b = st.top(); st.pop(); a = st.top(); st.pop(); st.push(a - b); } else if (s == \u0026#34;*\u0026#34;) { b = st.top(); st.pop(); a = st.top(); st.pop(); st.push(a * b); } else if (s == \u0026#34;/\u0026#34;) { b = st.top(); st.pop(); a = st.top(); st.pop(); st.push(a / b); } else { st.push(stoi(s)); } } cout \u0026lt;\u0026lt; st.top() \u0026lt;\u0026lt; endl; return 0; } ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ä¸­ã®é¢ç©æœ€å¤§ã®é•·æ–¹å½¢ ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ï¼Œãã®ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®å¤–æ ã«å†…åŒ…ã•ã‚Œã‚‹ã‚ˆã†ãªé•·æ–¹å½¢ã®ã†ã¡ï¼Œé¢ç©ãŒæœ€å¤§ã®ã‚‚ã®ã‚’æ±‚ã‚ã‚‹å•é¡Œã¯ã‚¹ã‚¿ãƒƒã‚¯ã§è§£ãã“ã¨ãŒã§ãã‚‹ï¼\nã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½¿ã‚ãªã„ã§æ±‚ã‚ã‚ˆã†ã¨ã™ã‚‹ãªã‚‰ã°ï¼Œé•·æ–¹å½¢ã®åº•è¾ºã‚’å½¢æˆã™ã‚‹ç¯„å›²ã‚’å…¨ã¦æ¢ç´¢ã™ã‚Œã°åŸç†çš„ã«ã¯è§£ãã“ã¨ãŒã§ãï¼Œ$O(n^2)$ã®è¨ˆç®—é‡ãŒã‹ã‹ã‚‹ï¼\nint get_rectangle_area(int size, int buffer[]) { int maxv = 0; for (int i = 0; i \u0026lt; size; i++) { for (int j = i; j \u0026lt; size; j++) { int minh = INF; for (int k = i; k \u0026lt;= j; k++) { minh = min(minh, buffer[k]); } maxv = max(maxv, minh * (j-i+1)); } } return maxv; } ã“ã‚Œã‚’ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç”¨ã„ã‚‹ã¨ï¼Œ$O(n)$ã§è§£ãã“ã¨ãŒã§ãã‚‹ï¼\nã‚¹ã‚¿ãƒƒã‚¯ã«ã¯ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’å½¢æˆã™ã‚‹å„é•·æ–¹å½¢ã®æƒ…å ±ã‚’è¨˜éŒ²ã™ã‚‹ï¼ã“ã®æƒ…å ±ã«ã¯ï¼Œé•·æ–¹å½¢ã®é«˜ã•heightã¨ãã®å·¦ç«¯ã®ä½ç½®posãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹ï¼ã¾ãšï¼Œã‚¹ã‚¿ãƒƒã‚¯ã‚’ç©ºã«ã—ã¦ï¼Œãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’å·¦ã‹ã‚‰é †ç•ªã«å³ã«å‘ã‹ã£ã¦è¦‹ã¦ã„ããªãŒã‚‰ï¼ˆiãŒ0ã‹ã‚‰n-1ã¾ã§å‹•ããªãŒã‚‰ï¼‰\n ã‚¹ã‚¿ãƒƒã‚¯ãŒç©ºãªã‚‰ã°ï¼Œã‚¹ã‚¿ãƒƒã‚¯ã«ä»Šè¦‹ã¦ã„ã‚‹é•·æ–¹å½¢ã®æƒ…å ±(height, pos)ã‚’ç©ã‚€ ã‚¹ã‚¿ãƒƒã‚¯ã®æœ€ä¸Šä½ã«ç©ã¾ã‚Œã¦ã„ã‚‹é•·æ–¹å½¢ã®æƒ…å ±ã®é«˜ã•ãŒï¼Œä»Šè¦‹ã¦ã„ã‚‹é•·æ–¹å½¢ã‚ˆã‚Šä½ã„ãªã‚‰ã°ï¼Œã‚¹ã‚¿ãƒƒã‚¯ã«ä»Šè¦‹ã¦ã„ã‚‹é•·æ–¹å½¢ã®(height, pos)ã‚’ç©ã‚€ ã‚¹ã‚¿ãƒƒã‚¯ã®æœ€ä¸Šä½ã«ç©ã¾ã‚Œã¦ã„ã‚‹é•·æ–¹å½¢ã®æƒ…å ±ã®é«˜ã•ãŒï¼Œä»Šè¦‹ã¦ã„ã‚‹é•·æ–¹å½¢ã‚ˆã‚Šç­‰ã—ã„ãªã‚‰ã°ï¼Œä½•ã‚‚ã—ãªã„ ã‚¹ã‚¿ãƒƒã‚¯ã®æœ€ä¸Šä½ã«ç©ã¾ã‚Œã¦ã„ã‚‹é•·æ–¹å½¢ã®æƒ…å ±ã®é«˜ã•ãŒï¼Œä»Šè¦‹ã¦ã„ã‚‹é•·æ–¹å½¢ã‚ˆã‚Šé«˜ã„ãªã‚‰ã°ï¼Œ  ã‚¹ã‚¿ãƒƒã‚¯ãŒç©ºã§ãªãï¼Œã‚¹ã‚¿ãƒƒã‚¯ã®æœ€ä¸Šä½ã«ç©ã¾ã‚Œã¦ã„ã‚‹é•·æ–¹å½¢ã®æƒ…å ±ã®é«˜ã•ãŒï¼Œä»Šè¦‹ã¦ã„ã‚‹é•·æ–¹å½¢ã®é«˜ã•ä»¥ä¸Šã§ã‚ã‚‹é™ã‚Šï¼Œã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰é•·æ–¹å½¢ã®æƒ…å ±ã‚’å–ã‚Šå‡ºã—ï¼Œãã®é¢ç©ã‚’è¨ˆç®—ã—ï¼Œæœ€å¤§å€¤ã‚’æ›´æ–°ã™ã‚‹ï¼é•·æ–¹å½¢ã®æ¨ªã®é•·ã•ã¯ç¾åœ¨ã®ä½ç½®ã¨è¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹å·¦ç«¯ã®ä½ç½®ã‹ã‚‰è¨ˆç®—ã§ãã‚‹ï¼ 1ãŒçµ‚ã‚ã£ãŸã‚‰ï¼Œã‚¹ã‚¿ãƒƒã‚¯ã«ä»Šè¦‹ã¦ã„ã‚‹é•·æ–¹å½¢ã®æƒ…å ±ã‚’è¿½åŠ ã™ã‚‹ï¼ãŸã ã—ï¼Œã“ã®ã¨ãã®å·¦ç«¯ã®ä½ç½®ã¯æœ€å¾Œã«ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å–ã‚Šå‡ºã—ãŸé•·æ–¹å½¢ã®posã®å€¤ã¨ã™ã‚‹ï¼    #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAX = 110000; struct Rectangle { long long height; int pos; } long long get_rectangle_area(int size, long long buffer[]) { stack\u0026lt;Rectangle\u0026gt; S; long long maxv = 0; buffer[size] = 0; for (int i = 0; i \u0026lt;= size; i++) { Rectangle rec; rect.height = buffer[i]; rect.pos = i; if (S.empty()) S.push(rect); else { if (S.top().height \u0026lt; rect.height) S.push(rect); else if (rect.height \u0026lt; S.top().height) { int target = i; while (!S.empty() \u0026amp;\u0026amp; rect.height \u0026lt;= S.top().height) { Rectangle pre = S.top(); S.pop(); long long area = pre.height * (i - pre.pos); maxv = max(maxv, area); target = pre.pos; } rect.pos = target; S.push(rect); } } } return maxv; } int main() { int size; long long buffer[MAX + 1]; while (1) { cin \u0026gt;\u0026gt; size; if (size == 0) break; for (int i = 0; i \u0026lt; size; i++) { cin \u0026gt;\u0026gt; buffer[i]; } cout \u0026lt;\u0026lt; get_rectangle_area(size, buffer) \u0026lt;\u0026lt; endl; } return 0; } ä¸Šã®ã‚ˆã†ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®äºœç¨®ã¨ã—ã¦ï¼Œæ•°åˆ—$A_1, A_2, \u0026hellip;, A_N$ã«å¯¾ã—ã¦ï¼Œ$A_i \\leq A_j$ï¼ˆ$j \u0026lt; i$ï¼‰ãªã‚‹æœ€å¤§ã®$j$ã‚’è¦‹ã¤ã‘ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒã‚ã‚‹ï¼ãŸã¨ãˆã°ï¼Œæ•°åˆ—\n$$ 6, 2, 4, 1, 3, 5, 7 $$\nã«å¯¾ã—ã¦ã¯\n$$ 0, 1, 1, 3, 3, 1, 0 $$\nã¨ãªã‚‹ï¼åŸç†çš„ã«ã¯ï¼Œå„è¦ç´ ã«å¯¾ã—ã¦ãã‚Œã‚ˆã‚Šå‰ã®ã™ã¹ã¦ã®è¦ç´ ã‚’æ¢ç´¢ã™ã‚Œã°ã‚ˆãï¼Œ$O(N^2)$ã‹ã‹ã‚‹ãŒè§£ã‘ã‚‹ï¼ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç”¨ã„ã‚‹ã¨$O(N)$ã§è§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stsdc++.h\u0026gt;using namespace std; const int INF = 100000000; int main() { int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;int\u0026gt; A(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; stack\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; st; st.push(make_pair(INF, 0)); for (int i = 0; i \u0026lt; N; i++) { while (st.top().first \u0026lt; A[i]) st.pop(); cout \u0026lt;\u0026lt; st.top().second() \u0026lt;\u0026lt; \u0026#34;, \u0026#34;\u0026gt;\u0026gt; st.push(make_pair(A[i], i+1)); } cout \u0026lt;\u0026lt; endl; return 0; } ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ­ãƒ“ãƒ³ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚° OSã®ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã«ç”¨ã„ã‚‰ã‚Œã¦ã„ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ãã‚Œãã‚Œã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä¸€å®šæ™‚é–“ã ã‘å‡¦ç†ã—ã¦ï¼Œãã‚Œã§çµ‚ã‚ã‚‰ãªã‘ã‚Œã°ã‚­ãƒ¥ãƒ¼ã®æœ€å¾Œã«çªã£è¾¼ã‚€ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int N, Q; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; queue\u0026lt;pair\u0026lt;string ,int\u0026gt;\u0026gt; que; for (int i = 0; i \u0026lt; N; i++) { string name; int time; cin \u0026gt;\u0026gt; name \u0026gt;\u0026gt; time; que.push(make_pair(name, time)); } int current_time = 0; while (!que.empty()) { auto now = que.front(); que.pop(); if (Q \u0026lt; now.second) { current_time += Q; now.second -= Q; que.push(now); } else { current_time += now.second; cout \u0026lt;\u0026lt; now.first \u0026lt;\u0026lt; \u0026#34; @ \u0026#34; \u0026lt;\u0026lt; current_time \u0026lt;\u0026lt; endl; } } } è¿·è·¯ ã‚°ãƒªãƒƒãƒ‰ã‚°ãƒ©ãƒ•ã¨ã—ã¦ã‚°ãƒ©ãƒ•ãŒä¸ãˆã‚‰ã‚Œï¼Œãã®è¿·è·¯ãŒè§£ã‘ã‚‹ã®ã‹ï¼Œè§£ã‘ã‚‹ãªã‚‰æœ€çŸ­æ‰‹æ•°ã¯ã„ãã¤ã§ï¼Œãã®ãƒ«ãƒ¼ãƒˆã‚’é€šã‚Œã°æœ€çŸ­æ‰‹æ•°ã§è¿·è·¯ã‚’è§£ã‘ã‚‹ã®ã‹ã‚’ä¸ãˆã‚‹ï¼å¹…å„ªå…ˆæ¢ç´¢ã‚„æ·±ã•å„ªå…ˆæ¢ç´¢ã§ï¼Œã‚¹ã‚¿ãƒ¼ãƒˆã‹ã‚‰ã‚´ãƒ¼ãƒ«ã¾ã§æ¢ç´¢ã—ã¦ã„ãã®ãŒè‰¯ã„ï¼ä»¥ä¸‹ã§ã¯å¹…å„ªå…ˆæ¢ç´¢ã§è§£ãï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int dh[4] = {1, 0, -1, 0}; const int dw[4] = {0, 1, 0, -1}; int main() { int H, W; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W; vector\u0026lt;string\u0026gt; maze(H); for (int h = 0; h \u0026lt; H; h++) cin \u0026gt;\u0026gt; maze[h]; int sh, sw, gh, gw; for (int i = 0; i \u0026lt; H; i++) { for (int j = 0; j \u0026lt; W; j++) { if (maze[i][j] == \u0026#39;S\u0026#39;) { sh = i; sw = j; } if (maze[i][j] == \u0026#39;G\u0026#39;) { gh = i; gw = j; } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(H, vector\u0026lt;int\u0026gt;(W, -1)); dist[sh][sw] = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; prevh(H, vector\u0026lt;int\u0026gt;(W, -1)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; prevw(H, vector\u0026lt;int\u0026gt;(W, -1)); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; q.push(make_pair(sh, sw)); while (!q.empty()) { auto p = q.front(); q.pop(); int h = p.first; int w = p.second; for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = h + dh[dir]; int nw = w + dw[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; if (maze[nh][nw] == \u0026#39;#\u0026#39;) continue; if (dist[nh][nw] != -1) continue; q.push(make_pair(nh, nw)); dist[nh][nw] = dist[h][w] + 1; prevh[nh][nw] = h; prevw[nh][nw] = w; } } int h = gh, w = gw; while (h != -1 \u0026amp;\u0026amp; w != -1) { maze[h][w] = \u0026#39;o\u0026#39;; int ph = prevh[h]; int pw = prevw[w]; h = ph, w = pw; } for (int i = 0; i \u0026lt; H; i++) { for (int j = 0; j \u0026lt; W; j++) { cout \u0026lt;\u0026lt; std::setw(3) \u0026lt;\u0026lt; maze[i][j]; } cout \u0026lt;\u0026lt; endl; } return 0; } ","date":1586521087,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1586521087,"objectID":"63f0e3d0709ab78a67173b9dad2d4d7a","permalink":"/ja/post/stack-and-queue/","publishdate":"2020-04-10T21:18:07+09:00","relpermalink":"/ja/post/stack-and-queue/","section":"post","summary":"ã‚¹ã‚¿ãƒƒã‚¯ã¨ã‚­ãƒ¥ãƒ¼ ã‚¹ã‚¿ãƒƒã‚¯ã¨ã‚­ãƒ¥ãƒ¼ã¯ã¨ã¦ã‚‚åŸºæœ¬çš„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ã‚¹ã‚¿ãƒƒã‚¯ã¨ã‚­ãƒ¥ãƒ¼ã®æœ¬è³ªã¯ ãƒ‡ãƒ¼ã‚¿ã‚’ã©ã®ã‚ˆã†ã«æ‰±ã†ã‹ ã¨ã„ã†éƒ¨åˆ†ï¼ã‚¹ã‚¿ãƒƒã‚¯ã‚„ã‚­ãƒ¥ãƒ¼ã¯é…","tags":["Stack","ã‚¹ã‚¿ãƒƒã‚¯","Queue","ã‚­ãƒ¥ãƒ¼","FIFO","LIFO","AtCoder","Competitive Programming","C++","cpp","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°","ç«¶ãƒ—ãƒ­","ABC"],"title":"ã‚¹ã‚¿ãƒƒã‚¯ã¨ã‚­ãƒ¥ãƒ¼","type":"post"},{"authors":[],"categories":[],"content":"Union-Findæœ¨ ã€Œã‚¢ã‚¤ãƒ†ãƒ ã®ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã€ã‚’æœ¨ã‚’ç”¨ã„ã¦ç®¡ç†ã™ã‚‹ï¼å…·ä½“çš„ã«ã¯ï¼Œã€ŒåŒã˜ã‚°ãƒ«ãƒ¼ãƒ—ã«æ‰€å±ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ åŒå£«ã¯ï¼Œæ ¹ã‚’åŒã˜ã¨ã™ã‚‹æœ¨ã«å±ã™ã‚‹ã€ã¨ã—ã¦ç®¡ç†ã™ã‚‹ï¼ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã®æƒ…å ±ã‚’æœ¨ã‚’ä½¿ã£ã¦ç®¡ç†ã™ã‚‹ã“ã¨ã®ã‚¦ãƒ¬ã‚·ãƒŸã¯ï¼Œã€Œã‚¢ã‚¤ãƒ†ãƒ $i$ã¨ã‚¢ã‚¤ãƒ†ãƒ $2$ãŒåŒã˜ã‚°ãƒ«ãƒ¼ãƒ—ã«å±ã—ã¦ã„ã‚‹ã‹ã€ã¨ã€Œã‚¢ã‚¤ãƒ†ãƒ $1$ã«å±ã—ã¦ã„ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã‚¢ã‚¤ãƒ†ãƒ $2$ã«å±ã—ã¦ã„ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½µåˆã—ã¦1ã¤ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã™ã‚‹ã€ã¨ã„ã†å‡¦ç†ãŒé«˜é€Ÿã«å®Ÿç¾ã§ãã‚‹ã“ã¨ï¼\nå®Ÿè£… struct UnionFind { vector\u0026lt;int\u0026gt; parents; UnionFind(int size): parents(size) { for (int i = 0; i \u0026lt; size; i++) parents[i] = i; } int root(int x) { if (parents[x] == x) return x; return parents[x] = root(parents[x]); } void unite(int x, int y) { int rootx = root(x); int rooty = root(y); if (rootx == rooty) return; parents[rootx] = rooty; } bool same(int x, int y) { int rootx = root(x); int rooty = root(y); return rootx == rooty; } } ç·´ç¿’å•é¡Œ  ABC 97 D ATC 1 B ARC 32 D  è§£èª¬ ABC 97 D #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct UnionFind { vector\u0026lt;int\u0026gt; parents; UnionFind(int size): parents(size) { for (int i = 0; i \u0026lt; size; i++) parents[i] = i; } int root(int x) { if (parents[x] == x) return x; return parents[x] = root(parents[x]); } void unite(int x, int y) { int rootx = root(x); int rooty = root(y); if (rootx == rooty) return; parents[rootx] = rooty; } bool same(int x, int y) { int rootx = root(x); int rooty = root(y); return rootx == rooty; } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;int\u0026gt; P(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; P[i]; UnionFind tree(N); for (int i = 0; i \u0026lt; M; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--; y--; tree.unite(x, y); } int cnt = 0; for (int i = 0; i \u0026lt; N; i++) { if (tree.same(i. P[i]-1)) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } ATC 1 B #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct UnionFind { vector\u0026lt;int\u0026gt; parents; UnionFind(int size): parents(size) { for (int i = 0; i \u0026lt; size; i++) parents[i] = i; } int root(int x) { if (parents[x] == x) return x; return parents[x] = root(parents[x]); } void unite(int x, int y) { int rootx = root(x); int rooty = root(y); if (rootx == rooty) return; parents[rootx] = rooty; } bool same(int x, int y) { int rootx = root(x); int rooty = root(y); return rootx == rooty; } } int main() { int N, Q; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; UnionFind tree(N); for (int i = 0; i \u0026lt; Q; i++) { int p, x, y; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (p == 0) { tree.unite(x, y); } els { if (tree.same(x, y)) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } ARC 32 D #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct UnionFind { vector\u0026lt;int\u0026gt; parents; UnionFind(int size): parents(size) { for (int i = 0; i \u0026lt; size; i++) parents[i] = i; } int root(int x) { if (parents[x] == x) return x; return parents[x] = root(parents[x]); } void unite(int x, int y) { int rootx = root(x); int rooty = root(y); if (rootx == rooty) return; parents[rootx] = rooty; } bool same(int x, int y) { int rootx = root(x); int rooty = root(y); return rootx == rooty; } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; UnionFind tree(N); for (int i = 9; i \u0026lt; M; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--; y--; tree.unite(x, y); } int cnt = 0; for (int i = 0; i \u0026lt; N; i++) { if (!tree.same(0, i)) { tree.unite(0, i); cnt++; } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } ","date":1586510431,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1586510431,"objectID":"c3db9d64022bc75c2a863bafc3f4b2d7","permalink":"/ja/post/union-find-tree/","publishdate":"2020-04-10T18:20:31+09:00","relpermalink":"/ja/post/union-find-tree/","section":"post","summary":"Union-Findæœ¨ ã€Œã‚¢ã‚¤ãƒ†ãƒ ã®ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã€ã‚’æœ¨ã‚’ç”¨ã„ã¦ç®¡ç†ã™ã‚‹ï¼å…·ä½“çš„ã«ã¯ï¼Œã€ŒåŒã˜ã‚°ãƒ«ãƒ¼ãƒ—ã«æ‰€å±ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ åŒå£«ã¯ï¼Œæ ¹ã‚’åŒã˜ã¨ã™ã‚‹æœ¨ã«","tags":[],"title":"Union Find Tree","type":"post"},{"authors":[],"categories":[],"content":"ã¯ã˜ã‚ã«   å†å¸°é–¢æ•°ã«å¯¾ã™ã‚‹ã€Œãªã‚“ã¨ãªãã‚ã‹ã‚‹ã€ã‚’ã€Œæ›¸ã‘ã‚‹ã€ã«ã¾ã§æŒã£ã¦ã„ããŸã„ã®ã§ï¼Œå­¦ã³ç›´ã—ï¼\n  @drken ã•ã‚“ã®ã€Œå†å¸°é–¢æ•°ã‚’å­¦ã¶ã¨ï¼Œã©ã‚“ãªä¸–ç•ŒãŒåºƒãŒã‚‹ã‹ã€ã‚’å‚è€ƒã«ï¼Œå†™çµŒã—ãªãŒã‚‰å­¦ç¿’ï¼\n ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼    å†å¸°é–¢æ•°  å†å¸°é–¢æ•°ï¼šè‡ªåˆ†è‡ªèº«ã‚’å‘¼ã³å‡ºã™  æˆ»ã‚Šå€¤ã®å‹ func(å¼•æ•°) { if (ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹) { return ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«å¯¾ã™ã‚‹å€¤; } func(æ¬¡ã®å¼•æ•°); // ã“ã“ã§å†å¸°å‘¼ã³å‡ºã— return ç­”ãˆ; }   å†å¸°é–¢æ•°ã‚’æ›¸ãã¨ãã®ãƒã‚¤ãƒ³ãƒˆ\n ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«å¯¾ã—ã¦å¿…ãšreturnã™ã‚‹ å†å¸°å‘¼ã³å‡ºã—ã‚’ã™ã‚‹ã¨ãï¼Œã‚‚ã¨ã®å•é¡Œã‚ˆã‚Šå°ã•ã„å•é¡Œã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã‚’è¡Œã†ï¼ã‚ˆã‚Šå°ã•ã„å•é¡Œã®ç³»åˆ—ãŒæœ€çµ‚çš„ã«ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«ãŸã©ã‚Šç€ãã‚ˆã†ã«ã™ã‚‹    ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«å¯¾ã™ã‚‹å‡¦ç†ã‚’å¿…ãšå…¥ã‚Œã‚‹ï¼å…¥ã‚Œãªã„ã¨ç„¡é™ã«è‡ªåˆ†ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ãªã£ã¦ stack overflow\n  $n$ä»¥ä¸‹ã®æ­£ã®æ•´æ•°ã®ç·å’Œã‚’å†å¸°ã§è¨ˆç®—ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ \n  int sum(int n) { if (n == 0) return 0; // base case  return sum(n - 1) + n; }   ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«å¯¾ã—ã¦ã®returnã‚’æ›¸ãã“ã¨ã§ï¼Œå†å¸°é–¢æ•°ã®æœ‰é™åœæ­¢æ€§ãŒå¾—ã‚‰ã‚Œã‚‹\n  ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã®ç¬¬$n$é …ã‚’å†å¸°é–¢æ•°ã§æ±‚ã‚ã‚‹\n  int fibo(int n) { if (n == 0) return 0; // base case  else if (n == 1) return 1; // base case  return fibo(n - 1) + fibo(n - 2); }   ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã®ç¬¬$n$é …ã‚’å†å¸°é–¢æ•°ã§æ±‚ã‚ã‚‹å®Ÿè£…ã§ã¯ï¼Œ$n$ãŒå¤§ãããªã‚‹ã¨å†å¸°é–¢æ•°ã®å‘¼ã³å‡ºã—ãŒçˆ†ç™ºã—ã¦ã—ã¾ã†\n  ãªã®ã§ï¼Œçµæœã‚’ãƒ¡ãƒ¢ã—ã¦ãŠãã¨ä¸å¿…è¦ã«å†å¸°é–¢æ•°ã‚’å‘¼ã³å‡ºã™å¿…è¦ãŒãªããªã‚Šå¤§ããª$n$ã«å¯¾ã—ã¦ã‚‚è¨ˆç®—å¯èƒ½ã«ãªã‚‹ -\u0026gt; ãƒ¡ãƒ¢åŒ–å†å¸°ï¼ˆå‹•çš„è¨ˆç”»æ³•ï¼‰\n  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { vector\u0026lt;long long\u0026gt; table(50); table[0] = 0; table[1] = 1; for (int n = 2; i \u0026lt; 50; i++) { table[n] = table[n-1] + table[n-2]; } return 0; } long long fibo(int n, vector\u0026lt;long long\u0026gt; \u0026amp;memo) { if (n == 0) return 0; // base case  else if (n == 1) return 1; // base case  if (memo[n] != -1) return memo[n]; // è¨ˆç®—æ¸ˆã¿ãªã®ã§ãƒ¡ãƒ¢ã£ã¦ã‚ã£ãŸã®ã‚’è¿”ã™  return memo[n-1] + memo[n-2]; }   å†å¸°é–¢æ•°ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªå•é¡Œã§ä½¿ãˆã‚‹\n ï¼ˆ$n$ã‚’å¤‰æ•°ã¨ã—ã¦ï¼‰$n$é‡ã®foræ–‡ã‚’æ›¸ããŸã„ã¨ãï¼šæ•°ç‹¬ã‚½ãƒ«ãƒãƒ»éƒ¨åˆ†å’Œå•é¡Œãªã© ã‚°ãƒ©ãƒ•ä¸Šã®æ¢ç´¢ï¼šãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆãƒ»ã‚µã‚¤ã‚¯ãƒ«æ¤œå‡ºãƒ»äºŒéƒ¨ã‚°ãƒ©ãƒ•åˆ¤å®šãªã© å†å¸°çš„ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼šãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ã®äº’é™¤æ³•ãƒ»ç¹°ã‚Šè¿”ã—è‡ªä¹—æ³• ãƒ»å†å¸°ä¸‹é™æ§‹æ–‡è§£æãªã© åˆ†å‰²çµ±æ²»æ³•ï¼šãƒãƒ¼ã‚¸ã‚½ãƒ¼ãƒˆãƒ»ã‚¯ã‚¤ãƒƒã‚¯ã‚½ãƒ¼ãƒˆãªã© ãƒ¡ãƒ¢åŒ–å†å¸°ãƒ»å‹•çš„è¨ˆç”»æ³•    $n$é‡ã®forãƒ«ãƒ¼ãƒ—ã‚’æ›¸ããŸã„ï¼š$a_i$ï¼ˆ$i = 0, 1, \u0026hellip;, n-1$ï¼‰å††ã®ã‚³ã‚¤ãƒ³ãŒãã‚Œãã‚Œ 1 æšãšã¤æ‰‹å…ƒã«ã‚ã‚‹ã¨ãï¼Œåˆè¨ˆãŒ$X$å††ã«ãªã‚‹ã‚ˆã†ãªã‚³ã‚¤ãƒ³ã®é¸ã³æ–¹ã¯ä½•é€šã‚Šã‚ã‚‹ã‹\n å…¨éƒ¨ã§$2^n$é€šã‚Šã®ã‚³ã‚¤ãƒ³ã®é¸ã³æ–¹ãŒã‚ã‚‹ å„ã‚³ã‚¤ãƒ³ã«ã¤ã„ã¦ã€Œé¸ã¶é¸ã°ãªã„ã€ã§forãƒ«ãƒ¼ãƒ—ã‚’æ›¸ã“ã†ã¨ã™ã‚‹ã¨$n$é‡ã®forãƒ«ãƒ¼ãƒ—ã«ãªã‚‹ãŒï¼Œå®Ÿè¡Œæ™‚ã«$n$ãŒæ±ºã¾ã‚‹ã®ã§ãã®ã¾ã¾æ›¸ã‘ãªã„ $a_{n-1}$ã‚’é¸ã¶ã‹é¸ã°ãªã„ã‹ã¯ï¼Œ$a_0$ã‹ã‚‰$a_{n-2}$ã®çµ„ã¿åˆã‚ã›ã§$X-a_{n-1}$å††ã‚’å®Ÿç¾ã§ãã‚‹ã‹ã«ã‹ã‹ã£ã¦ã„ã‚‹ \u0026hellip; $a_1$ã‚’é¸ã¶ã‹é¸ã°ãªã„ã‹ã¯ï¼Œ$a_0$ã‹ã‚‰$a_0$ã®çµ„ã¿åˆã‚ã›ã§$X-a_{n-1}-a_{n-2}-\u0026hellip;-a_2-a_1$å††ã‚’å®Ÿç¾ã§ãã‚‹ã‹ã«ã‹ã‹ã£ã¦ã„ã‚‹ $a_0$ã‚’é¸ã¶ã‹é¸ã°ãªã„ã‹ã¯ï¼Œ$a_0$ã‹ã‚‰$a_{-1}$ã®çµ„ã¿åˆã‚ã›ã§$X-a_{n-1}-a_{n-2}-\u0026hellip;-a_2-a_1-a_0$å††ã‚’å®Ÿç¾ã§ãã‚‹ã‹ã«ã‹ã‹ã£ã¦ã„ã‚‹ -\u0026gt; $a_0$ã‚’é¸ã¶ã‹é¸ã°ãªã„ã‹ã¯ï¼Œ$X$ãŒ$0$ã§ã‚ã‚‹ã‹ã©ã†ã‹ã«ã‹ã‹ã£ã¦ã„ã‚‹    // a_0-a_iã®ã‚³ã‚¤ãƒ³ã§åˆè¨ˆxã‚’å®Ÿç¾ã§ãã‚‹ã‹ã‚’è¨ˆç®— bool solve(int i, int x, const vector\u0026lt;int\u0026gt; \u0026amp;a) { if (i == 0) { if (x == 0) return true; // åˆè¨ˆ0ã‚’å®Ÿç¾ã™ã‚‹ã“ã¨ã¯å¯èƒ½  else return false; } if (solve(i-1, x, a)) return true; if (solve(i-1, x-a[i-1], a)) return true; return false; }  ãƒ¡ãƒ¢åŒ–ã«ã‚ˆã‚‹é«˜é€ŸåŒ–ï¼šmemo[i][x]ã«solve(i, x)ã®çµæœã‚’å…¥ã‚Œã¦ãŠã  bool solve(int i, int x, const vector\u0026lt;int\u0026gt; \u0026amp;a, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;memo) { if (i == 0) { if (x == 0) return true; else return false; } if (memo[i][x] != -1) return dp[i][x]; if (solve(i-1, x, a, memo)) return memo[i][x] = 1; if (solve(i-1, x-a[i-1], a, memo)) return memo[i][x] = 1; return memo[i][x] = 0; }  æ•°ç‹¬ã‚½ãƒ«ãƒ  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Field = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; void solve(Field \u0026amp;field, vector\u0026lt;Field\u0026gt; \u0026amp;results) { int emptyi = -1, emptyj = -1; for (int i = 0; i \u0026lt; 9 \u0026amp;\u0026amp; emptyi == -1; i++) { for (int j = 0; j \u0026lt; 9 \u0026amp;\u0026amp; emptyj == -1; j++) { if (field[i][j] == -1) { emptyi = i; emptyj = j; break; } } } // ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ï¼šã™ã¹ã¦ã®ãƒã‚¹ã‚’åŸ‹ã‚çµ‚ã‚ã£ãŸ  if (emptyi == -1 || emptyj == -1) { results.push_back(field); return; } vector\u0026lt;bool\u0026gt; usable(10, true); for (int i = 0; i \u0026lt; 9; i++) { // åŒã˜åˆ—ã«åŒã˜æ•°å­—ã¯ã ã‚  if (field[emptyi][i] != -1) usable[field[emptyi][i]] = false; // åŒã˜è¡Œã«åŒã˜æ•°å­—ã¯ã ã‚  if (field[i][emptyj] != -1) usable[field[i][emptyj]] = false; // åŒã˜ãƒ–ãƒ­ãƒƒã‚¯å†…ã«åŒã˜æ•°å­—ã¯ã ã‚  int bi = emptyi / 3 * 3 + 1; int bj = emptyj / 3 * 3 + 1; for (int di = bi - 1; di \u0026lt;= bi + 1; di++) { for (int dj = bj - 1; dj \u0026lt;= bj + 1; dj++) { if (field[di][dj] != -1) { usable[field[di][dj]] = false; } } } } // å…¥ã‚Œã‚‰ã‚Œã‚‹æ•°å­—å…¨éƒ¨è©¦ã™  for (int v = 1; v \u0026lt;= 9; v++) { if (!usable[v]) continue; field[emptyi][emptyj] = v; // ç©ºããƒã‚¹ã«ãŠã‘ã‚‹æ•°å­—ã‚’ç½®ã„ã¦ã¿ãŸ  solve(field, results); // å†å¸°çš„ã«ï¼Œç©ºããƒã‚¹ã®å€‹æ•°ãŒä¸€ã¤æ¸›ã£ãŸå•é¡Œã‚’è§£ãã«è¡Œã  } field[emptyi][emptyj] = -1; // æ·±ã•å„ªå…ˆæ¢ç´¢ãªã®ã§æˆ»ã£ãŸã¨ãã«çŠ¶æ…‹ã‚’æˆ»ã—ã¦ãŠã } int main() { Field field(9, vector\u0026lt;int\u0026gt;(9, -1)); for (int i = 0; i \u0026lt; 9; i++) { string line; cin \u0026gt;\u0026gt; line; for (int j = 0; j \u0026lt; 9; j++) { if (line[j] == \u0026#39;*\u0026#39;) continue; int num = line[j] - \u0026#39;0\u0026#39;; field[i][j] = num; } } vector\u0026lt;Field\u0026gt; results; solve(field, results); if (results.size() == 0) cout \u0026lt;\u0026lt; \u0026#34;no solution...\u0026#34; \u0026lt;\u0026lt; endl; else if (1 \u0026lt; results.size()) cout \u0026lt;\u0026lt; \u0026#34;more than one solution\u0026#34; \u0026lt;\u0026lt; endl; else { Field ans = results[0]; for (int i = 0; i \u0026lt; 9; i++) { for (int j = 0; j \u0026lt; 9; j++) { cout \u0026lt;\u0026lt; ans[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } }  ã‚°ãƒ©ãƒ•ä¸Šã®æ¢ç´¢ï¼šæ·±ã•å„ªå…ˆæ¢ç´¢ã¯å†å¸°é–¢æ•°ã§æ›¸ã‘ã‚‹  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; void dfs(int v, const Graph \u0026amp;G, vector\u0026lt;bool\u0026gt; \u0026amp;seen) { seen[v] = true; // é ‚ç‚¹vã‚’è¨ªã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²  for (auto next: G[v]) { if (seen[next]) continue; // vã®éš£æ¥é ‚ç‚¹ã®ã†ã¡è¨ªå•æ¸ˆã¿ã®ã‚‚ã®ã¯ã‚¹ã‚­ãƒƒãƒ—  dfs(next, G, seen); } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; G[a].push_back(b); } vector\u0026lt;bool\u0026gt; seen(N, false); for (int v = 0; v \u0026lt; N; v++) { if (seen[v]) continue; // é€£çµã§ã¯ãªã„ã‚°ãƒ©ãƒ•ã«ã‚‚å¯¾å¿œ  dfs(v, G, seen); } return 0; }  ã‚°ãƒ©ãƒ•ä¸Šã®æ¢ç´¢ï¼šãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆï¼å†å¸°é–¢æ•°ã‹ã‚‰æŠœã‘ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãƒ¡ãƒ¢ã£ã¦ãŠãã“ã¨ã§ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã«ãªã‚‹  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; void rec(int v, const Graoh \u0026amp;G, vector\u0026lt;bool\u0026gt; \u0026amp;seen, vector\u0026lt;int\u0026gt; \u0026amp;order) { seen[v] = true; for (auto next: G[v]) { if (seen[next]) continue; rec(next, G, seen, order); } order.push_back(v); // æŠœã‘ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãƒ¡ãƒ¢ } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; G[a].push_back(b); } vector\u0026lt;bool\u0026gt; seen(N, false); vector\u0026lt;int\u0026gt; order; for (int v = 0; v \u0026lt; N; v++) { if (seen[v]) continue; // é€£çµã§ã¯ãªã„ã‚°ãƒ©ãƒ•ã«ã‚‚å¯¾å¿œ  rec(v, G, seen, order); } reverse(order.begin(), order.end()); for (auto v: order) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; }  ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ã®äº’é™¤æ³•ï¼šæœ€å¤§å…¬ç´„æ•°ã‚’æ±‚ã‚ã‚‹  long long gcd(long long a, long long b) { if (a \u0026lt; b) swap(a, b); if (b == 0) return a; else return gcd(b, a % b); } long long lcm(long long a, long long b) { if (a \u0026lt; b) swap(a, b); return a * b / gcd(a, b); }  ç¹°ã‚Šè¿”ã—è‡ªä¹—æ³•ï¼šåŠ¹ç‡çš„ã«$x^n mod m$ã‚’æ±‚ã‚ã‚‹  long long modpow(long long x, long long n, long long m) { if (n == 0) return 1; // ãƒ™ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹  long long half = modpow(x, n/2, m); long long res = half * half % m; if (n \u0026amp; 1) // nãŒå¥‡æ•°ã®ã¨ã  res = res * x % m; return res; }  Union-Find tree  struct UnionFindTree { vector\u0026lt;int\u0026gt; parent, rank; UnionFindTree(int size): parent(size, -1), rank(size, -1) {} void init(int size) { parent.assign(size, -1); rank.assign(size, 0); } int root(int x) { if (parent[x] == -1) return x; else return parent[x] = root(parent[x]); } bool is_same(int x, int y) { return root(x) == root(y); } bool merge(int x, int y) { x = root(x); y = root(y); if (x == y) return false; if (rank[x] \u0026lt; rank[y]) swap(x, y); if (rank[x] == rank[y]) rank[x]++; parent[y] = x; return true; } }  å†å¸°ä¸‹é™æ§‹æ–‡è§£æ  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; // å†å¸°ä¸‹é™ãƒ‘ãƒ¼ã‚µ template\u0026lt;class T\u0026gt; struct Parser { // results  int root; // vals[root] is the answer  vector\u0026lt;T\u0026gt; vals; // value of each node  vector\u0026lt;char\u0026gt; ops; // operator of each node (\u0026#39;a\u0026#39; means leaf values)  vector\u0026lt;int\u0026gt; left, right; // the index of left-node, right-node  vector\u0026lt;int\u0026gt; ids; // the node-index of i-th value  int ind = 0; void init() { vals.clear(); ops.clear(); left.clear(); right.clear(); ids.clear(); ind = 0; } // generate nodes  int newnode(char op, int lp, int rp, T val = 0) { ops.push_back(op); left.push_back(lp); right.push_back(rp); if (op == \u0026#39;a\u0026#39;) { vals.push_back(val); ids.push_back(ind++); } else { if (op == \u0026#39;+\u0026#39;) vals.push_back(vals[lp] + vals[rp]); else if (op == \u0026#39;-\u0026#39;) vals.push_back(vals[lp] - vals[rp]); else if (op == \u0026#39;*\u0026#39;) vals.push_back(vals[lp] * vals[rp]); else if (op == \u0026#39;/\u0026#39;) vals.push_back(vals[lp] / vals[rp]); ids.push_back(-1); } return (int)vals.size() - 1; } // main solver  T solve(const string \u0026amp;S) { int p = 0; string nS = \u0026#34;\u0026#34;; for (auto c : S) if (c != \u0026#39; \u0026#39;) nS += c; root = expr(nS, p); return vals[root]; } // parser  int expr(const string \u0026amp;S, int \u0026amp;p) { int lp = factor(S, p); while (p \u0026lt; (int)S.size() \u0026amp;\u0026amp; (S[p] == \u0026#39;+\u0026#39; || S[p] == \u0026#39;-\u0026#39;)) { char op = S[p]; ++p; int rp = factor(S, p); lp = newnode(op, lp, rp); } return lp; } int factor(const string \u0026amp;S, int \u0026amp;p) { int lp = value(S, p); while (p \u0026lt; (int)S.size() \u0026amp;\u0026amp; (S[p]== \u0026#39;*\u0026#39; || S[p] == \u0026#39;/\u0026#39;)) { char op = S[p]; ++p; int rp = value(S, p); lp = newnode(op, lp, rp); } return lp; } int value(const string \u0026amp;S, int \u0026amp;p) { if (S[p] == \u0026#39;(\u0026#39;) { ++p; // skip \u0026#39;(\u0026#39;  int lp = expr(S, p); ++p; // skip \u0026#39;)\u0026#39;  return lp; } else { T val = 0; int sign = 1; if (p \u0026lt; (int)S.size() \u0026amp;\u0026amp; S[p] == \u0026#39;-\u0026#39;) sign = -1; while (p \u0026lt; (int)S.size() \u0026amp;\u0026amp; S[p] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; S[p] \u0026lt;= \u0026#39;9\u0026#39;) { val = val * 10 + (int)(S[p] - \u0026#39;0\u0026#39;); ++p; } return newnode(\u0026#39;a\u0026#39;, -1, -1, val); } } }; int main() { Parser\u0026lt;int\u0026gt; parse; cout \u0026lt;\u0026lt; parse.solve(\u0026#34;6 + 3\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; parse.solve(\u0026#34;3 + (10 - 4) / 2\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; parse.solve(\u0026#34;((6 - 3) * 2 + 10 / 5) * (-3)\u0026#34;) \u0026lt;\u0026lt; endl; }   æœ«å°¾å†å¸°ã«ã‚ˆã‚‹æœ€é©åŒ–\n å†å¸°é–¢æ•°å†…ã§ã®è‡ªèº«ã®å‘¼ã³å‡ºã—ãŒå†å¸°é–¢æ•°å†…ã®æœ«å°¾ï¼Œæ­£ç¢ºã«ã¯returnã®ç›´å‰ãªã‚‰ï¼Œå†å¸°é–¢æ•°ã®ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®å†åˆ©ç”¨ãŒå¯èƒ½ãªã®ã§é€šå¸¸ã®ç¹°ã‚Šè¿”ã—ã¨åŒã˜è¨ˆç®—ãŒå¯èƒ½ å†å¸°é–¢æ•°ã‚’æœ«å°¾å†å¸°ã«æ›¸ãæ›ãˆã‚‹ã“ã¨ã§ã‚ˆã‚Šå¤§ãã„å•é¡Œã‚’è¨ˆç®—ã§ãã‚‹ã“ã¨ãŒã‚ã‚‹ ref: https://qiita.com/pebblip/items/cf8d3230969b2f6b3132    æœ«å°¾å†å¸°ã§ã¯ãªã„éšä¹—ã®è¨ˆç®—\n  function factorial(n) { if (n === 0) { return 1; } return n * factorial(n - 1); // ã“ã®å†å¸°å‘¼ã³å‡ºã—ã¯ï¼Œå†å¸°å‘¼ã³å‡ºã—ã®çµæœã‚’ç”¨ã„ã¦è¨ˆç®—ã‚’ã—ã¦ã„ã‚‹ã®ã§æœ«å°¾å†å¸°ã§ã¯ãªã„ï¼ˆå†å¸°å‘¼ã³å‡ºã—ãŒreturnã®ç›´å‰ã§ã¯ãªã„ï¼‰ }  æœ«å°¾å†å¸°ã«æ›¸ãæ›ãˆãŸéšä¹—ã®è¨ˆç®—  function factorial(n) { function factorialTail(n, accum) { // accumã«ç›´å‰ã®çµæœã‚’ãŸã‚ã¦ãŠã  if (n === 0) { return accum; } return factorialTail(n - 1, n * accum); // ã“ã®factorialTailã®å‘¼ã³å‡ºã—ã¯æœ«å°¾å†å¸°  } return factorialTail(n, 1); }  Babel ã§ã¯æœ«å°¾å†å¸°ãªå†å¸°é–¢æ•°ã¯é€šå¸¸ã®whileãƒ«ãƒ¼ãƒ—ã§æ›¸ãç›´ã™æœ€é©åŒ–ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹  function factorial(n) { // å†å¸°å‘¼ã³å‡ºã—ãŒé™¤å»ã•ã‚Œã¦ã„ã‚‹  function factorialTail(_x, _x2) { var _again = true; _function: while (_again) { var n = _x, accum = _x2; _again = false; if (n === 0) { return accum; } _x = n - 1; _x2 = n * accum; _again = true; continue _function; } } return factorialTail(n, 1); } ","date":1586509828,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1608174628,"objectID":"61ed7eb6e65e70a0cf66f1441c09b246","permalink":"/ja/post/recursion/","publishdate":"2020-04-10T18:10:28+09:00","relpermalink":"/ja/post/recursion/","section":"post","summary":"ã¯ã˜ã‚ã« å†å¸°é–¢æ•°ã«å¯¾ã™ã‚‹ã€Œãªã‚“ã¨ãªãã‚ã‹ã‚‹ã€ã‚’ã€Œæ›¸ã‘ã‚‹ã€ã«ã¾ã§æŒã£ã¦ã„ããŸã„ã®ã§ï¼Œå­¦ã³ç›´ã—ï¼ @drken ã•ã‚“ã®ã€Œå†å¸°é–¢æ•°ã‚’å­¦ã¶ã¨ï¼Œã©ã‚“ãªä¸–ç•ŒãŒåºƒãŒã‚‹ã‹","tags":["å†å¸°","recursion","AtCoder","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°","ç«¶ãƒ—ãƒ­"],"title":"ã€Œå†å¸°ã€ã«ã¤ã„ã¦ã®å­¦ã³ç›´ã—","type":"post"},{"authors":[],"categories":[],"content":"ã‚°ãƒ©ãƒ•ã‚’æ¢ç´¢ã—ãŸã„ è¨ˆç®—æ©Ÿã‚’ã€Œä¸ãˆã‚‰ã‚ŒãŸå¯¾è±¡ã®ä¸­ã‹ã‚‰ï¼Œç›®çš„ã«åˆè‡´ã™ã‚‹ã‚‚ã®ã‚’è¦‹ã¤ã‘å‡ºã—ãŸã‚Šï¼Œæœ€è‰¯ã®ã‚‚ã®ã‚’è¦‹ã¤ã‘å‡ºã™ã€ã¨ã„ã†ã€Œæ¢ç´¢ã€ç›®çš„ã§ç”¨ã„ã‚‹å ´é¢ã¯å¤šãã‚ã‚‹ï¼ä¸–ã®ä¸­ã«ã¯ã³ã“ã£ã¦ã„ã‚‹å•é¡ŒãŸã¡ã¯ï¼Œè€ƒãˆã‚‰ã‚Œã‚‹ã™ã¹ã¦ã®å ´åˆã‚’ãã¾ãªãèª¿ã¹ã¤å°½ãã™ã“ã¨ã«ã‚ˆã£ã¦åŸç†çš„ã«è§£æ±ºã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\nå•é¡Œã‚’ã€Œã‚°ãƒ©ãƒ•ã€ã¨ã—ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ãƒ»å®šå¼åŒ–ã™ã‚‹ã“ã¨ã§é«˜é€Ÿãªæ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’è€ƒãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã“ã¨ãŒå¤šã„ï¼ä¾‹ãˆã°ï¼Œé¦–éƒ½åœã®é›»è»Šã®ä¹—æ›æ¡ˆå†…ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã»ã¨ã‚“ã©ãã®ã¾ã¾ã‚°ãƒ©ãƒ•ä¸Šã®æœ€çŸ­çµŒè·¯æ¢ç´¢å•é¡Œã¨ã—ã¦å®šå¼åŒ–ã§ãã‚‹ã—ï¼Œä»–ã«ã‚‚ã‚ªã‚»ãƒ­ã‚„å°†æ£‹ãªã©ã®ãƒœãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ã‚‚ï¼Œãƒ¦ãƒ¼ã‚¶ã®æ“ä½œã«ã‚ˆã£ã¦ç›¤ä¸Šã®çŠ¶æ…‹ã‚’é ‚ç‚¹ã¨ã™ã‚‹ã‚°ãƒ©ãƒ•ä¸Šã‚’ç§»å‹•ã—ã¦ã„ã‚‹ã¨ã™ã‚Œã°ã‚°ãƒ©ãƒ•ä¸Šã®æ¢ç´¢å•é¡Œã¨ã¿ãªã›ã‚‹ï¼\nã‚°ãƒ©ãƒ• ã‚°ãƒ©ãƒ•ã¨ã¯ï¼Œå¯¾è±¡ç‰©ã‚’æ§‹æˆã™ã‚‹äº‹ç‰©ã®é›†åˆã¨ãã®é›†åˆã‚’æ§‹æˆã™ã‚‹å¯¾è±¡ç‰©é–“ã®é–¢ä¿‚ã«ã®ã¿æ³¨ç›®ã—ãŸãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ã“ã¨ã§ï¼Œå‘è¿‘ãªä¾‹ã§è¨€ãˆã°ï¼Œäººé–“é–¢ä¿‚ã¯ã‚°ãƒ©ãƒ•ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\n**ã‚°ãƒ©ãƒ•$G$**ã¯ãã‚Œã‚’æ§‹æˆã™ã‚‹é ‚ç‚¹ã®æœ‰é™é›†åˆ$V = \\{v_1, v_2, \u0026hellip;, v_n\\}$ã¨é ‚ç‚¹é–“ã«ç”Ÿãˆã‚‹è¾ºã®æœ‰é™é›†åˆ$E = \\{e_1, e_2, \u0026hellip;, e_m\\}$ã®çµ„ã¨ã—ã¦å®šç¾©ã•ã‚Œã‚‹ï¼\n$$ G = (V, E) $$\né ‚ç‚¹$v_i$ã¨$v_j$ãŒè¾º$e$ã«ã‚ˆã£ã¦æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã¨ãï¼Œé ‚ç‚¹$v_i$ã¨$v_j$ã¯äº’ã„ã«éš£æ¥ã—ã¦ã„ã‚‹ã¨ã„ã„ï¼Œ$v_i$ï¼Œ$v_j$ã¯$e$ã®ç«¯ç‚¹ã§ã‚ã‚‹ã¨ã„ã†ï¼\nã‚°ãƒ©ãƒ•$G$ã®å„è¾º$e = (v_i, v_j)$ã«ã¤ã„ã¦ï¼Œ$(v_i, v_j)$ã¨$(v_j, v_i)$ã‚’åŒºåˆ¥ã—ãªã„ã¨ãï¼Œ$G$ã‚’ç„¡å‘ã‚°ãƒ©ãƒ•ã¨å‘¼ã³ï¼Œé€†ã«åŒºåˆ¥ã™ã‚‹ã¨ãæœ‰å‘ã‚°ãƒ©ãƒ•ã¨å‘¼ã¶ï¼\n   ç„¡å‘ã‚°ãƒ©ãƒ•      æœ‰å‘ã‚°ãƒ©ãƒ•   ã‚°ãƒ©ãƒ•$G$ä¸Šã® 2 é ‚ç‚¹$u$ï¼Œ$v$ã«ã¤ã„ã¦ï¼Œ$u$ã‚’å‡ºç™ºã—ã¦éš£æ¥ã™ã‚‹é ‚ç‚¹ã‚’ãŸã©ã‚‹ã“ã¨ã§$v$ã«åˆ°é”ã§ãã‚‹ã¨ãï¼Œãã®çµŒè·¯ã‚’**$u$-$v$è·¯**ã¨ã„ã†ï¼ã¾ãŸã“ã®ã¨ã$u$ã‚’ãã®è·¯ã®**å§‹ç‚¹**ï¼Œ$v$ã‚’**çµ‚ç‚¹**ã¨ã„ã†ï¼ã•ã‚‰ã«ï¼Œè·¯ã®ã†ã¡ï¼ŒåŒã˜é ‚ç‚¹ã‚’ 2 åº¦ä»¥ä¸Šé€šã‚‰ãªã„ã‚‚ã®ã‚’**ãƒ‘ã‚¹**ã¨ã„ã†ï¼ã¾ãŸï¼Œè·¯ã®ã†ã¡ï¼Œå§‹ç‚¹ã¨çµ‚ç‚¹ãŒç­‰ã—ã„ã‚‚ã®ã‚’**é–‰è·¯**ï¼ˆã¾ãŸã¯**ã‚µã‚¤ã‚¯ãƒ«**ï¼‰ã¨å‘¼ã¶ï¼\n   ãƒ‘ã‚¹      é–‰è·¯   ã‚°ãƒ©ãƒ•$G$ã®ä»»æ„ã® 2 é ‚ç‚¹$u$ï¼Œ$v$ $\\in V$ã«å¯¾ã—ã¦ï¼Œ$u$-$v$ãƒ‘ã‚¹ãƒ»$v$-$u$ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã¨ãï¼Œ$G$ã¯é€£çµã§ã‚ã‚‹ã¨ã„ã†ï¼ç‰¹ã«ï¼Œæœ‰å‘ã‚°ãƒ©ãƒ•$G$ã®ä»»æ„ã® 2 é ‚ç‚¹$u$ï¼Œ$v$ $\\in V$ã«å¯¾ã—ã¦ï¼Œ$u$-$v$ãƒ‘ã‚¹ãƒ»$v$-$u$ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã¨ãï¼Œ$G$ã¯å¼·é€£çµã§ã‚ã‚‹ã¨ã„ã†ï¼\n   é€£çµãªã‚°ãƒ©ãƒ•      é€£çµã§ãªã„ã‚°ãƒ©ãƒ•   è¨ˆç®—æ©Ÿä¸Šã§ã®ã‚°ãƒ©ãƒ•ã®å®Ÿè£… è¨ˆç®—æ©Ÿä¸Šã§ã¯ã‚°ãƒ©ãƒ•ã¯å¤§ããåˆ†ã‘ã¦ä»¥ä¸‹ã®äºŒé€šã‚ŠãŒã‚ã‚‹ï¼\n éš£æ¥ãƒªã‚¹ãƒˆ  ã‚°ãƒ©ãƒ•$G$ã‚’æ§‹æˆã™ã‚‹å„é ‚ç‚¹ã«ã¤ã„ã¦ï¼Œãã®é ‚ç‚¹ã®éš£æ¥é ‚ç‚¹ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦ä¿æŒã™ã‚‹ã“ã¨ã§ã‚°ãƒ©ãƒ•ã‚’è¡¨ç¾ã™ã‚‹ï¼é ‚ç‚¹æ•°ã«å¯¾ã—ã¦è¾ºã®æœ¬æ•°ãŒæ¯”è¼ƒçš„å°‘ãªã„ç–ãªã‚°ãƒ©ãƒ•ã®å®Ÿè£…ã«ãŠã„ã¦ï¼ˆéš£æ¥è¡Œåˆ—è¡¨ç¾ã¨æ¯”è¼ƒã—ã¦ï¼‰æœ‰åˆ©ãªã“ã¨ãŒã‚ã‚‹ï¼\n éš£æ¥è¡Œåˆ—  ã‚°ãƒ©ãƒ•$G$ã‚’æ§‹æˆã™ã‚‹$n$é ‚ç‚¹ã«ã¤ã„ã¦ï¼Œ$n \\times n$ã®å¤§ãã•ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ç”¨æ„ã—ï¼Œé ‚ç‚¹$i$-$j$é–“ã«è¾ºãŒç”Ÿãˆã¦ã„ã‚‹ã¨ãï¼Œãã®ãƒ†ãƒ¼ãƒ–ãƒ«ã®$(i, j)$ã«1ã‚’ç«‹ã¦ã‚‹ã“ã¨ã§è¾ºã‚’è¡¨ç¾ã™ã‚‹ï¼é ‚ç‚¹æ•°ã«å¯¾ã—ã¦è¾ºã®æœ¬æ•°ãŒæ¯”è¼ƒçš„å¤šã„å¯†ãªã‚°ãƒ©ãƒ•ã®å®Ÿè£…ã«ãŠã„ã¦ï¼ˆéš£æ¥ãƒªã‚¹ãƒˆè¡¨ç¾ã¨æ¯”è¼ƒã—ã¦ï¼‰æœ‰åˆ©ãªã“ã¨ãŒã‚ã‚‹ï¼\nä»¥ä¸‹ã§ã¯ï¼Œã‚°ãƒ©ãƒ•ã‚’éš£æ¥ãƒªã‚¹ãƒˆã¨ã—ã¦å®Ÿè£…ã™ã‚‹ï¼\nusing Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; Graph G; ä¾‹ãˆã°ï¼Œå…¥åŠ›ãŒä»¥ä¸‹ã®ã‚ˆã†ã«ä¸ãˆã‚‰ã‚ŒãŸã¨ãï¼Œã‚°ãƒ©ãƒ•$G$ã¯æ¬¡ã®ã‚ˆã†ã«æ§‹ç¯‰ã•ã‚Œã‚‹ï¼\n ã€å…¥åŠ›ã€‘ï¼š\n$$ N \\space M $$\n$$ u_1 \\space v_1 $$\n$$ u_2 \\space v_2 $$\n$$ u_3 \\space v_3 $$\n$$ \u0026hellip; $$\n$$ u_M \\space v_M $$\n #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); // G[v].push_back(u);  } return 0; } è¾ºã«é‡ã¿ã®ã‚ã‚‹ã‚°ãƒ©ãƒ•ã§ã‚ã‚Œã°ï¼ŒEdgeã¨ã„ã†è¾ºã‚’è¡¨ã™æ§‹é€ ä½“ã‚’å®šç¾©ã—ã¦ã‚„ã‚‹ã¨ã‚ã‹ã‚Šã‚„ã™ã„ï¼\n ã€å…¥åŠ›ã€‘ï¼š\n$$ N \\space M $$\n$$ u_1 \\space v_1 \\space w_1 $$\n$$ u_2 \\space v_2 \\space w_2 $$\n$$ u_3 \\space v_3 \\space w_3 $$\n$$ \u0026hellip; $$\n$$ u_M \\space v_M \\space w_M $$\n #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct Edge { int to; int weight; Edge(int to, int weight): to(to), weight(weight) {} }; using Graph = vector\u0026lt;vector\u0026lt;Edge\u0026gt;\u0026gt;; int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int from, to, weight; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; weight; G[from].push_back(Edge(to, weight)); // G[to].push_back(Edge(from, weight));  } return 0; } ã‚°ãƒ©ãƒ•ã®æ¢ç´¢ ä¸€èˆ¬ã«ã‚°ãƒ©ãƒ•ä¸Šã®æ¢ç´¢ã«ã¯ã©ã®ã‚ˆã†ãªæ–¹é‡ãŒè€ƒãˆã‚‰ã‚Œã‚‹ã®ã ã‚ã†ã‹ï¼ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ãªã‚°ãƒ©ãƒ•ã«å¯¾ã™ã‚‹é ‚ç‚¹ 0 ã‚’å§‹ç‚¹ã¨ã—ãŸæ¢ç´¢ã‚’è€ƒãˆã‚‹ï¼\n   é ‚ç‚¹$0$ã‹ã‚‰æ¢ç´¢ã‚’å§‹ã‚ã‚‹ï¼   é ‚ç‚¹$0$ã«è¨ªå•ã—ãŸå¾Œï¼Œæ¬¡ã«è¨ªå•ã™ã‚‹é ‚ç‚¹ã‚’æ¢ã™ï¼ã¤ã¾ã‚Šé ‚ç‚¹$0$ã®éš£æ¥é ‚ç‚¹ã‚’èª¿ã¹ã‚‹ã¨ï¼Œé ‚ç‚¹$1$ã¨é ‚ç‚¹$2$ã‚’ç™ºè¦‹ã—ä¿ç•™ãƒ¡ãƒ¢ã«è¿½è¨˜ã™ã‚‹ï¼ã¨ã‚Šã‚ãˆãšï¼Œæ¬¡ã«è¨ªå•ã™ã‚‹é ‚ç‚¹ã‚’é ‚ç‚¹$1$ã«æ±ºã‚ï¼Œæ¢ç´¢ã‚’ç¶šã‘ã‚‹ï¼\n    é ‚ç‚¹$0$ã«è¨ªå•ã—ãŸï¼      $æ¬¡ã«è¨ªå•ã™ã‚‹é ‚ç‚¹ã‚’æ±ºã‚ã‚‹ï¼$   é ‚ç‚¹$1$ã«è¨ªå•ã—ãŸå¾Œï¼Œæ¬¡ã«è¨ªå•ã™ã‚‹é ‚ç‚¹ã‚’æ¢ã™ï¼ã¤ã¾ã‚Šï¼Œé ‚ç‚¹$1$ã®éš£æ¥é ‚ç‚¹ã‚’èª¿ã¹ã‚‹ã¨ï¼Œé ‚ç‚¹$3$ã¨é ‚ç‚¹$4$ã‚’ç™ºè¦‹ã—ä¿ç•™ãƒ¡ãƒ¢ã«è¿½è¨˜ã™ã‚‹ï¼ï¼ãã“ã§æ¬¡ã«è¨ªå•ã™ã‚‹é ‚ç‚¹ã®é¸ã³æ–¹ãŒ 2 é€šã‚Šè€ƒãˆã‚‰ã‚Œã‚‹ï¼\n ã€Œå¾Œã«ä¿ç•™ãƒ¡ãƒ¢ã«è¿½è¨˜ã—ãŸé ‚ç‚¹$3$ãƒ»é ‚ç‚¹$4$ã‚’ï¼Œé ‚ç‚¹$2$ã‚ˆã‚Šå…ˆã«è¨ªå•ã™ã‚‹ã€ ã€Œå…ˆã«ä¿ç•™ãƒ¡ãƒ¢ã«è¿½è¨˜ã—ãŸé ‚ç‚¹$2$ã‚’ï¼Œé ‚ç‚¹$3$ãƒ»é ‚ç‚¹$4$ã‚ˆã‚Šå…ˆã«è¨ªå•ã™ã‚‹ã€  ã€Œå¾Œã«ä¿ç•™ãƒ¡ãƒ¢ã«è¿½è¨˜ã—ãŸé ‚ç‚¹$3$ãƒ»é ‚ç‚¹$4$ã‚’ï¼Œé ‚ç‚¹$2$ã‚ˆã‚Šå…ˆã«è¨ªå•ã™ã‚‹ã€ã¨ã„ã†æ–¹é‡ã§ç¶šãæ¢ç´¢ã‚’ æ·±ã•å„ªå…ˆæ¢ç´¢ Depth-First Searchï¼ˆDFSï¼‰ ã¨å‘¼ã³ï¼Œã€Œå…ˆã«ä¿ç•™ãƒ¡ãƒ¢ã«è¿½è¨˜ã—ãŸé ‚ç‚¹$2$ã‚’ï¼Œé ‚ç‚¹$3$ãƒ»é ‚ç‚¹$4$ã‚ˆã‚Šå…ˆã«è¨ªå•ã™ã‚‹ã€ã¨ã„ã†æ–¹é‡ã§ç¶šãæ¢ç´¢ã‚’ å¹…å„ªå…ˆæ¢ç´¢ Breadth-First Searchï¼ˆBFSï¼‰ ã¨å‘¼ã¶ï¼\nDFS ã§ã¯ä¿ç•™ãƒ¡ãƒ¢ã®æŒ™å‹•ãŒï¼ŒLast-In-First-Out ãªã®ã§ã‚¹ã‚¿ãƒƒã‚¯ã‚„å†å¸°é–¢æ•°ã§å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ä¸€æ–¹ã§ï¼ŒBFS ã§ã¯ä¿ç•™ãƒ¡ãƒ¢ã®æŒ™å‹•ãŒï¼ŒFirst-In-First-Out ãªã®ã§ã‚­ãƒ¥ãƒ¼ã§å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\n       ã©ã†ã„ã†æ–¹é‡ã§ä¿ç•™ãƒ¡ãƒ¢ã‹ã‚‰æ¬¡ã«è¨ªã‚Œã‚‹é ‚ç‚¹ã‚’é¸æŠã™ã‚‹ã‹ã‚’ä¸€æ—¦è„‡ã«ãŠã„ã¦ãŠã„ã¦ï¼Œã‚°ãƒ©ãƒ•ä¸Šã®æ¢ç´¢ã‚’æ›¸ãä¸‹ã™ã¨\nhas_visited[i]: é ‚ç‚¹iãŒè¨ªå•æ¸ˆã¿ãªã‚‰trueï¼Œãã†ã§ãªã„ãªã‚‰falseã‚’æ ¼ç´ã™ã‚‹é…åˆ— suspended: ä¿ç•™ãƒ¡ãƒ¢ï¼ˆæœªè¨ªå•ã‹ã¤å­˜åœ¨ã‚’ç™ºè¦‹æ¸ˆã¿ã®é ‚ç‚¹ã®é›†åˆï¼‰ has_visitedå…¨ä½“ã‚’falseã§åˆæœŸåŒ–ãƒ»suspendedã‚’ç©ºã«åˆæœŸåŒ–; has_visited[å§‹ç‚¹é ‚ç‚¹] = true; suspendedã«å§‹ç‚¹é ‚ç‚¹ã‚’è¿½åŠ ; while (!suspendedãŒç©º) { u := suspendedã‹ã‚‰1ã¤é ‚ç‚¹ã‚’å–ã‚Šå‡ºã™ï¼ˆã“ã®ã¨ãã®å–ã‚Šå‡ºã—æ–¹ã§æ¢ç´¢ã®æ€§æ ¼ãŒæ±ºã¾ã‚‹ï¼‰; for (v: uã®éš£æ¥é ‚ç‚¹) { if (has_visited[v]) continue; // ã™ã§ã«è¨ªå•æ¸ˆã¿ã ã£ãŸã®ã§ã‚¹ãƒ«ãƒ¼ else { has_visited[u] = true; // è¨ªå•ã—ãŸã®ã§å°ã‚’ã¤ã‘ã‚‹ suspended.append(v); // ä¿ç•™ãƒ¡ãƒ¢ã«è¿½è¨˜ã™ã‚‹ } } } ã¾ãŸï¼Œé–‰è·¯ãŒå­˜åœ¨ã—ãªã„ã‹ã¤é€£çµã§ã‚ã‚‹ã‚ˆã†ãªã‚°ãƒ©ãƒ•ã¯ã€Œæœ¨ã€ã¨å‘¼ã°ã‚Œã‚‹ï¼æœ¨ã¯ï¼Œã‚°ãƒ©ãƒ•ã®ç‰¹æ®Šå‹ã§ã‚ã‚‹ã®ã§ï¼Œã‚°ãƒ©ãƒ•ã§ã®æ¢ç´¢ã¨åŒæ§˜ã®è­°è«–ãŒæœ¨ã§ã®æ¢ç´¢ã«ã‚‚è¨€ãˆã‚‹ï¼\næ·±ã•å„ªå…ˆæ¢ç´¢ Depth-Frist Seachï¼ˆDFS) ã‚°ãƒ©ãƒ•ä¸Šã‚’æ¢ç´¢ã™ã‚‹æ‰‹æ³•ã¨ã—ã¦æœ‰åï¼ã€Œè¡Œã‘ã‚‹ã¨ã“ã‚ã¾ã§é€²ã‚“ã§ï¼Œè¡Œãæ­¢ã¾ã‚Šã«ãªã£ãŸã‚‰æˆ»ã£ã¦åˆ¥ã®é“ã‚’è©¦ã™ã€ã¨ã„ã†æ–¹é‡ã§ã‚°ãƒ©ãƒ•ä¸Šã‚’æ¢ç´¢ã™ã‚‹ï¼ä¸Šã®èª¬æ˜ã§è¨€ãˆã°ã€Œä¿ç•™ãƒ¡ãƒ¢ã‹ã‚‰ LIFO ã§é ‚ç‚¹ã‚’å–ã‚Šå‡ºã™ã€ã®ãŒ DFSï¼ã€Œä¿ç•™ãƒ¡ãƒ¢ã‹ã‚‰ LIFO ã§é ‚ç‚¹ã‚’å–ã‚Šå‡ºã™ã€ã¨ã„ã†æ–¹é‡ãŒã‚¹ã‚¿ãƒƒã‚¯ã‚„å†å¸°é–¢æ•°ã®æ€§è³ªã¨ä¸€è‡´ã—å®Ÿè£…ã«ç”¨ã„ã‚‰ã‚Œã‚‹ï¼\nã‚¹ã‚¿ãƒƒã‚¯ã«ã‚ˆã‚‹ DFS ã®å®Ÿè£… ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç”¨ã„ã¦ DFS ã‚’å®Ÿè£…ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; stack\u0026lt;int\u0026gt; suspended; void DFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; suspended.push(v); while (!suspended.empty()) { int u = suspended.top(); suspended.pop(); for (auto w: G[u]) { if (has_visited[w]) continue; else { has_visited[u] = true; suspended.push(w); } } } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } has_visited.assign(N, false); DFS(G, 0); return 0; } å†å¸°é–¢æ•°ã«ã‚ˆã‚‹ DFS ã®å®Ÿè£… å†å¸°é–¢æ•°ã‚’ç”¨ã„ã¦ DFS ã‚’å®Ÿè£…ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; void DFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; for (auto u: G[v]) { if (has_visited[u]) continue; DFS(G, u); } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } has_visited.assign(N, false); DFS(G, 0); return 0; } å¹…å„ªå…ˆæ¢ç´¢ Breadth-First Searchï¼ˆBFSï¼‰ ã‚°ãƒ©ãƒ•ä¸Šã‚’æ¢ç´¢ã™ã‚‹æ‰‹æ³•ã¨ã—ã¦æœ‰åï¼ã€Œåˆ†ã‹ã‚Œé“ã«é­é‡ã—ãŸã‚‰ï¼Œå…¨ã¦ã®åˆ†ã‹ã‚Œé“ã«ã¤ã„ã¦ã¡ã‚‡ã£ã¨ãšã¤ç­‰ã—ãè¨ªå•ã—ã¦ã„ãã€ã¨ã„ã†æ–¹é‡ã§ã‚°ãƒ©ãƒ•ä¸Šã‚’æ¢ç´¢ã™ã‚‹ï¼ä¸Šã®èª¬æ˜ã§è¨€ãˆã°ã€Œä¿ç•™ãƒ¡ãƒ¢ã‹ã‚‰ FIFO ã§é ‚ç‚¹ã‚’å–ã‚Šå‡ºã™ã€ã®ãŒ BFSï¼ã€Œä¿ç•™ãƒ¡ãƒ¢ã‹ã‚‰ FIFO ã§é ‚ç‚¹ã‚’å–ã‚Šå‡ºã™ã€ã¨ã„ã†æ–¹é‡ãŒã‚­ãƒ¥ãƒ¼ã®æ€§è³ªã¨ä¸€è‡´ã—å®Ÿè£…ã«ç”¨ã„ã‚‰ã‚Œã‚‹ï¼\nã‚­ãƒ¥ãƒ¼ã«ã‚ˆã‚‹ BFS ã®å®Ÿè£… ã‚­ãƒ¥ãƒ¼ã‚’ç”¨ã„ã¦ BFS ã‚’å®Ÿè£…ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; queue\u0026lt;int\u0026gt; suspended; void BFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; suspended.push(v); while (!suspended.empty()) { int u = suspended.front(); suspended.pop(); for (auto w: G[u]) { if (has_visited[w]) continue; else { has_visited[w] = true; suspended.push(w); } } } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } has_visited.assign(N, false); BFS(G, 0); return 0; } BFS ã«ã‚ã£ã¦ DFS ã«ãªã„ã‚‚ã® BFS ã¯å…¨é ‚ç‚¹ã‚’å§‹ç‚¹ã‹ã‚‰ã®è¾ºã®æœ¬æ•°ã«ã‚ˆã£ã¦ãƒ¬ãƒ™ãƒ«åˆ†ã‘ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼ç‰¹ã«ï¼Œå…¨ã¦ã®è¾ºã®é‡ã•ãŒ$1$ã§ã‚ã‚‹ã‚ˆã†ãªé‡ã¿ä»˜ãã‚°ãƒ©ãƒ•ã§ BFS ã‚’è¡Œã†ã¨ï¼Œãã®å§‹ç‚¹ã‹ã‚‰ã®å„é ‚ç‚¹ã®æœ€çŸ­è·é›¢ã‚’æ±‚ã‚ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ã—ã¦ã‚‚ä½¿ã†ã“ã¨ãŒã§ãã‚‹ï¼ãŸã ã—ï¼ŒBFS ãŒæœ€çŸ­è·é›¢ã‚’æ±‚ã‚ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ã—ã¦ä½¿ãˆã‚‹ã®ã¯ï¼Œå…¨ã¦ã®è¾ºã®é‡ã•ãŒ$1$ã§ã‚ã‚‹ã‚°ãƒ©ãƒ•ã«é™ã‚‹ã“ã¨ã«æ³¨æ„ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ï¼ãã†ã§ãªã„ã‚°ãƒ©ãƒ•ãªã‚‰ dijkstra æ³•ãªã©ä»–ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ç”¨ã„ãªã„ã¨æ­£ã—ã„ç­”ãˆãŒå¾—ã‚‰ã‚Œãªã„ï¼\nBFS ã§ã™ã¹ã¦ã®è¾ºã®é‡ã•ãŒ$1$ã§ã‚ã‚‹ã‚ˆã†ãªã‚°ãƒ©ãƒ•ã‚’æ§‹æˆã™ã‚‹å„é ‚ç‚¹ã®ï¼Œé ‚ç‚¹$0$ã‹ã‚‰ã®æœ€çŸ­è·é›¢ã‚’æ±‚ã‚ã‚‹å‡¦ç†ã‚’å®Ÿè£…ã™ã‚‹ã¨æ¬¡ã®é€šã‚Šï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;int\u0026gt; distance; // \u0026lt;-- vector\u0026lt;bool\u0026gt; has_visited; queue\u0026lt;int\u0026gt; suspended; void BFS(const Graph \u0026amp;G, int v) { distance[v] = 0; // å§‹ç‚¹ã®è·é›¢ã¯0  suspended.push(v); while (!suspended.empty()) { int u = suspended.front(); suspended.pop(); for (auto w: G[u]) { if (distance[w] != -1) continue; // è¨ªå•æ¸ˆã¿ãªã®ã§ã‚¹ãƒ«ãƒ¼  else { distance[w] = distance[u] + 1; // é ‚ç‚¹wã¯é ‚ç‚¹uã®éš£æ¥é ‚ç‚¹  suspended.push(w); } } } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } for (int i = 0; i \u0026lt; N; i++) distance[i] = -1; // distance[i] == -1 --\u0026gt; é ‚ç‚¹iã«ã¯æœªè¨ªå•  BFS(G, 0); for (int i = 0; i \u0026lt; N; i++) { cout \u0026lt;\u0026lt; \u0026#34;node[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;]: \u0026#34; \u0026lt;\u0026lt; distance[i] \u0026lt;\u0026lt; endl; } return 0; } ã‚°ãƒ©ãƒ•æ¢ç´¢ã®ä¾‹é¡Œ åˆ°é”å¯èƒ½æ€§åˆ¤å®š 2 é ‚ç‚¹$s$ï¼Œ$t$ $\\in V$ãŒä¸ãˆã‚‰ã‚Œï¼Œ$s$ã‹ã‚‰$t$ã¸è¾ºã‚’ãŸã©ã£ã¦åˆ°é”ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹å•é¡Œï¼å˜ç´”ã«ï¼Œ$s$ã‚’å§‹ç‚¹ã¨ã—ãŸ DFS ã¾ãŸã¯ BFS ã‚’å®Ÿè¡Œã—ï¼Œhas_visited[s]ã‚’ç¢ºã‹ã‚ã‚Œã°è‰¯ã„ï¼\n ã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½¿ã£ãŸ DFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; stack\u0026lt;int\u0026gt; suspended; void DFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; suspended.push(v); while (!suspended.empty()) { int u = suspended.top(); suspended.pop(); for (auto w: G[u]) { if (has_visited[w]) continue; else { has_visited[u] = true; suspended.push(w); } } } } int main() { int N, M, s, t; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); } has_visited.assign(N, false); DFS(G, s); if (has_visited[t]) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; }  å†å¸°ã‚’ä½¿ã£ãŸ DFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; void DFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; for (auto w: G[v]) { if (has_visited[w]) continue; DFS(G, w); } } int main() { int N, M, s, t; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); } has_visited.assign(N, false); DFS(G, s); if (has_visited[t]) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; }  BFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; queue\u0026lt;int\u0026gt; suspended; void BFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; suspended.push(v); while (!suspended.empty()) { int u = suspended.front(); suspended.pop(); for (auto w: G[u]) { if (has_visited[w]) continue; else { has_visited[u] = true; suspended.push(w); } } } } int main() { int N, M, s, t; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); } has_visited.assign(N, false); BFS(G, s); if (has_visited[t]) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ã‚°ãƒªãƒƒãƒ‰ã‚°ãƒ©ãƒ• ã‚°ãƒ©ãƒ•ãŒäºŒæ¬¡å…ƒã‚°ãƒªãƒƒãƒ‰ã¨ã—ã¦ä¸ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ãªå•é¡Œã‚‚é »å‡ºã§ã‚ã‚‹ï¼ã‚°ãƒªãƒƒãƒ‰å½¢å¼ã§ã®ã‚°ãƒ©ãƒ•ã®å…¥åŠ›ã¯ãŸã„ã¦ã„ä»¥ä¸‹ã®ã‚ˆã†ãªå½¢å¼ã§ã‚ã‚‹ï¼\n ã€å…¥åŠ›ã€‘\n10 10 // ç›¤é¢ã‚µã‚¤ã‚ºï¼ˆç¸¦ãƒ»æ¨ªï¼‰ s......... // s: ã‚¹ã‚¿ãƒ¼ãƒˆä½ç½® #########. // g: ã‚´ãƒ¼ãƒ«ä½ç½® #.......#. // ã€Œ.ã€ã¯é€šè·¯ #..####.#. // ã€Œ#ã€ã¯å£ï¼ˆé€²ã‚€ã“ã¨ãŒã§ããªã„ï¼‰ ##....#.#. #####.#.#. g.#.#.#.#. #.#.#.#.#. #.#.#.#.#. #.....#...  ä¸ãˆã‚‰ã‚ŒãŸè¿·è·¯å†…ã‚’ï¼Œä¸Šä¸‹å·¦å³ã«ç§»å‹•ã—ãªãŒã‚‰é€šè·¯ãƒã‚¹.ã®ã¿ã‚’é€šã£ã¦sã‹ã‚‰gã¾ã§ãŸã©ã‚Šç€ã‘ã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹ï¼\n ã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½¿ã£ãŸ DFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; int H, W; vector\u0026lt;string\u0026gt; maze; bool has_visited[510][510]; stack\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; suspended; void DFS(int h, int w) { suspended.push(make_pair(h, w)); has_visited[h][w] = true; while (!suspended.empty()) { int ch, cw; tie(ch, cw) = suspended.top(); suspended.pop(); for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = ch + dx[dir]; int nw = cw + dy[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; // å ´å¤–ãªã®ã§é€²ã‚ãš  if (maze[nh][nw] == \u0026#39;#\u0026#39;) continue; // å£ãªã®ã§é€²ã‚ãš  if (has_visited[nh][nw]) continue; else { has_visited[ch][cw] = true; suspended.push(make_pair(nh, nw)); } } } } int main(){ cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W; maze.resize(H); for (int h = 0; h \u0026lt; H; h++) cin \u0026gt;\u0026gt; maze[h]; int sh, sw, gh, gw; for (int h = 0; h \u0026lt; H; h++) { for (int w = 0; w \u0026lt; W; w++) { if (maze[h][w] == \u0026#39;s\u0026#39;) sh = h, sw = w; if (maze[h][w] == \u0026#39;g\u0026#39;) gh = h, gw = w; } } memset(has_visited, 0, sizeof(has_visited)); DFS(sh, sw); if (has_visited[gh][gw]) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; }  å†å¸°ã‚’ä½¿ã£ãŸ DFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; int H, W; vector\u0026lt;string\u0026gt; maze; bool has_visited[510][510]; void DFS(int h, int w) { has_visited[h][w] = true; for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = h + dx[dir]; int nw = w + dy[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; // å ´å¤–ãªã®ã§é€²ã‚ãš  if (maze[nh][nw] == \u0026#39;#\u0026#39;) continue; // å£ãªã®ã§é€²ã‚ãš  if (has_visited[nh][nw]) continue; DFS(nh, nw); } } int main(){ cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W; maze.resize(H); for (int h = 0; h \u0026lt; H; h++) cin \u0026gt;\u0026gt; maze[h]; int sh, sw, gh, gw; for (int h = 0; h \u0026lt; H; h++) { for (int w = 0; w \u0026lt; W; w++) { if (maze[h][w] == \u0026#39;s\u0026#39;) sh = h, sw = w; if (maze[h][w] == \u0026#39;g\u0026#39;) gh = h, gw = w; } } memset(has_visited, 0, sizeof(has_visited)); DFS(sh, sw); if (has_visited[gh][gw]) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; }  BFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; int H, W; vector\u0026lt;string\u0026gt; maze; bool has_visited[510][510]; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; suspended; void BFS(int h, int w) { suspended.push(make_pair(h, w)); has_visited[h][w] = true; while (!suspended.empty()) { int ch, cw; tie(ch, cw) = suspended.front(); suspended.pop(); for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = ch + dx[dir]; int nw = cw + dy[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; // å ´å¤–ãªã®ã§é€²ã‚ãš  if (maze[nh][nw] == \u0026#39;#\u0026#39;) continue; // å£ãªã®ã§é€²ã‚ãš  if (has_visited[nh][nw]) continue; else { has_visited[ch][cw] = true; suspended.push(make_pair(nh, nw)); } } } } int main(){ cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W; maze.resize(H); for (int h = 0; h \u0026lt; H; h++) cin \u0026gt;\u0026gt; maze[h]; int sh, sw, gh, gw; for (int h = 0; h \u0026lt; H; h++) { for (int w = 0; w \u0026lt; W; w++) { if (maze[h][w] == \u0026#39;s\u0026#39;) sh = h, sw = w; if (maze[h][w] == \u0026#39;g\u0026#39;) gh = h, gw = w; } } memset(has_visited, 0, sizeof(has_visited)); BFS(sh, sw); if (has_visited[gh][gw]) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } é€£çµæˆåˆ†ã®ã‚«ã‚¦ãƒ³ãƒˆ é€£çµã¨ã¯é™ã‚‰ãªã„ï¼ˆã¤ã¾ã‚Šã¶ã£ãŸåˆ‡ã‚Œã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ï¼‰ã‚°ãƒ©ãƒ•ãŒä¸ãˆã‚‰ã‚Œï¼Œãã®é€£çµæˆåˆ†ã®å€‹æ•°ã‚’æ•°ãˆã‚‹ï¼ã“ã‚Œã‚‚å˜ç´”ã«ã¾ã æ¢ç´¢ã—ã¦ã„ãªã„é ‚ç‚¹ã‚’ 1 ã¤é¸ã‚“ã§$v$ã¨ã—ï¼Œ$v$ã‚’å§‹ç‚¹ã¨ã™ã‚‹ DFS ã¾ãŸã¯ BFS ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’ï¼Œå…¨é ‚ç‚¹ãŒæ¢ç´¢æ¸ˆã¿ã«ãªã‚‹ã¾ã§ç¹°ã‚Šè¿”ã›ã°è‰¯ã„ï¼\n ã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½¿ã£ãŸ DFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; stack\u0026lt;int\u0026gt; suspended; void DFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; suspended.push(v); while (!suspended.empty()) { int u = suspended.top(); suspended.pop(); for (auto w: G[u]) { if (has_visited[w]) continue; else { has_visited[u] = true; suspended.push(w); } } } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } int cnt = 0; has_visited.assign(N, false); for (int v = 0; v \u0026lt; N; v++) { if (has_visited[v]) continue; DFS(G, v); cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; }  å†å¸°ã‚’ä½¿ã£ãŸ DFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; void DFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; for (auto w: G[v]) { if (has_visited[w]) continue; else DFS(G, w); } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } int cnt = 0; has_visited.assign(N, false); for (int v = 0; v \u0026lt; N; v++) { if (has_visited[v]) continue; DFS(G, v); cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; }  BFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; queue\u0026lt;int\u0026gt; suspended; void BFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; suspended.push(v); while (!suspended.empty()) { int u = suspended.front(); suspended.pop(); for (auto w: G[u]) { if (has_visited[w]) continue; else { has_visited[u] = true; suspended.push(w); } } } } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } int cnt = 0; has_visited.assign(N, false); for (int v = 0; v \u0026lt; N; v++) { if (has_visited[v]) continue; BFS(G, v); cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } äºŒéƒ¨ã‚°ãƒ©ãƒ•åˆ¤å®š ä¸ãˆã‚‰ã‚ŒãŸã‚°ãƒ©ãƒ•ãŒäºŒéƒ¨ã‚°ãƒ©ãƒ•ã§ã‚ã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹ï¼äºŒéƒ¨ã‚°ãƒ©ãƒ•ã¨ã¯ã€Œå…¨é ‚ç‚¹ã‚’ç™½ã¾ãŸã¯é»’ã«å¡—ã£ã¦ã„ãã¨ãï¼Œç™½é ‚ç‚¹åŒå£«ãŒè¾ºã§çµã°ã‚Œã‚‹ã“ã¨ãŒãªãã‹ã¤é»’é ‚ç‚¹åŒå£«ãŒè¾ºã§çµã°ã‚Œã‚‹ã“ã¨ãŒãªã„ã‚ˆã†ã«é ‚ç‚¹ã‚’å¡—ã‚Šåˆ†ã‘ã‚‰ã‚Œã‚‹ã‚°ãƒ©ãƒ•ã€ã®ã“ã¨ã§ã‚ã‚‹ï¼\nåˆ¤å®šæ–¹æ³•ã¯ç°¡å˜ã§ã‚ã‚‹ï¼é©å½“ãªé ‚ç‚¹ã‚’ç™½ã‚‚ã—ãã¯é»’ã«å¡—ã£ãŸã¨ãï¼Œãã®é ‚ç‚¹ã‚’å§‹ç‚¹ã«è‡ªå‹•çš„ã«éš£æ¥é ‚ç‚¹ãŸã¡ã®è‰²ãŒæ¬¡ã€…ã«æ±ºã¾ã‚‹ï¼å¡—ã‚ŠãªãŒã‚‰ï¼Œéš£æ¥ã™ã‚‹é ‚ç‚¹ãŒåŒã˜è‰²ã«ãªã£ã¦ã—ã¾ã†ã‹ã‚’ç¢ºèªã™ã‚Œã°åˆ¤å®šã§ãã‚‹ï¼å…¨é ‚ç‚¹ã‚’å¡—ã‚‹ã“ã¨ãŒã§ãã‚Œã°ï¼Œãã®ã‚°ãƒ©ãƒ•ã¯äºŒéƒ¨ã‚°ãƒ©ãƒ•ã§ã‚ã‚‹ã¨è¨€ãˆã‚‹ï¼\nã¾ãŸï¼Œé…åˆ—has_visitedã¯æœªè¨ªå•ã§ã‚ã‚‹ã“ã¨ã‚’è¡¨ã™è‰²ã‚’å°å…¥ã™ã‚‹ã“ã¨ã§ï¼Œé ‚ç‚¹ã®è‰²ã‚’ä¿æŒã™ã‚‹é…åˆ—ã«ã¾ã¨ã‚ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\n å†å¸°ã‚’ä½¿ã£ãŸ DFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;int\u0026gt; color; // color[i]: 0 = é»’, 1 = ç™½, -1 = æœªè¨ªå• bool DFS(const Graph \u0026amp;G, int v, int current_color = 0) { color[v] = current_color; for (auto w: G[v]) { if (color[w] != -1) { if (color[w] == current_color) return false; continue; } if (!DFS(G, w, 1 - current_color)) return false; } return true; } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } color.assign(N, -1); bool is_bipartite = true; for (int v = 0; v \u0026lt; N; v++) { if (color[v] != -1) continue; if (!DFS(G, v)) is_bipartite = false; } if (is_bipartite) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } BFS ã§ã¯ã€Œå§‹ç‚¹é ‚ç‚¹ã‹ã‚‰ã®è·é›¢ã«ã‚ˆã£ã¦é ‚ç‚¹ã‚’ãƒ¬ãƒ™ãƒ«åˆ†ã‘ã™ã‚‹ã€ã“ã¨ã«ãªã‚Šï¼Œä¸ãˆã‚‰ã‚ŒãŸã‚°ãƒ©ãƒ•ãŒäºŒéƒ¨ã‚°ãƒ©ãƒ•ãªã‚‰å§‹ç‚¹ã‹ã‚‰ã®è·é›¢ãŒå¶æ•°ãªã‚‰å§‹ç‚¹ã¨åŒã˜è‰²ï¼Œå¥‡æ•°ãªã‚‰ç•°ãªã‚‹è‰²ã¨ãªã‚‹ï¼ã“ã“ã§ï¼Œäº’ã„ã«éš£æ¥ã™ã‚‹é ‚ç‚¹é–“ã§ã¯å§‹ç‚¹ã‹ã‚‰ã®è·é›¢ãŒ 1 ã ã‘ã“ã¨ãªã‚‹ã®ã§ï¼Œã€Œã‚°ãƒ©ãƒ•ãŒäºŒéƒ¨ã‚°ãƒ©ãƒ•ã§ã‚ã‚‹ã€ã¨ã€ŒBFS ã«ã‚ˆã£ã¦è¨ˆç®—ã•ã‚Œã‚‹å„é ‚ç‚¹ã®å§‹ç‚¹ã‹ã‚‰ã®è·é›¢ãŒç­‰ã—ã„ 2 é ‚ç‚¹ã¯éš£æ¥ã—ãªã„ã€ã¯åŒå€¤ã¨ãªã‚‹ï¼\n BFS ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i =0 ; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } bool is_bipartite = true; vector\u0026lt;int\u0026gt; distance(N, -1); queue\u0026lt;int\u0026gt; suspended; for (int v = 0; v \u0026lt; N; v++) { if (distance[v] != -1) continue; distance[v] = 0; suspended.push(v); while (!suspended.epmty()) { int v = suspended.front(); suspended.pop(); for (auto w: G[v]) { if (dist[w] == -1) { dist[w] = dist[v] + 1; suspended.push(w); } else { if (dist[v] == dist[w]) is_bipartite = false; } } } } if (is_bipartite) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; MM endl; return 0; } æœ¨ã«å¯¾ã™ã‚‹ DFS ã€Œæœ¨ã€ã¯ã€Œé–‰è·¯ã®ãªã„é€£çµãªã‚°ãƒ©ãƒ•ã€ã§ã‚ã‚‹ï¼æœ¨ã«å¯¾ã™ã‚‹ DFS ã§ã¯ï¼Œæ¬¡ã«è¨ªå•ã™ã‚‹é ‚ç‚¹ã‚’æ¢ã™ã¨ãã«ï¼Œå¿…ãšã€Œè¦ªãŒã™ã§ã«è¨ªå•æ¸ˆã¿ã§ã‚ã‚‹ã€ã¨ãƒãƒ¼ã‚¯ã•ã‚Œã¦ã„ã‚‹ï¼ã“ã®ã“ã¨ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ï¼Œæ ¹ã®ãªã„æœ¨ã«å¯¾ã—ã¦ï¼Œä¸ãˆã‚‰ã‚ŒãŸé ‚ç‚¹ã‚’æ ¹ã¨ã—ãŸã¨ãã®æ ¹ä»˜ãæœ¨ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ä»¥ä¸‹ã§ã¯ï¼Œä¸ãˆã‚‰ã‚ŒãŸã‚°ãƒ©ãƒ•$G$ã‚’ï¼Œé ‚ç‚¹$0$ã‚’æ ¹ã¨ã—ãŸæ ¹ä»˜ãæœ¨ã¨è¦‹ãŸã¨ãã®ï¼Œå„é ‚ç‚¹ã®æ·±ã•ï¼ˆæ ¹ã‹ã‚‰ã®è·é›¢ï¼‰ã¨ãã®é ‚ç‚¹ã‚’æ ¹ã¨ã™ã‚‹éƒ¨åˆ†æœ¨ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—ã™ã‚‹ï¼é ‚ç‚¹ã®æ·±ã•ã¯ï¼Œæ ¹ã‹ã‚‰ã®è·é›¢ã§ã‚ã‚Šï¼Œè¡ŒããŒã‘æ™‚ã«æ±ºã¾ã‚‹ï¼ãªãœãªã‚‰ï¼Œã‚ã‚‹é ‚ç‚¹ã®æ·±ã•ã¯ï¼Œãã®é ‚ç‚¹ã®è¦ªã®æ·±ã•ã« 1 ã‚’è¶³ã—ãŸã‚‚ã®ã§ã‚ã‚‹ï¼ä¸€æ–¹ã§ï¼Œéƒ¨åˆ†æœ¨ã®ã‚µã‚¤ã‚ºã¯ï¼Œå¸°ã‚ŠãŒã‘æ™‚ã«æ±ºã¾ã‚‹ï¼ãªãœãªã‚‰ï¼Œè‡ªèº«ã‚’æ ¹ã¨ã™ã‚‹éƒ¨åˆ†æœ¨ã®ã‚µã‚¤ã‚ºã¯ï¼Œè‡ªåˆ†ã®å­ä¾›ã‚’æ ¹ã¨ã™ã‚‹éƒ¨åˆ†æœ¨ã®ã‚µã‚¤ã‚ºã®ç·å’Œã« 1 è¶³ã—ãŸã‚‚ã®ã§ã‚ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;int\u0026gt; depth; vector\u0026lt;int\u0026gt; subtree_size; void DFS(const Graph \u0026amp;G, int v, int p, int d) { // è¡ŒããŒã‘æ™‚  depth[v] = d; for (auto w: G[v]) { if (w == p) continue; DFS(G, w, v); } // å¸°ã‚ŠãŒã‘æ™‚  subtree_size[v] = 0; for (auto child: G[v]) { if (child == p) continue; // éš£æ¥é ‚ç‚¹ãŒè¦ªã—ã‹ã„ãªã„ï¼ã¤ã¾ã‚Šæœ¨ã‹ã‚‰è¦‹ã‚‹ã¨è‘‰  subtree_size[v] += subtree_size[c]; } subtree_size[v] += 1; // è‡ªåˆ†è‡ªèº« } int main() { int N; cin \u0026gt;\u0026gt; N; // æœ¨ã®è¾ºæ•° = é ‚ç‚¹æ•° - 1  Graph G(N); for (int i = 0; i \u0026lt; N-1; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } int root = 0; depth.assign(N, 0); subtree_size.assign(N, 0); DFS(G, root, -1); // ã‚°ãƒ©ãƒ•Gã‚’ï¼Œé ‚ç‚¹0ã‚’æ ¹ã¨ã—ãŸæ ¹ä»˜ãæœ¨ã¨ã—ã¦DFS  for (int v = 0; v \u0026lt; N; v++) { cout \u0026lt;\u0026lt; \u0026#34;node[\u0026#34; \u0026lt;\u0026lt; v \u0026#34;]: depth = \u0026#34; \u0026lt;\u0026lt; depth[v] \u0026lt;\u0026lt; \u0026#34;, subtree_size = \u0026#34; \u0026lt;\u0026lt; subtree_size[v] \u0026lt;\u0026lt; endl; } return 0; } ä¸€èˆ¬ã«ï¼Œå­ãƒãƒ¼ãƒ‰ã®æƒ…å ±ã‚’ç”¨ã„ã¦è¦ªãƒãƒ¼ãƒ‰ã®æƒ…å ±ã‚’æ›´æ–°ã™ã‚‹å‡¦ç†ã‚’æœ¨ DPã¨ã„ã†ï¼è¡ŒããŒã‘æ™‚ã«ã¯ã€Œè¦ªãƒãƒ¼ãƒ‰ã®æƒ…å ±ã‚’å­ãƒãƒ¼ãƒ‰ã«é…ã‚‹ã€ã‚ˆã†ãªå‡¦ç†ã‚’ã—ï¼Œå¸°ã‚ŠãŒã‘æ™‚ã«ã¯ã€Œå­ãƒãƒ¼ãƒ‰ã®æƒ…å ±ã‚’è¦ªãƒãƒ¼ãƒ‰ã«é›†ã‚ã¦è¦ªãƒãƒ¼ãƒ‰ã®æƒ…å ±ã‚’æ›´æ–°ã™ã‚‹ã€ã‚ˆã†ãªå‡¦ç†ã‚’ã™ã‚‹ã¨è‰¯ã„ï¼\nãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆ ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã¨ã¯ï¼Œé–‰è·¯ã®å­˜åœ¨ã—ãªã„æœ‰å‘ã‚°ãƒ©ãƒ•ï¼ˆã“ã®ã‚ˆã†ãªã‚°ãƒ©ãƒ•ã‚’ DAG ã¨ã„ã†ï¼‰ã«å¯¾ã—ã¦ï¼Œè¾ºã®å‘ããŒæƒã†ã‚ˆã†ã«é ‚ç‚¹ã‚’ä¸¦ã¹ã‚‹ã‚ˆã†ãªã‚½ãƒ¼ãƒˆã®ã“ã¨ã‚’æŒ‡ã—ï¼Œã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ãƒ»ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰é–“ã®ä¾å­˜é–¢ä¿‚ã‚’è§£æ±ºã™ã‚‹ã‚ˆã†ãªå ´é¢ã§ç”¨ã„ã‚‰ã‚Œã‚‹ï¼ã¾ãŸï¼ŒDAG ã§ã‚ã‚‹ã“ã¨ã¯ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆãŒå¯èƒ½ã§ã‚ã‚‹ã“ã¨ã¨åŒå€¤ã§ã‚ã‚‹ã‚‰ã—ã„ï¼\nãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã§ã¯ï¼Œãã®é ‚ç‚¹ã‚’å§‹ç‚¹ã¨ã™ã‚‹è¾ºãŒ 0 æœ¬ã§ã‚ã‚‹ã‚ˆã†ãªé ‚ç‚¹ï¼ˆã‚·ãƒ³ã‚¯ãƒãƒ¼ãƒ‰ï¼‰ãŒæœ«å°¾ã«æ¥ã‚‹.ã‚·ãƒ³ã‚¯ãƒãƒ¼ãƒ‰ã‚’å–ã‚Šé™¤ãï¼Œãã®é ‚ç‚¹ã«å‘ã‹ã£ã¦ã„ãŸè¾ºã‚’å‰Šé™¤ã™ã‚‹ã¨ï¼Œæ–°ãŸã«ã‚·ãƒ³ã‚¯ãƒãƒ¼ãƒ‰ã«ãªã‚‹é ‚ç‚¹ãŒç™ºç”Ÿã™ã‚‹ï¼æ–°ãŸã«ç™ºç”Ÿã—ãŸã‚·ãƒ³ã‚¯ãƒãƒ¼ãƒ‰ã‹ã‚‰é©å½“ã«ä¸€ã¤é¸ã³å‰Šé™¤ã—åŒæ§˜ã®ã“ã¨ã‚’è¡Œã†ï¼ã“ã‚Œã‚’ã™ã¹ã¦ã®é ‚ç‚¹ãŒå‰Šé™¤ã•ã‚Œã‚‹ã¾ã§è¡Œã„ï¼Œé ‚ç‚¹ã®å‰Šé™¤ã•ã‚ŒãŸé€†é †ã‚’å‡ºåŠ›ã™ã‚‹ã¨ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆãŒå®Ÿç¾ã§ãã‚‹ï¼ã“ã®æ–¹æ³•ã ã¨é€†å‘ãã® BFS ã£ã½ã„æŒ™å‹•ã¨ãªã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); vector\u0026lt;int\u0026gt; out_degree(N); // out_degree[i]: é ‚ç‚¹iã‚’å§‹ç‚¹ã¨ã™ã‚‹è¾ºã®æœ¬æ•°  for (int i = 0; i \u0026lt; M; i++) { int from, to; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to; G[to].push_back(from); // è¾ºã‚’é€†å‘ãã«ä¿å­˜ã™ã‚‹  out_degree[from]++; } queue\u0026lt;int\u0026gt; q; for (int i = 0;i \u0026lt; N; i++) if (out_degree == 0) q.push(i); // ã‚·ãƒ³ã‚¯ãƒãƒ¼ãƒ‰ã‚’ã‚­ãƒ¥ãƒ¼ã«çªã£è¾¼ã‚€  vector\u0026lt;int\u0026gt; order; // order[i]: é ‚ç‚¹iã®ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã«ãŠã‘ã‚‹é †ä½ã®é€†é †  while (!q.empty()) { int v = q.front(); q.pop(); order.push_back(v); for (auto neighbor: G[v]) { out_degree[neighbor]--; // ã‚·ãƒ³ã‚¯ãƒãƒ¼ãƒ‰ã«å‘ã‹ã£ã¦ç”Ÿãˆã¦ã„ãŸè¾ºã‚’æ¶ˆã™  if (out_degree[neighbor] == 0) q.push(neighbor); } } reverse(order.begin(), order.end()); for (auto v: order) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; return 0; } ã“ã“ã§ï¼ŒDFS ã®å¸°ã‚ŠãŒã‘é †ã‚’è€ƒãˆã‚‹ã¨ï¼Œã“ã‚Œã¯ã¾ã•ã—ããƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã¨ãªã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; void DFS(const Graph \u0026amp;G, int v, vector\u0026lt;bool\u0026gt; \u0026amp;has_visited, vector\u0026lt;int\u0026gt; \u0026amp;order) { has_visited[v] = true; for (auto w: G[v]) { if (has_visited[w]) continue; DFS(G, w, has_visited, order); } // å¸°ã‚ŠãŒã‘æ™‚  order.push_back(v); } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int from, to; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to; G[from].push_back(to); } vector\u0026lt;bool\u0026gt; has_visited(N, false); vector\u0026lt;int\u0026gt; order; for (int v = 0; v \u0026lt; N; v++) { if (has_visited[v]) continue; DFS(G, v, has_visited, order); } reverse(order.begin(), order.end()); for (auto v: order) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; return 0; } é–‰è·¯æ¤œå‡º ã‚°ãƒ©ãƒ•ã«é–‰è·¯ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’æ¤œå‡ºã™ã‚‹å•é¡Œï¼BFS ã£ã½ã„ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã®æ‰‹æ³•ã‚’è€ƒæ…®ã™ã‚‹ã¨ï¼Œã‚µã‚¤ã‚¯ãƒ«ã«å«ã¾ã‚Œã‚‹é ‚ç‚¹ã¯ã‚·ãƒ³ã‚¯ãƒãƒ¼ãƒ‰ã«ãªã‚‹ã“ã¨ãŒãªã„ã®ã§ï¼Œãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã§ãã‚‹ç¯„å›²ã§ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã—ãŸå¾Œã«ï¼Œã‚­ãƒ¥ãƒ¼ã«å…¥ã£ãŸã“ã¨ãŒãªã„é ‚ç‚¹ãŒå­˜åœ¨ã™ã‚Œã°ï¼Œé–‰è·¯ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ï¼\nä»¥ä¸‹ã¯ï¼Œã‚µã‚¤ã‚¯ãƒ«ã‚’ 1 ã¤å«ã‚€ã“ã¨ãŒä¿è¨¼ã•ã‚ŒãŸç„¡å‘ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦ï¼Œ2 é ‚ç‚¹$a$ï¼Œ$b$ãŒã¨ã‚‚ã«ãã®ã‚µã‚¤ã‚¯ãƒ«ä¸Šã«ã‚ã‚‹ã¨ãã¯2ã‚’ï¼Œãã†ã§ãªã„ã¨ãã¯1ã‚’å‡ºåŠ›ã›ã‚ˆã¨ã„ã†å•é¡Œã®è§£ç­”ã§ã‚ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; int main() { int N; cin \u0026gt;\u0026gt; N; // ã‚µã‚¤ã‚¯ãƒ«ã‚’1ã¤å«ã‚€ã‚°ãƒ©ãƒ•ãªã®ã§è¾ºæ•°ã‚‚N  Graph G(N); vector\u0026lt;int\u0026gt; degree(N, 0); for (int i = 0; i \u0026lt; N; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--; v--; G[u].push_back(v); G[v].push_back(u); degree[u]++; degree[v]++; } queue\u0026lt;int\u0026gt; q; for (int i = 0; i \u0026lt; N; i++) if (degree[i] == 1) q.push(i); vector\u0026lt;bool\u0026gt; has_enqueued(N, false); // has_enqueued[i]: é ‚ç‚¹iãŒã‚­ãƒ¥ãƒ¼ã«å…¥ã£ãŸã“ã¨ãŒã‚ã‚‹ã‹  while (!q.empty()) { int v = q.front(); q.pop(); has_enqueued[v] = true; for (auto w: G[v]) { degree[w]--; if (degree[w] == 1) q.push(w); } } int Q; cin \u0026gt;\u0026gt; Q; for (int _ = 0; _ \u0026lt; Q; _++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a--; b--; if (!has_enqueued[a] \u0026amp;\u0026amp; !has_enqueued[b]) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; } } ã¾ãŸï¼Œä¸ãˆã‚‰ã‚ŒãŸã‚°ãƒ©ãƒ•ã«é–‰è·¯ãŒã‚ã‚‹ã¨ãï¼Œã‚ã‚‹é ‚ç‚¹$v$ã«å¯¾ã—ã¦ï¼Œ$v$ã‹ã‚‰åˆ°é”ã™ã‚‹ã“ã¨ãŒã§ãã‚‹å…¨é ‚ç‚¹ã®æ¢ç´¢ã®çµ‚äº†ã‚ˆã‚Šå‰ã«ï¼ˆã¤ã¾ã‚Šå¸°ã‚ŠãŒã‘æ™‚ã«ãªã‚‹å‰ã«ï¼‰$v$ã«æˆ»ã£ã¦æ¥ã‚‹ã“ã¨ãŒã§ãã‚‹ã“ã¨ã¨åŒå€¤ã§ã‚ã‚‹ï¼ã“ã‚Œã‚’æ¤œçŸ¥ã—ã¦ã‚„ã£ã¦ã‚‚é–‰è·¯æ¤œçŸ¥ã«ãªã‚‹ï¼ã“ã‚Œã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«ã¯ï¼Œhas_visited[i]: é ‚ç‚¹iã‚’è¡ŒããŒã‘é †ã®æ„å‘³ã§è¨ªå•æ¸ˆã¿ï¼Œhas_finished[i]: é ‚ç‚¹iã‚’å¸°ã‚ŠãŒã‘é †ã®æ„å‘³ã§è¨ªå•çµ‚äº†ã¨ã™ã‚‹é…åˆ—ã‚’ç”¨æ„ã‚Œã°è‰¯ã„ï¼ã¾ãŸï¼Œé–‰è·¯ã‚’å¾©å…ƒã¾ã§ã—ãŸã„å ´åˆã«ã¯ï¼Œè¡ŒããŒã‘æ™‚ã«ç©ã¿ï¼Œå¸°ã‚ŠãŒã‘æ™‚ã«å–ã‚Šå‡ºã™ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç”¨æ„ã™ã‚‹ã¨ï¼Œé–‰è·¯ã‚’æ¤œçŸ¥ã—ãŸæ™‚ç‚¹ã§ã®ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸­èº«ãŒé–‰è·¯ã‚’æ§‹æˆã™ã‚‹é ‚ç‚¹ã«ãªã£ã¦ã„ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited, has_finished; int pos = -1; stack\u0026lt;int\u0026gt; history; void DFS(const Graph \u0026amp;G, int v, int p) { has_visited[v] = true; // è¡ŒããŒã‘é †ã®æ„å‘³ã§è¨ªå•æ¸ˆã¿  history.push(v); for (auto w: G[v]) { if (w == p) continue; if (has_finished[w]) continue; if (has_visited[w] \u0026amp;\u0026amp; !has_finished[w]) { // è¡ŒããŒã‘é †ã®æ„å‘³ã§è¨ªå•æ¸ˆã¿ãªã®ã«å¸°ã‚ŠãŒã‘é †ã®æ„å‘³ã§æœªè¨ªå•  pos = w; return; } DFS(G, w, v); if (pos != -1) return; } history.pop(); has_finished[v] = true; // å¸°ã‚ŠãŒã‘é †ã®æ„å‘³ã§è¨ªå•æ¸ˆã¿ } int main() { int N; cin \u0026gt;\u0026gt; N; Graph G(N); for (int i = 0; i \u0026lt; N; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--; v--; G[u].push_back(v); G[v].push_back(u); } has_visited.assign(N, false); has_finished.assign(N, false); pos = -1; DFS(G, 0, -1); set\u0026lt;int\u0026gt; cycle; while (!history.empty()) { int v = history.pop(); cycle.insert(v); history.pop(); if (v == pos) break; } int Q; cin \u0026gt;\u0026gt; Q; for (int _ = 0; _ \u0026lt; Q; _++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a--; b--; if (cycle.count(a) \u0026amp;\u0026amp; cycle.count(b)) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; } return 0; } ã‚°ãƒ©ãƒ•æ¢ç´¢ã®ç·´ç¿’å•é¡Œ  ALDS 1-11 B AOJ 1160 ABC 138 D JOI2009 äºˆé¸ 4 ARC 31 B ABC 126 D CODE FSTIVAL2017 qualB C ALDS 1-11 C ABC 7 C JOI2011 äºˆé¸ 5 JOI2012 äºˆé¸ 5 AOJ 1166 ABC 88 D AOJ 2891  è§£èª¬ ALDS 1-11 B åŸºæœ¬å•é¡Œï¼å†å¸°ã® DFS ãŒæ›¸ãã‚„ã™ã„ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;bool\u0026gt; has_visited; vector\u0026lt;int\u0026gt; d; // è¡ŒããŒã‘ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— vector\u0026lt;int\u0026gt; f; // å¸°ã‚ŠãŒã‘ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— int tick = 0; void DFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; tick++; d[v] = tick; for (auto w: G[v]) { if (has_visited[w]) continue; DFS(G, w); } tick++; f[v] = tick; } int main() { int N; cin \u0026gt;\u0026gt; N; Graph G(N); has_visited.resize(N); has_visited.assign(N, false); d.resize(N); d.assign(N, 0); f.resize(N); f.assign(N, 0); for (int i = 0; i \u0026lt; N; i++) { int u, k; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; k; u--; G[u].resize(0); int v; for (int i = 0; i \u0026lt; k; i++) { cin \u0026gt;\u0026gt; v; v--; G[u].push_back(v); } } for (int i = 0; i \u0026lt; N; i++) { if (!has_visited[i]) DFS(G, i); } for (int i = 0; i \u0026lt; N; i++) { cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f[i] \u0026lt;\u0026lt; endl; } return 0; } AOJ 1160 ã‚°ãƒªãƒƒãƒ‰ã‚°ãƒ©ãƒ•ã®é€£çµæˆåˆ†ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹å•é¡Œï¼æ·±ã•å„ªå…ˆæ¢ç´¢ã§ã‚«ã‚¦ãƒ³ãƒˆã—ã¦ã„ãï¼é™¸ãŒ1ã§æµ·ãŒ0ã§ã‚ã‚‹ãŒï¼Œè¨ªå•æ¸ˆã¿ã®ãƒã‚¹ç›®ã‚’0ã§æ½°ã—ã¦ã„ãã“ã¨ã§é…åˆ—has_visitedã‚’ç”¨æ„ã›ãšã¨ã‚‚å®Ÿè£…ã§ãã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int H, W; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; field; void DFS(int h, int w) { field[h][w] = 0; // è¨ªå•ã—ãŸé™¸ã®ãƒã‚¹ã‚’æµ·ã«ã—ã¦ã—ã¾ã†  for (int dh = -1; dh \u0026lt;= 1; dh++) { for (int dw = -1; dw \u0026lt;= 1; dw++) { int nh = h + dh; int nw = w + dw; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; if (field[nh][nw] == 0) continue; DFS(nh, nw); } } } int main() { while (cin \u0026gt;\u0026gt; W \u0026gt;\u0026gt; H) { if (H == 0 || W == 0) break; field.assign(H, vector\u0026lt;int\u0026gt;(W, 0)); for (int h = 0; h \u0026lt; H; h++) { for (int w = 0; w \u0026lt; W; w++) { cin \u0026gt;\u0026gt; field[h][w]; } } int cnt = 0; for (int h = 0; h \u0026lt; H; h++) { for (int w = 0; w \u0026lt; W; w++) { if (field[h][w] == 0) continue; DFS(h, w); cnt++; } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } ABC 138 D è¦ªãƒãƒ¼ãƒ‰ã®æƒ…å ±ã‚’å­ãƒãƒ¼ãƒ‰ã«é…ã‚‹ã®ã§ï¼ŒDFS ã§è¡ŒããŒã‘ã«ã‚«ã‚¦ãƒ³ã‚¿ã®å€¤ã‚’æ›´æ–°ã™ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;long long\u0026gt; counters; vector\u0026lt;bool\u0026gt; has_visited; void DFS(const Graph \u0026amp;G, int v) { has_visited[v] = true; for (auto w: G[v]) { if (has_visited[w]) continue; else { counters[w] += counters[v]; DFS(G, w); } } } int main() { int N, Q; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; Graph G(N); has_visited.resize(N); has_visited.assign(N, false); counters.resize(N); counters.assign(N, 0); for (int i = 0; i \u0026lt; N-1; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a--; b--; G[a].push_back(b); G[b].push_back(a); } for (int i = 0; i \u0026lt; Q; i++) { int p; cin \u0026gt;\u0026gt; p; p--; long long x; cin \u0026gt;\u0026gt; x; counters[p] += x; } DFS(G, 0); for (int i = 0; i \u0026lt; N; i++) { if (i != N-1) cout \u0026lt;\u0026lt; counters[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; counters[i] \u0026lt;\u0026lt; endl; } return 0; } JOI2009 äºˆé¸ 4 è–„æ°·ã®åœ°å›³ã‚’ã‚°ãƒªãƒƒãƒ‰ã‚°ãƒ©ãƒ•ã¨ã¿ãªã™ã¨ï¼Œå‰²ã‚‹ã“ã¨ã®ã§ãã‚‹è–„æ°·ã®æšæ•°ã¯ã‚°ãƒ©ãƒ•ã®æ·±ã•ã«å¯¾å¿œã™ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, -1, 0, 1}; int H, W, ans = -1; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; has_broken; void DFS(const Graph \u0026amp;G, int h, int w, int d) { ans = max(ans, d); has_broken[h][w] = true; for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = h + dx[dir]; int nw = w + dy[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; if (has_broken[nh][nw]) continue; if (!G[nh][nw]) continue; DFS(G, nh, nw, d+1); } has_broken[h][w] = false; } int main() { cin \u0026gt;\u0026gt; W; cin \u0026gt;\u0026gt; H; has_broken.resize(H); for (int i = 0; i \u0026lt; H; i++) has_broken[i].resize(W); Graph G(H); for (int i = 0; i \u0026lt; H; i++) { G[i].resize(W); } for (int i = 0; i \u0026lt; H; i++) { for (int j = 0; j \u0026lt; W; j++) { int x; cin \u0026gt;\u0026gt; x; G[i][j] = x; } } for (int h = 0; h \u0026lt; H; h++) { for (int w = 0; w \u0026lt; W; w++) { if (!G[h][w]) continue; DFS(G, h, w, 1); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ARC 31 B ã‚°ãƒªãƒƒãƒ‰ã‚°ãƒ©ãƒ•ã®é€£çµæˆåˆ†ã‚«ã‚¦ãƒ³ãƒˆå•é¡Œï¼DFS ã§è§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;string\u0026gt;; const int dh[4] = {1, 0, -1, 0}; const int dw[4] = {0, 1, 0, -1}; const int H = 10, W = 10; void DFS(Graph \u0026amp;G, int h, int w) { G[h][w] = \u0026#39;*\u0026#39;; // è¨ªå•æ¸ˆã¿  for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = h + dh[dir]; int nw = w + dw[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; if (G[nh][nw] == \u0026#39;*\u0026#39;) continue; if (G[nh][nw] == \u0026#39;x\u0026#39;) continue; else { DFS(G, nh, nw); } } } int check(Graph \u0026amp;G) { int cnt = 0; for (int h = 0; h \u0026lt; H; h++) { for (int w = 0; w \u0026lt; W; w++) { if (G[h][w] == \u0026#39;o\u0026#39;) { DFS(G, h, w); cnt++; } } } return cnt; } int main() { Graph G(H); for (int h = 0; h \u0026lt; H; h++) cin \u0026gt;\u0026gt; G[h]; for (int h = 0; h \u0026lt; H; h++) { for (int w = 0; w \u0026lt; W; w++) { if (G[h][w] == \u0026#39;x\u0026#39;) { G[h][w] = \u0026#39;o\u0026#39;; if (check(G) == 1) { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; return 0; } for (int h = 0; h \u0026lt; H; h++) for (int w = 0; w \u0026lt; W; w++) if (G[h][w] == \u0026#39;*\u0026#39;) G[h][w] = \u0026#39;o\u0026#39;; G[h][w] = \u0026#39;x\u0026#39;; } } } cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ABC 126 D äºŒéƒ¨ã‚°ãƒ©ãƒ•åˆ¤å®šå•é¡Œã«ä¼¼ã¦ã„ã‚‹ï¼ã€ŒåŒã˜è‰²ã«å¡—ã‚‰ã‚ŒãŸä»»æ„ã® 2 é ‚ç‚¹ã«ã¤ã„ã¦ãã®è·é›¢ãŒå¶æ•°ã€ã¨ã„ã†æ¡ä»¶ã‹ã‚‰ï¼Œã‚ã‚‹ 1 ã¤é ‚ç‚¹ã®è‰²ã‚’æ±ºã‚ã¦ã—ã¾ãˆã°ï¼Œä»–ã®é ‚ç‚¹ã®è‰²ã¯è‡ªå‹•çš„ã«æ±ºå®šã—ã¦ã—ã¾ã†ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct Edge { int to; int weight; Edge(int to, int weight): to(to), weight(weight) {} }; using Tree = vector\u0026lt;vector\u0026lt;Edge\u0026gt;\u0026gt;; // 1: é»’, 0: ç™½, -1:æœªè¨ªå• vector\u0026lt;int\u0026gt; color; bool DFS(const Tree \u0026amp;T, int v, int current_color = 0) { color[v] = current_color; for (auto e: T[v]) { if (color[e.to] != -1) { if ((e.weight%2 == 1 \u0026amp;\u0026amp; color[e.to] == current_color) \u0026amp;\u0026amp; (e.weight%2 == 0 \u0026amp;\u0026amp; color[e.to] != current_color)) { return false; } else { continue; } } if (e.weight%2 == 0) { if (!DFS(T, e.to, current_color)) { return false; } } else { if (!DFS(T, e.to, 1 - current_color)) { return false; } } } return true; } int main(){ int N; cin \u0026gt;\u0026gt; N; Tree T(N); for (int i = 0; i \u0026lt; N-1; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; u--; v--; T[u].push_back(Edge(v, w)); T[v].push_back(Edge(u, w)); } color.assign(N, -1); for (int v = 0; v \u0026lt; N; v++) { if (color[v] != -1) continue; if (DFS(T, v)) break; } for (int v = 0; v \u0026lt; N; v++) cout \u0026lt;\u0026lt; color[v] \u0026lt;\u0026lt; endl; return 0; } CODE FSTIVAL2017 qualB C ğŸã•ã‚“ãŒæŒã£ã¦ã„ã‚‹ã®ã¯ï¼Œ$N$é ‚ç‚¹ã®é€£çµãªç„¡å‘ã‚°ãƒ©ãƒ•ï¼æ“ä½œã«ã‚ˆã£ã¦é ‚ç‚¹$u$-é ‚ç‚¹$v$ã«ã¯é•·ã•$3$ã®ãƒ‘ã‚¹ã¨é•·ã•$1$ã®ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼å¥‡æ•°é•·ã®ãƒ‘ã‚¹ã‚’æŒã¤ 2 é ‚ç‚¹$u$ï¼Œ$v$ $\\in V$ã«å¯¾ã—ã¦ï¼Œã€Œæ“ä½œã€ã‚’ç¹°ã‚Šè¿”ã™ã“ã¨ã§$u$ï¼Œ$v$ã‚’ç›´æ¥çµã¶è¾ºãŒç™»å ´ã™ã‚‹ï¼ã“ã‚Œã¯å¸°ç´çš„ã«è¨¼æ˜ã§ãã‚‹ï¼ã€Œã‚°ãƒ©ãƒ•ã«å¥‡æ•°é•·ã®ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã€ã¯ãã®ã‚°ãƒ©ãƒ•ãŒäºŒéƒ¨ã‚°ãƒ©ãƒ•ã§ã‚ã‚‹ã‹ã©ã†ã‹ã«ã‚ˆã£ã¦å¤‰ã‚ã‚‹ï¼\nã¾ãšï¼Œã‚°ãƒ©ãƒ•$G$ãŒäºŒéƒ¨ã‚°ãƒ©ãƒ•ã§ã‚ã‚‹ã¨ãã‚’è€ƒãˆã‚‹ï¼$G$ã¯äºŒéƒ¨ã‚°ãƒ©ãƒ•ãªã®ã§é ‚ç‚¹ã‚’é»’ãƒ»ç™½ã§å¡—ã‚Šåˆ†ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ç•°ãªã‚‹è‰²ã§å¡—ã‚‰ã‚ŒãŸä»»æ„ã®é ‚ç‚¹å¯¾ã‚’å–ã‚‹ã¨ï¼Œ$G$ã¯é€£çµãªã‚°ãƒ©ãƒ•ãªã®ã§ï¼Œãã®é ‚ç‚¹å¯¾é–“ã«ã¯ãƒ‘ã‚¹ãŒå­˜åœ¨ã—ã¦ï¼Œãã®é•·ã•ã¯å¥‡æ•°ã§ã‚ã‚‹ï¼ã‚†ãˆã«ï¼Œã€Œæ“ä½œã€ã‚’ç¹°ã‚Šè¿”ã™ã“ã¨ã§ã„ã¤ã‹ã¯ãã®é ‚ç‚¹å¯¾é–“ã«ã¯è¾ºãŒå¼µã‚‰ã‚Œã‚‹ï¼ã‚ˆã£ã¦ï¼Œ$G$ãŒäºŒéƒ¨ã‚°ãƒ©ãƒ•ã§ã‚ã‚‹ã¨ãï¼Œã€Œæ“ä½œã€ã‚’ç¹°ã‚Šè¿”ã™ã“ã¨ã§ä»»æ„ã®é»’è‰²é ‚ç‚¹-ä»»æ„ã®ç™½è‰²é ‚ç‚¹é–“ã«è¾ºã‚’å¼µã‚‹ã“ã¨ãŒã§ãã‚‹ï¼è¿½åŠ ã§ãã‚‹è¾ºã®æœ¬æ•°ã¯ï¼Œé»’è‰²é ‚ç‚¹æ•°ã¨ç™½è‰²é ‚ç‚¹æ•°ã®ç©ã‹ã‚‰ã™ã§ã«å­˜åœ¨ã™ã‚‹è¾ºæ•°$M$ã‚’å¼•ã„ãŸå€¤ã¨ãªã‚‹ï¼\næ¬¡ã«ã‚°ãƒ©ãƒ•$G$ãŒäºŒéƒ¨ã‚°ãƒ©ãƒ•ã§ãªã„ã¨ãã‚’è€ƒãˆã‚‹ï¼$G$ãŒäºŒéƒ¨ã‚°ãƒ©ãƒ•ã§ãªã„ãªã‚‰ã°ï¼ŒåŒã˜è‰²ã§å¡—ã‚‰ã‚ŒãŸé ‚ç‚¹ã‚’çµã¶è¾ºãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼$G$ã¯é€£çµã§ã‚‚ã‚ã‚‹ã®ã§$V$å†…ã®ä»»æ„ã® 2 é ‚ç‚¹é–“ã«ã¯ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ï¼ã‚ˆã£ã¦ï¼ŒåŒã˜è‰²ã§å¡—ã‚‰ã‚ŒãŸé ‚ç‚¹ã‚’çµã¶è¾ºã®ç«¯ç‚¹ã‚’å«ã‚€é•·ã•ãŒå¥‡æ•°ã®é–‰è·¯ãŒ$G$ã«å­˜åœ¨ã™ã‚‹ã“ã¨ã«ãªã‚‹ï¼ã“ã®é–‰è·¯ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ï¼Œ$G$å†…ã®ä»»æ„ã® 2 é ‚ç‚¹é–“ã«é•·ã•ãŒå¥‡æ•°ã®ãƒ‘ã‚¹ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼$G$ã¯é€£çµãªã®ã§ï¼Œ$V$å†…ã®ä»»æ„ã® 2 é ‚ç‚¹é–“ã«ã¯ãƒ‘ã‚¹ãŒå­˜åœ¨ã—ï¼ŒãŸã¨ãˆãã‚ŒãŒå¶æ•°ã§ã‚ã£ã¦ã‚‚ï¼Œå¥‡æ•°é•·ã®é–‰è·¯ã‚’ä½™åˆ†ã«çµŒã‚‹ã“ã¨ã§ãã®ãƒ‘ã‚¹ã®é•·ã•ã‚’å¥‡æ•°ã«ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼å¥‡æ•°é•·ã®ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã¨ããã®ç«¯ç‚¹ã®é ‚ç‚¹ã¯ã€Œæ“ä½œã€ã‚’ç¹°ã‚Šè¿”ã™ã“ã¨ã§ç›´æ¥çµã¶è¾ºãŒå¼µã‚‰ã‚Œã‚‹ã®ã§ï¼Œ$G$ã¯å®Œå…¨ã‚°ãƒ©ãƒ•ã«ãªã£ã¦ã„ãï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;int\u0026gt; color; bool DFS(const Graph \u0026amp;G, int v, int current_color = 0) { color[v] = current_color; for (auto w: G[v]) { if (color[w] != -1) { if (color[w] == current_color) return false; else continue; } if (!DFS(G, w, 1 - current_color)) return false; } return true; } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; Graph G(N); for (int i = 0; i \u0026lt; M; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a--; b--; G[a].push_back(b); G[b].push_back(a); } color.assign(N, -1); bool is_bipartite = true; for (int v = 0; v \u0026lt; N; v++) { if (color[v] != -1) continue; if (!DFS(G, v)) is_bipartite = false; } if (is_bipartite) { int B = 0, W = 0; for (int v = 0; v \u0026lt; N; v++) { if (color[v] == 0) W++; else if (color[v] == 1) B++; } cout \u0026lt;\u0026lt; W*B - M \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; N*(N-1)/2 - M \u0026lt;\u0026lt; endl; } return 0; } ALDS 1-11 C å¹…å„ªå…ˆæ¢ç´¢ã®åŸºæœ¬å•é¡Œï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Graph = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;int\u0026gt; dist; void BFS(const Graph \u0026amp;G, int v) { queue\u0026lt;int\u0026gt; q; dist[v] = 0; q.push(v); while (!q.empty()) { int w = q.front(); q.pop(); for (auto nn: G[w]) { if (dist[nn] != -1) continue; dist[nn] = dist[w] + 1; q.push(nn); } } } int main() { int N; cin \u0026gt;\u0026gt; N; Graph G(N); for (int i = 0; i \u0026lt; N; i++) { int u, k; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; k; u--; for (int j = 0; j \u0026lt; k; j++) { int v; cin \u0026gt;\u0026gt; v; v--; G[u].push_back(v); } } dist.assign(N, -1); BFS(G, 0); for (int i = 0; i \u0026lt; N; i++) { cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; dist[i] \u0026lt;\u0026lt; endl; } return 0; } ABC 7 C ã‚°ãƒªãƒƒãƒ‰å½¢å¼ã§ã®è¿·è·¯æ¢ç´¢ï¼ã€Œæœ€å°æ‰‹æ•°ã€ãŒã»ã—ã„ã®ã§ BFS ãŒæ‰‹è»½ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int dh[4] = {1, 0, -1, 0}; const int dw[4] = {0, 1, 0, -1}; using Graph = vector\u0026lt;string\u0026gt;; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; suspended; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist; // dist[i][j]: ä½ç½®(sx, sy)ã‹ã‚‰ä½ç½®(i, j)ã¾ã§ã®æœ€å°æ‰‹æ•°  int main() { int H, W; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W; int sh, sw, gh, gw; cin \u0026gt;\u0026gt; sh \u0026gt;\u0026gt; sw \u0026gt;\u0026gt; gh \u0026gt;\u0026gt; gw; sh--; sw--; gh--; gw--; Graph G(H); for (int i = 0; i \u0026lt; H; i++) cin \u0026gt;\u0026gt; G[i]; dist.resize(H); for (int i = 0; i \u0026lt; H; i++) { dist[i].resize(W); dist[i].assign(W, -1); } dist[sh][sw] = 0; suspended.push(make_pair(sh, sw)); while (!suspended.empty()) { int h, w; tie(h, w) = suspended.front(); suspended.pop(); for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = h + dh[dir]; int nw = w + dw[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; if (dist[nh][nw] != -1) continue; if (G[nh][nw] == \u0026#39;#\u0026#39;) continue; dist[nh][nw] = dist[h][w] + 1; suspended.push(make_pair(nh, nw)); } } cout \u0026lt;\u0026lt; dist[gh][gw] \u0026lt;\u0026lt; endl; return 0; } JOI2011 äºˆé¸ 5 ãƒã‚ºãƒŸã®ä½“åŠ›ã®åˆæœŸå€¤ãŒ$1$ã§ã‚ã‚Šï¼Œãƒãƒ¼ã‚º$1$å€‹ã”ã¨ã«ä½“åŠ›ãŒ$1$å¢—ãˆã‚‹ã®ã§ï¼ŒæŸ”ã‚‰ã‹ã•é †ã«ãƒãƒ¼ã‚ºã‚’é£Ÿã¹ã¦ã„ãã“ã¨ã«ãªã‚‹ï¼ãƒãƒ¼ã‚ºå·¥å ´é–“ã®æœ€çŸ­è·é›¢ã‚’æ±‚ã‚ã¦ã„ãï¼å…¨å¯¾æœ€çŸ­è·é›¢ã‚’æ±‚ã‚ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ã£ã¦ã‚‚è‰¯ã„ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using Field = vector\u0026lt;string\u0026gt;; Field F; int H, W, N; const int dh[4] = {1, 0, -1, 0}; const int dw[4] = {0, 1, 0, -1}; int BFS(pair\u0026lt;int, int\u0026gt; from, pair\u0026lt;int, int\u0026gt; to) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(H, vector\u0026lt;int\u0026gt;(W, 1e8)); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; dist[from.first][from.second] = 0; q.push(from); while (!q.empty()) { auto p = q.front(); q.pop(); int h = p.first; int w = p.second; if (pair\u0026lt;int, int\u0026gt;(h, w) == to) { return dist[h][w]; } for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = h + dh[dir]; int nw = w + dw[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; if (F[nh][nw] == \u0026#39;X\u0026#39;) continue; if (dist[h][w] + 1 \u0026lt; dist[nh][nw]) { dist[nh][nw] = dist[h][w] + 1; q.push(pair\u0026lt;int, int\u0026gt;(nh, nw)); } } } return -1; // should not reach here } int main() { cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W \u0026gt;\u0026gt; N; F.resize(H); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; factories(N+1); for (int i = 0; i \u0026lt; H; i++) cin \u0026gt;\u0026gt; F[i]; for (int i = 0; i \u0026lt; H; i++) { for (int j = 0; j \u0026lt; W; j++) { if (F[i][j] == \u0026#39;S\u0026#39;) F[i][j] = \u0026#39;0\u0026#39;; if (\u0026#39;0\u0026#39; \u0026lt;= F[i][j] \u0026amp;\u0026amp; F[i][j] \u0026lt;= \u0026#39;9\u0026#39;) { int idx = F[i][j] - \u0026#39;0\u0026#39;; factories[idx] = pair\u0026lt;int, int\u0026gt;(i, j); } } } int ans = 0; for (int i = 0; i \u0026lt; N; i++) { ans += BFS(factories[i], factories[i+1]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } JOI2012 äºˆé¸ 5 ãƒãƒ§ãƒƒãƒˆå¤‰ãªåº§æ¨™ç³»ã«å¯¾ã™ã‚‹ BFSï¼å»ºç‰©ã®ãªã„åŒºç”»ã«å°ã‚’ã¤ã‘ï¼Œå»ºç‰©ã®ãªã„åŒºç”»ã®å‘¨å›²ã«å»ºç‰©ãŒç«‹ã£ã¦ã„ã‚‹åŒºç”»ãŒã‚ã‚Œã°ãã®å¢ƒç•Œã¯è‰²ã‚’å¡—ã‚‹ã“ã¨ã«ãªã‚‹ï¼åº§æ¨™ã«ã‚ˆã£ã¦å‘¨å›² 6 åŒºç”»ã®ï¼Œãƒã‚¹ç›®ä½ç½®ãŒå¤‰ã‚ã£ã¦ãã‚‹ã“ã¨ã«æ³¨æ„ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int odx[6] = {-1, -1, 0, 1, 1, 0}; const int ody[6] = { 0, 1, 1, 1, 0, -1}; const int edx[6] = {-1, -1, 0, 1, 1, 0}; const int edy[6] = {-1, 0, 1, 0, -1, -1}; int w, h; int main() { cin \u0026gt;\u0026gt; w \u0026gt;\u0026gt; h; w += 2; h += 2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(h, vector\u0026lt;int\u0026gt;(w, -1)); for (int i = 1; i \u0026lt; h-1; i++) { for (int j = 1; j \u0026lt; w-1; j++) { cin \u0026gt;\u0026gt; a[i][j]; } } auto paint_BFS = [\u0026amp;](int sx, int sy) { queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; q.push(make_pair(sx, sy)); while (!q.empty()) { auto p = q.front(); q.pop(); int x = p.first, y = p.second; for (int dir = 0; dir \u0026lt; 6; dir++) { int nx, ny; if (x%2 == 1) { nx = x + odx[dir]; ny = y + ody[dir]; } else { nx = x + edx[dir]; ny = y + edy[dir]; } if (nx \u0026lt; 0 || h \u0026lt;= nx || ny \u0026lt; 0 || w \u0026lt;= ny) continue; if (a[nx][ny] == 1) continue; if (a[nx][ny] == -1) continue; a[nx][ny] = -1; q.push(make_pair(nx, ny)); } } }; for (int i = 0; i \u0026lt; h; i++) { for (int j = 0; j \u0026lt; w; j++) { if (a[i][j] == -1) paint_BFS(i, j); } } int ans = 0; { queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; q.push(make_pair(0, 0)); while (!q.empty()) { auto p = q.front(); q.pop(); int x = p.first, y = p.second; if (a[x][y] == 0) continue; for (int dir = 0; dir \u0026lt; 6; dir++) { int nx, ny; if (x%2 == 1) { nx = x + odx[dir]; ny = y + ody[dir]; } else { nx = x + edx[dir]; ny = y + edy[dir]; } if (nx \u0026lt; 0 || h \u0026lt;= nx || ny \u0026lt; 0 || w \u0026lt;= ny) continue; if (a[nx][ny] == 0) continue; if (a[nx][ny] == 1) { ans++; continue; } q.push(make_pair(nx, ny)); } a[x][y] = 0; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } AOJ 1166 ã‚„ã‚„ãƒˆãƒªãƒƒã‚­ãƒ¼ãªå½¢ã§è¿·è·¯æƒ…å ±ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼å†…å®¹ã¯åŸºæœ¬çš„ãª BFS ã«éããªã„ï¼BFS ã®ã©ã“ã§è¿·è·¯ã®æƒ…å ±ã‚’ä½¿ã†ã‹ã¨ã„ã†ã¨ï¼Œã€Œéš£æ¥ãƒã‚¹ã«è¡Œã‘ã‚‹ã®ã‹ã€ã‚’çŸ¥ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã‚ã‚‹ï¼ã‚ˆã£ã¦ï¼Œç¸¦æ¨ªã®ä»•åˆ‡ã‚Šã®æƒ…å ±ã‚’ãã‚Œãã‚Œåˆ¥ã®å½¢ã§æŒã£ã¦ãŠã„ã¦ï¼Œéš£æ¥ãƒã‚¹ã¸ã®ç§»å‹•ã‚’è€ƒãˆã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãã®æƒ…å ±ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ï¼\nhorizontal_partitionï¼Œvertical_partitionã¨ã„ã† 2 ã¤ã®é…åˆ—ã§è¿·è·¯æƒ…å ±ã‚’ä¿æŒã™ã‚‹ï¼\n   ã©ã®é…åˆ—ã®ã©ã®è¦ç´ ãŒã©ã“ã®å£ã®ã“ã¨ã‚’æŒ‡ã™ã®ã‹ã‚’æ•´ç†ã™ã‚‹ï¼   #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int INF = 1001001; const int dh[4] = {0, 1, 0, -1}; const int dw[4] = {1, 0, -1, 0}; int main() { while (1) { int W, H; cin \u0026gt;\u0026gt; W \u0026gt;\u0026gt; H; if (W == 0 \u0026amp;\u0026amp; H == 0) break; int vertical_partition[H][W-1]; int horizontal_partition[H-1][W]; for (int i = 0; i \u0026lt; 2*H - 1; i++) { if (i%2 == 0) { for (int j = 0; j \u0026lt; W-1; j++) cin \u0026gt;\u0026gt; vertical_partition[i/2][j]; } else { for (int j = 0; j \u0026lt; W; j++) cin \u0026gt;\u0026gt; horizontal_partition[i/2][j]; } } int dist[H][W]; for (int i = 0; i \u0026lt; H; i++) for (int j = 0; j \u0026lt; W; j++) dist[i][j] = INF; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; dist[0][0] = 0; q.push(make_pair(0, 0)); while (!q.empty()) { auto p = q.front(); q.pop(); int h = p.first; int w = p.second; for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = h + dh[dir]; int nw = w + dw[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; if (nh == h+1 \u0026amp;\u0026amp; nw == w \u0026amp;\u0026amp; horizontal_partition[h][w] == 1) continue; if (nh == h \u0026amp;\u0026amp; nw == w+1 \u0026amp;\u0026amp; vertical_partition[h][w] == 1) continue; if (nh == h-1 \u0026amp;\u0026amp; nw == w \u0026amp;\u0026amp; horizontal_partition[h-1][w] == 1) continue; if (nh == h \u0026amp;\u0026amp; nw == w-1 \u0026amp;\u0026amp; vertical_partition[h][w-1] == 1) continue; if (dist[nh][nw] != INF) continue; dist[nh][nw] = dist[h][w] + 1; q.push(make_pair(nh, nw)); } } cout \u0026lt;\u0026lt; (dist[H-1][W-1] == INF ? 0 : dist[H-1][W-1] + 1) \u0026lt;\u0026lt; endl; } return 0; } ABC 88 D è¦ã™ã‚‹ã«ï¼Œ$(1, 1)$ã‹ã‚‰$(H, W)$ã¾ã§æœ€çŸ­çµŒè·¯ã§ï¼ˆï¼é€šã‚‹ç™½ã„ãƒã‚¹ã®æ•°ãŒæœ€å°ãªçµŒè·¯ã§ï¼‰ã„ã‘ã°ï¼Œãã‚Œä»¥å¤–ã®ãƒã‚¹ã¯é»’ã«å¡—ã‚‹ã“ã¨ãŒã§ãå¾—ç‚¹ã‚’æœ€å¤§åŒ–ã§ãã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int dh[4] = {1, 0, -1, 0}; const int dw[4] = {0, 1, 0, -1}; using Graph = vector\u0026lt;string\u0026gt;; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; suspended; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist; // dist[i][j]: ä½ç½®(sx, sy)ã‹ã‚‰ä½ç½®(i, j)ã¾ã§ã®æœ€å°æ‰‹æ•°  int main() { int H, W; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W; Graph G(H); for (int i = 0; i \u0026lt; H; i++) cin \u0026gt;\u0026gt; G[i]; dist.resize(H); for (int i = 0; i \u0026lt; H; i++) { dist[i].resize(W); dist[i].assign(W, -1); } dist[0][0] = 0; suspended.push(make_pair(0, 0)); while (!suspended.empty()) { int h, w; tie(h, w) = suspended.front(); suspended.pop(); for (int dir = 0; dir \u0026lt; 4; dir++) { int nh = h + dh[dir]; int nw = w + dw[dir]; if (nh \u0026lt; 0 || H \u0026lt;= nh || nw \u0026lt; 0 || W \u0026lt;= nw) continue; if (dist[nh][nw] != -1) continue; if (G[nh][nw] == \u0026#39;#\u0026#39;) continue; dist[nh][nw] = dist[h][w] + 1; suspended.push(make_pair(nh, nw)); } } int white = 0; int ans = 0; for (int i = 0; i \u0026lt; H; i++) { for (int j = 0; j \u0026lt; W; j++) { if (G[i][j] == \u0026#39;.\u0026#39;) white++; } } if (dist[H-1][W-1] == -1) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; white - dist[H-1][W-1] - 1 \u0026lt;\u0026lt; endl; return 0; } ","date":1586222823,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1586222823,"objectID":"2e781d5d912aa842a25d1d360ff085c5","permalink":"/ja/post/graph-traversal/","publishdate":"2020-04-07T10:27:03+09:00","relpermalink":"/ja/post/graph-traversal/","section":"post","summary":"ã‚°ãƒ©ãƒ•ã‚’æ¢ç´¢ã—ãŸã„ è¨ˆç®—æ©Ÿã‚’ã€Œä¸ãˆã‚‰ã‚ŒãŸå¯¾è±¡ã®ä¸­ã‹ã‚‰ï¼Œç›®çš„ã«åˆè‡´ã™ã‚‹ã‚‚ã®ã‚’è¦‹ã¤ã‘å‡ºã—ãŸã‚Šï¼Œæœ€è‰¯ã®ã‚‚ã®ã‚’è¦‹ã¤ã‘å‡ºã™ã€ã¨ã„ã†ã€Œæ¢ç´¢ã€ç›®çš„ã§ç”¨ã„ã‚‹å ´","tags":["AtCoder","Competitive Programming","C++","cpp","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°","ç«¶ãƒ—ãƒ­","ABC","ã‚°ãƒ©ãƒ•","ã‚°ãƒ©ãƒ•ç†è«–","Graph","Graph Theory","ã‚°ãƒ©ãƒ•æ¢ç´¢","Graph Traversal","æ·±ã•å„ªå…ˆæ¢ç´¢","Depth-First Search","DFS","å¹…å„ªå…ˆæ¢ç´¢","Breadth-First Search","BFS"],"title":"ã‚°ãƒ©ãƒ•æ¢ç´¢","type":"post"},{"authors":[],"categories":[],"content":"äºŒåˆ†æ¢ç´¢ äºŒåˆ†æ¢ç´¢ã¨ã„ã†ã¨ã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã®ä¸­ã‹ã‚‰ç›®çš„ã®å€¤ã‚’åŠ¹ç‡ã‚ˆãï¼ˆå…·ä½“çš„ã«ã¯$O(\\log n)$ï¼‰ã§æ¢ã—å‡ºã™æ‰‹æ³•ã€ã¨ã—ã¦èª¬æ˜ã•ã‚Œã‚‹ã“ã¨ãŒåœ§å€’çš„ã§ï¼Œã¨ã‚‚ã™ã‚‹ã¨ï¼Œã€ŒäºŒåˆ†æ¢ç´¢ã¯ã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã‹ã‚‰å€¤ã‚’æ¢ã™ãŸã‚ã ã‘ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã€ã¨å‹˜é•ã„ã—ã¦ã—ã¾ã†ï¼å®Ÿéš›ï¼Œåƒ•ã‚‚ãã†æ€ã£ã¦ã„ãŸï¼\näºŒåˆ†æ¢ç´¢ã®ã€ŒåŠåˆ†ã«ã—ã¦ã‚µã‚¤ã‚ºã®å°ã•ã„å•é¡Œã‚’è§£ãã€ã¨ã„ã†ã‚¨ãƒƒã‚»ãƒ³ã‚¹ã¯å®Ÿã«å¤šãã®å•é¡Œã«é©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ä¸€èˆ¬åŒ–ã•ã‚ŒãŸäºŒåˆ†æ¢ç´¢ã¨ã‚‚è¨€ã†ã¹ãã‹ï¼\nã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã‹ã‚‰ç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã™ã€äºŒåˆ†æ¢ç´¢ ã¾ãšã¯ï¼Œã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã‹ã‚‰ç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã™ã€ã¨ã„ã†ï¼Œã‚ˆãã‚ã‚‹äºŒåˆ†æ¢ç´¢ã‚’å®Ÿè£…ã—ã¦ã¿ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; vector\u0026lt;int\u0026gt; a = {1, 14, 32, 51, 51, 51, 243, 419, 750, 910}; int binary_search(int key) { int left = 0, right = (int)a.size() - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (a[mid] == key) return mid; else if (key \u0026lt; a[mid]) right = mid - 1; else if (a[mid] \u0026lt; key) left = mid + 1; } return -1; } int main() { cout \u0026lt;\u0026lt; binary_search(51) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; binary_search(0) \u0026lt;\u0026lt; endl; return 0; } æ¢ç´¢ç¯„å›²ã‚’åŠåˆ†ãšã¤å°ã•ãã—ã¦ãã“ã¨ã§ç›®çš„ã®ã‚‚ã®ã‚’è¦‹ã¤ã‘å‡ºã™ï¼æ¢ç´¢ç¯„å›²ãŒæŒ‡æ•°ã®é€Ÿåº¦ã§å°ã•ããªã£ã¦ã„ãã®ã§ï¼Œæ¢ç´¢å¯¾è±¡ãŒã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚Œã°ï¼Œ$O(\\log n)$ã§ç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¦‹ã¤ã‘å‡ºã™ã“ã¨ãŒã§ãã‚‹ï¼\näºŒåˆ†æ¢ç´¢ã®å®Ÿè£…ã¯ã¡ã‚‡ã£ã¨ã‚„ã‚„ã“ã—ã„ï¼ãƒ«ãƒ¼ãƒ—ã®çµ‚äº†æ¡ä»¶ã¨ã‹ï¼Œleftãƒ»rightã®æ›´æ–°ã£ã¦ã©ã†ã—ã¦ãŸã£ã‘ã¨ã‹è€ƒãˆã‚‹ã¨ç›´æ„Ÿçš„ã«ã‚¹ãƒ©ã‚¹ãƒ©æ›¸ã‘ã‚‹æ„Ÿã˜ã§ã¯ãªã„ï¼\nã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã«å¯¾ã—ã¦ï¼Œç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ä»¥ä¸Šã¨ãªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ±‚ã‚ã‚‹ã€äºŒåˆ†æ¢ç´¢ äºŒåˆ†æ¢ç´¢ã‚’ã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã‹ã‚‰ç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã™ã€ã§ã¯ãªãã¦ï¼Œ ã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã«å¯¾ã—ã¦ï¼Œç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ä»¥ä¸Šã¨ãªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ±‚ã‚ã‚‹ã€ ã¨ã™ã‚‹ã ã‘ã§ï¼ŒäºŒåˆ†æ¢ç´¢ã‚’ã„ã‚ã‚“ãªå•é¡Œã«é©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ï¼\nã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã«å¯¾ã™ã‚‹ï¼Œç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ä»¥ä¸Šã¨ãªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€ã‹ã‚‰ã¯\n ç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒï¼Œæ¢ç´¢ç¯„å›²å†…ã§ä½•ç•ªç›®ã«å°ã•ã„ã®ã‹ãŒã‚ã‹ã‚‹ ç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒæ¢ç´¢ç¯„å›²å†…ã«è¤‡æ•°å­˜åœ¨ã™ã‚‹ãªã‚‰ï¼Œãã‚Œã‚‰ã®ã†ã¡æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–ã‚Œã‚‹ ã€Œç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚ˆã‚Šå¤§ãããªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€ã‚’å–ã‚Œã‚Œã°ï¼Œæ¢ç´¢ç¯„å›²å†…ã«ã„ãã¤åŒã˜ã‚¢ã‚¤ãƒ†ãƒ ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ãã‚‹  ã¨ï¼Œã‚ˆã‚Šå¤šãã®æƒ…å ±ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ï¼\nã“ã®ã‚ˆã†ãªæ¢ç´¢ã®æ±åŒ–ã®æœ‰ç”¨æ€§ã¯ï¼Œä¾‹ãˆã°std::lower_bound()é–¢æ•°ãƒ»std::upper_bound()é–¢æ•°ãŒæ¨™æº–ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†…ã§æä¾›ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‹ã‚‰ã‚‚ã†ã‹ãŒã„çŸ¥ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼é–¢æ•°ãŒã©ã‚“ãªè¿”ã‚Šå€¤ã‚’è¿”ã™ã‹æ¬¡ç¬¬ã§ï¼Œãã®é–¢æ•°ã®ä¾¿åˆ©åº¦åˆã„ã‚‚å¤‰ã‚ã£ã¦ãã‚‹ï¼\nstd::lower_bound()é–¢æ•°ã¯ï¼Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—aã¨ç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ keyã‚’ä¸ãˆã‚‹ã“ã¨ã§ï¼Œkey \u0026lt;= a[index]ã¨ãªã‚‹æœ€å°ã®indexã‚’è¿”ã™ï¼\nstd::upper_bound()é–¢æ•°ã¯ï¼Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—aã¨ç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ keyã‚’ä¸ãˆã‚‹ã“ã¨ã§ï¼Œkey \u0026lt; a[index]ã¨ãªã‚‹æœ€å°ã®indexã‚’è¿”ã™ï¼\n   std::lower_bound()ã¨std:upper_bound()   ä¸€èˆ¬åŒ–ã•ã‚ŒãŸäºŒåˆ†æ¢ç´¢ ã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã«å¯¾ã—ã¦ï¼Œç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ä»¥ä¸Šã¨ãªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€ãŒå¾—ã‚‰ã‚ŒãŸã»ã†ãŒä¾¿åˆ©ã¨ã„ã†ã“ã¨ãŒã‚ã‹ã£ãŸã¨ã“ã‚ã§ï¼Œä¸€èˆ¬åŒ–ã•ã‚ŒãŸäºŒåˆ†æ¢ç´¢ã‚’è€ƒãˆã‚‹ã¨ï¼ŒäºŒåˆ†æ¢ç´¢ã¯ï¼Œã€Œã‚ã‚‹æ¡ä»¶ã«ã¤ã„ã¦ï¼Œæ¢ç´¢ç¯„å›²ã«ãŠã„ã¦ï¼Œãã®æ¡ä»¶ã‚’æº€ãŸã™ã‹ã©ã†ã‹ã«ã¤ã„ã¦å˜èª¿æ€§ãŒèªã‚ã‚‰ã‚Œã‚‹ï¼ˆã¤ã¾ã‚Šï¼Œã‚ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚ˆã‚Šå°ã•ã„ã‚¢ã‚¤ãƒ†ãƒ ã¯ãã®æ¡ä»¶ã‚’æº€ãŸã•ãªã„ã‘ã©ï¼Œã‚ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä»¥ä¸Šã®ã‚¢ã‚¤ãƒ†ãƒ ã¯ãã®æ¡ä»¶ã‚’æº€ãŸã™ï¼‰ã¨ãï¼Œãã®æ¡ä»¶ã‚’æº€ãŸã™æœ€å°ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¦‹ã¤ã‘ã‚‹ã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ã—ã¦ä¸€èˆ¬åŒ–ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼äºŒåˆ†æ¢ç´¢ã‚’ã“ã®ã‚ˆã†ã«æ‰ãˆã¦ãŠãã¨ï¼Œç›´æ„Ÿçš„ãªå®Ÿè£…ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ï¼\nã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã«å¯¾ã—ã¦ï¼Œç›®çš„ã®ã‚¢ã‚¤ãƒ†ãƒ ä»¥ä¸Šã¨ãªã‚‹æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ±‚ã‚ã‚‹ã€äºŒåˆ†æ¢ç´¢ã¯æ¬¡ã®ã‚ˆã†ã«å®Ÿè£…ã§ãã‚‹ï¼ã“ã®ã¨ãï¼Œã€Œã‚ã‚‹æ¡ä»¶ã€ã¨ã¯ã€Œkeyä»¥ä¸Šã€ã«ç›¸å½“ã—ï¼Œé…åˆ—ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã¯ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã®ã§ï¼Œæ¡ä»¶ã‚’æº€ãŸã™ã‹å¦ã‹ã«ã¤ã„ã¦ã®å˜èª¿æ€§ãŒèªã‚ã‚‰ã‚Œã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; vector\u0026lt;int\u0026gt; a = {1, 14, 32, 51, 51, 51, 243, 419, 750, 910}; bool is_ok(int index, int key) { if (key \u0026lt;= a[index]) return true; else return false; } int binary_search(int key) { int left = -1; int right = (int)a.size(); while (1 \u0026lt; right - left) { int mid = left + (right - left) / 2; if (is_ok(mid, key)) right = mid; else left = mid; } return right; } int main() { cout \u0026lt;\u0026lt; binary_search(51) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; binary_search(0) \u0026lt;\u0026lt; endl; return 0; } ã“ã®å®Ÿè£…ã§ã¯ï¼Œ\n leftã¯ã€Œå¸¸ã«æ¡ä»¶ã‚’æº€ãŸã•ãªã„è¦ç´ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€ rightã¯ã€Œå¸¸ã«æ¡ä»¶ã‚’æº€ãŸã™è¦ç´ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€  ã¨ã—ï¼Œ\n right - left == 1ã¨ãªã‚‹ã¾ã§ï¼Œã¤ã¾ã‚Šleftã¨rightãŒéš£ã‚Šåˆã†ã¾ã§ï¼Œæ¡ä»¶ã‚’æº€ãŸã™ãƒ»æº€ãŸã•ãªã„ã®å¢ƒç•Œã‚’å‹•ã‹ã—ã¦ã„ã  ã“ã¨ã‚’ç¹°ã‚Šè¿”ã—ã¦ã„ã‚‹ï¼æœ€çµ‚çš„ã«ï¼ŒrightãŒã€Œæ¡ä»¶ã‚’æº€ãŸã™æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€ã¨ãªã‚‹ï¼\næ¡ä»¶ã‚’æº€ãŸã™ã‹å¦ã‹ã®å˜èª¿æ€§ãŒèªã‚ã‚‰ã‚Œã‚‹ã¨ãï¼Œã“ã®ã‚ˆã†ã«å¢ƒç•Œã‚’ç§»å‹•ã•ã›ã¦ã„ãã“ã¨ã§ï¼Œæ¡ä»¶ã‚’æº€ãŸã™æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ä¸€æ–¹ã§ï¼Œå˜èª¿æ€§ãŒãªã„æ¢ç´¢ç¯„å›²ã«ãŠã„ã¦ã“ã‚Œã‚’å®Ÿè¡Œã™ã‚‹ã¨ï¼Œæ¡ä»¶ã‚’æº€ãŸã™ãƒ»æº€ãŸã•ãªã„ã®å¢ƒç•Œã®1ã¤ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãï¼Œã“ã‚Œã¯æ–¹ç¨‹å¼ã®è§£ã®1ã¤ã‚’æ±‚ã‚ã‚‹ã‚ˆã†ãªå ´é¢ã§ä½¿ãˆã‚‹ï¼\nã‚ãã‚‹å¼äºŒåˆ†æ¢ç´¢ ä¸Šã®å®Ÿè£…ã§ã¯ï¼Œleft/rightã®æ€§è³ªã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸãŒï¼Œãã‚Œã™ã‚‰è€ƒæ…®ã™ã‚‹ã“ã¨ãªãå®Ÿè£…ã«è½ã¨ã—è¾¼ã‚€ã“ã¨ãŒã§ãã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; vector\u0026lt;int\u0026gt; a = {1, 14, 32, 51, 51, 51, 243, 419, 750, 910}; bool is_ok(int index, int key) { if (key \u0026lt;= a[index]) return true; else return false; } int binary_search(int key) { int ng = -1; int ok = (int)a.size(); while (1 \u0026lt; abs(ok - ng)) { int mid = (ok + ng) / 2; if (is_ok(mid, key)) ok = mid; else ng = mid; } return ok; } int main() { cout \u0026lt;\u0026lt; binary_search(51) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; binary_search(0) \u0026lt;\u0026lt; endl; return 0; } äºŒåˆ†æ¢ç´¢ã®ç·´ç¿’å•é¡Œ  ALDS 1-4 B JOI2009æœ¬é¸ 2 ABC 77 C ABC 34 D JOI2008 æœ¬é¸3  è§£èª¬ ALDS 1-4 B mapã‚’ä½¿ãˆã°è§£æ±ºã™ã‚‹ã‘ã‚Œã©ã‚‚ï¼ŒäºŒåˆ†æ¢ç´¢ã§ã‚‚è§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int n, q; vector\u0026lt;int\u0026gt; S(n), T(q); bool is_ok(int index, int key) { if (key \u0026lt;= S[index]) return true; else return false; } int binary_search(int key) { int ng = -1; int ok = (int)S.size(); while (1 \u0026lt; abs(ok - ng)) { int mid = (ok + ng) / 2; if (is_ok(mid, key)) ok = mid; else ng = mid; } return ok; } int main() { cin \u0026gt;\u0026gt; n; S.resize(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; S[i]; cin \u0026gt;\u0026gt; q; T.resize(q); for (int i = 0; i \u0026lt; q; i++) cin \u0026gt;\u0026gt; T[i]; int cnt = 0; for (auto k : T) { if (0 \u0026lt;= binary_search(k) \u0026amp;\u0026amp; binary_search(k) \u0026lt; n) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } JOI2009æœ¬é¸ 2 ãƒ”ã‚¶å±‹ã•ã‚“ã¨å®…é…å…ˆã®ä½ç½®é–¢ä¿‚ï¼ˆã¤ã¾ã‚Šï¼Œå®…é…å…ˆã®ã™ãä¸¡è„‡ã«ã‚ã‚‹ãƒ”ã‚¶å±‹ï¼‰ãŒã‚ã‹ã‚Œã°ï¼Œå®…é…å…ˆã®ä¸¡éš£ã®ã†ã¡ã®è¿‘ã„æ–¹ã‹ã‚‰å®…é…ã™ã‚‹ã“ã¨ã§ç„¡é§„ãªã‚³ã‚¹ãƒˆã‚’æ›ã‘ãšã«ãƒ”ã‚¶ã‚’é‹ã³å±Šã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ä¸¡éš£ä»¥å¤–ã®åº—ã‹ã‚‰å®…é…ã—ã‚ˆã†ã¨ã—ãŸã‚‰ï¼Œãã®é“ä¸­ã§ä¸¡éš£ã®åº—ã®ä¸€æ–¹ã«é­é‡ã™ã‚‹ã¯ãšã ï¼ãã‚Šã‚ƒãã†ã ï¼ãªã®ã§ï¼Œèª¿ã¹ã‚‹ã¹ãã¯ï¼Œå®…é…å…ˆã®ã™ãä¸¡éš£ã«ã‚ã‚‹ãƒ”ã‚¶å±‹ãŒã©ã‚Œãªã®ã‹ï¼ãƒ”ã‚¶å±‹ã‚’ï¼Œæœ¬åº—ã‹ã‚‰ã®è·é›¢ã§ã‚½ãƒ¼ãƒˆã—ã¦ãŠã„ã¦ï¼Œå®…é…å…ˆãŒã©ã®ä½ç½®ã«å…¥ã‚‹ã®ã‹ã‚’äºŒåˆ†æ¢ç´¢ã§æ±‚ã‚ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { long long d; int n, m; cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; pizza_stores(n+1); for (int i = 1; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; pizza_stores[i]; pizza_stores[0] = 0; pizza_stores[n] = d; sort(pizza_stores.begin(), pizza_stores.end()); vector\u0026lt;int\u0026gt; houses(m); for (int i = 0; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; houses[i]; long long ans = 0; for (int i = 0; i \u0026lt; m; i++) { auto iter = lower_bound(pizza_stores.begin(), pizza_stores.end(), houses[i]); ans += min(abs(*iter - houses[i]), abs(*(iter - 1) - houses[i])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ABC 77 C ä¸­éƒ¨ã®ãƒ‘ãƒ¼ãƒ„ã®ã‚µã‚¤ã‚ºã‚’$B_i$ã«å›ºå®šã™ã‚‹ã¨ï¼Œä¸Šéƒ¨ã«ä½¿ãˆã‚‹ãƒ‘ãƒ¼ãƒ„ã®ã‚µã‚¤ã‚ºã¯$B_i$ã‚ˆã‚Šå°ã•ã„ã‚‚ã®ã§ï¼Œä¸‹éƒ¨ã«ä½¿ãˆã‚‹ãƒ‘ãƒ¼ãƒ„ã®ã‚µã‚¤ã‚ºã¯$B_i$ã‚ˆã‚Šå¤§ãã„ã‚‚ã®ã§ã‚ã‚‹ï¼ä¸Šéƒ¨ãƒ»ä¸‹éƒ¨ã«ä½¿ãˆã‚‹ãƒ‘ãƒ¼ãƒ„ã‚’ãã‚Œãã‚Œå¤§ãã•é †ã«ã‚½ãƒ¼ãƒˆã—ã¦ãŠã„ã¦äºŒåˆ†æ¢ç´¢ã«ã‚ˆã£ã¦ï¼Œ$B_i$ã‚ˆã‚Šå°ã•ã„ãƒ»å¤§ãã„ãƒ‘ãƒ¼ãƒ„ãŒã„ãã¤ã‚ã‚‹ã‹ã‚’æ•°ãˆã¦æ›ã‘åˆã‚ã›ã‚Œã°ï¼Œä¸­éƒ¨ã«ã‚µã‚¤ã‚º$B_i$ã®ãƒ‘ãƒ¼ãƒ„ã‚’ä½¿ã£ãŸç¥­å£‡ã®ç¨®é¡ãŒå¾—ã‚‰ã‚Œã‚‹ã®ã§ï¼Œã“ã‚Œã‚’$i$ã«ã¤ã„ã¦å‰é€šã‚Šè©¦ã›ã°ç­”ãˆãŒæ±‚ã¾ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;long long\u0026gt; a(n), b(n), c(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; b[i]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; c[i]; sort(a.begin(), a.end()); sort(b.begin(), b.end()); sort(c.begin(), c.end()); long long ans = 0; for (int i = 0; i \u0026lt; n; i++) { long long bi = b[i]; auto aiter = lower_bound(a.begin(), a.end(), bi); auto citer = upper_bound(c.begin(), c.end(), bi); ans += distance(a.begin(), aiter) * distance(citer, c.end()); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ABC 34 D é¢¨èˆ¹ã®å‰²ã‚Šæ–¹ã®ç·æ•°ã¯$N!$é€šã‚Šã ãŒï¼Œ$1 \\leq N \\leq 100000$ã§ã‚ã‚‹ã“ã¨ã‹ã‚‰ãœã‚“ã¶æ¢ç´¢ã™ã‚‹ã®ã§ã¯é–“ã«åˆã‚ãªã„ï¼\nå•é¡Œã‚’ã€ŒãƒšãƒŠãƒ«ãƒ†ã‚£ã®æœ€å°åŒ–å•é¡Œã€ã¨æ‰ãˆã‚‹ã®ã§ã¯ãªãï¼Œã€Œå…¨ã¦ã®é¢¨èˆ¹ã‚’é«˜åº¦$X$ã‚’è¶…ãˆã‚‹å‰ã«å‰²ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã€ã¨ã„ã†åˆ¤å®šå•é¡Œã¨ã—ã¦æ‰ãˆï¼Œå…¨ã¦ã®é¢¨èˆ¹ã‚’å‰²ã‚‹ã“ã¨ãŒã§ãã‚‹é«˜åº¦$X$ã®æœ€å°å€¤ãŒæ±‚ã‚ã‚‹ç­”ãˆã¨ãªã‚‹ï¼\nã€Œ$X$ã‚’å›ºå®šã—ãŸã¨ãï¼Œå…¨ã¦ã®é¢¨èˆ¹ã‚’å‰²ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã€ã¯é«˜åº¦$X$ã«åˆ°é”ã™ã‚‹ã¾ã§ã®çŒ¶äºˆãŒçŸ­ã„é¢¨èˆ¹ã‹ã‚‰å‰²ã‚‹è²ªæ¬²æ³•ã§èª¿ã¹ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\nä¸€æ–¹ã§$X$ã®å€¤ã¯ï¼Œã€Œé«˜åº¦$X$ä»¥ä¸‹ã§ï¼Œå…¨ã¦ã®é¢¨èˆ¹ã‚’å‰²ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã€ã¨ã„ã†æ¡ä»¶ã‚’æº€ãŸã™æœ€å°ã®ã‚‚ã®ã¨ã—ã¦äºŒåˆ†æ¢ç´¢ã«ã‚ˆã£ã¦æ±ºå®šã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ã€Œé«˜åº¦$X$ä»¥ä¸‹ã§ï¼Œå…¨ã¦ã®é¢¨èˆ¹ã‚’å‰²ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã€ã¨ã„ã†æ¡ä»¶ã¯ï¼Œã‚ã‚‹å€¤$H$æœªæº€ã®$X$ã«å¯¾ã—ã¦ã¯å½ã¨ãªã‚Šï¼Œ$H$ä»¥ä¸Šã®$X$ã«å¯¾ã—ã¦çœŸã¨ãªã‚‹å˜èª¿æ€§ãŒã‚ã‚‹ï¼ã€Œé«˜åº¦10cmã¾ã§ã«ãœã‚“ã¶ã®é¢¨èˆ¹ã‚’å‰²ã‚Œã€ã¨è¨€ã‚ã‚Œã¦ã‚‚ç„¡ç†ã ã‘ã©ï¼Œã€Œé«˜åº¦1000kmã¾ã§ã«ãœã‚“ã¶ã®é¢¨èˆ¹ã‚’å‰²ã‚Œã€ã¨è¨€ã‚ã‚Œã¦ã‚‚ä½™è£•ã¨ã„ã†ã“ã¨ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using ll = long long; ll N; ll H[100010], S[100010]; int main() { cin \u0026gt;\u0026gt; N; for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; H[i] \u0026gt;\u0026gt; S[i]; ll ng = 0; ll ok = 1e15; vector\u0026lt;ll\u0026gt; hist(N); // hist[i]: æ™‚åˆ»iã¾ã§ã«å‰²ã‚‰ãªã‘ã‚Œã°ãªã‚‰ãªã„é¢¨èˆ¹ã®å€‹æ•°  while (1 \u0026lt; abs(ok - ng)) { ll mid = (ok + ng) / 2; bool flag = true; // ä»¥ä¸‹ã§bool is_ok(mid){...}ã‚’è¨ˆç®—  for (int i = 0; i \u0026lt; N; i++) hist[i] = 0; for (int i = 0; i \u0026lt; N; i++) { if (mid \u0026lt; H[i]) flag = false; // æ™‚åˆ»0ã§ã™ã§ã«é«˜åº¦midã‚ˆã‚Šä¸Šã«é¢¨èˆ¹ãŒã‚ã‚‹  ll remind_time = (mid - H[i]) / S[i]; // é«˜åº¦midã«åˆ°é”ã™ã‚‹ã¾ã§ã®æ™‚é–“çš„çŒ¶äºˆ  if (remind_time \u0026lt; 0) { flag = false; break; } hist[min(remind_time, N-1)]++; } for (int i = 1; i \u0026lt; N; i++) hist[i] += hist[i-1]; for (int i = 0; i \u0026lt; N; i++) { if (i+1 \u0026lt; hist[i]) flag = false; // æ™‚åˆ»iã¾ã§ã«å‰²ã‚Œã‚‹æœ€å¤§ã®é¢¨èˆ¹ã®å€‹æ•°ã¯i+1å€‹ï¼ˆæ™‚åˆ»0ã®ã¨ãã«1ã¤å‰²ã‚‹ã“ã¨ã«æ³¨æ„ï¼‰  } if (flag) ok = mid; else ng = mid; } cout \u0026lt;\u0026lt; ok \u0026lt;\u0026lt; endl; return 0; } JOI2008 æœ¬é¸3 çŸ¢ã®ã‚ãŸã‚Šæ–¹ã®ç·æ•°ã¯ï¼Œï¼ˆã€ŒçŸ¢ã‚’æŠ•ã’ãªã„ã€ã‚’ã€Œ$0$ç‚¹ã®çš„ã«å½“ãŸã‚‹ã€ã¨è€ƒãˆã¦ï¼Œï¼‰$(N+1)^4$é€šã‚Šã‚ã‚‹ã®ã§ï¼Œãœã‚“ã¶ã‚’èª¿ã¹ä¸Šã’ã‚Œã°åŸç†çš„ã«è§£ã‘ã‚‹ï¼ã—ã‹ã—$N$ã®åˆ¶ç´„ã‹ã‚‰ã“ã‚Œã§ã¯æº€ç‚¹ã¯å–ã‚Œãªã„ï¼ã“ã®è§£æ³•ã®ç„¡é§„ãªã¨ã“ã‚ã¯ï¼Œ4æœ¬å…¨ã¦ã®çŸ¢ã‚’æŠ•ã’ãªã„ã¨å¾—ç‚¹ã‚’è¨ˆç®—ã§ããªã„ã¨ã—ã¦ã„ã‚‹ç‚¹ã§ã‚ã‚‹ï¼ä¾‹ãˆã°ï¼Œ2æœ¬æŠ•ã’ãŸæ™‚ç‚¹ã§ã™ã§ã«å½“ãŸã£ãŸçš„ã®åˆè¨ˆãŒ$M$ã‚’è¶…ãˆã¦ã—ã¾ãˆã°æœ€çµ‚å¾—ç‚¹ã¯ï¼ˆæ®‹ã‚Š2æœ¬ã®çŸ¢ã‚’æŠ•ã’ã‚‹ã¾ã§ã‚‚ãªãï¼‰$0$ã«æ±ºå®šã™ã‚‹ï¼ãã“ã§ï¼ŒçŸ¢ã‚’2æœ¬ã”ã¨ã«æŠ•ã’ã‚‹ã“ã¨ã‚’ä¸€ã¤ã®å˜ä½ã¨ã—ã¦æœ€å¤§å¾—ç‚¹ã‚’èª¿ã¹ä¸Šã’ã‚‹ã“ã¨ã«ã™ã‚‹ï¼å…·ä½“çš„ã«ã¯ï¼Œã¾ãšæœ€åˆã®2æœ¬ã®çŸ¢ã‚’æŠ•ã’ãŸã¨ãã«å¾—ã‚‰ã‚Œã‚‹åˆè¨ˆå¾—ç‚¹$Q_1$ï¼ˆæœ€å¤§ã§$(N+1)^2$é€šã‚Šã®å€¤ï¼‰ã‚’è¨ˆç®—ã—æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã—ã¦ãŠãï¼ç¶šã2æœ¬ã®çŸ¢ã‚’æŠ•ã’ãŸã¨ãã®å¾—ç‚¹$Q_2$ã‚’ï¼Œæ¡ä»¶ã€Œ$Q_1 + Q_2 \\leq M$ã€ã‚’æº€ãŸã™æœ€å¤§ã®å€¤ã¨ã—ã¦äºŒåˆ†æ¢ç´¢ã™ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int N; long long M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;long long\u0026gt; P(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; P[i]; P.push_back(0LL); N += 1; vector\u0026lt;long long\u0026gt; Q; set\u0026lt;long long\u0026gt; tmp; for (int i = 0; i \u0026lt; N+1; i++) { for (int j = i; j \u0026lt; N+1; j++) { tmp.insert(P[i] + P[j]); } } for (auto iter = tmp.begin(); iter != tmp.end(); iter++) Q.push_back(*iter); sort(Q.begin(), Q.end()); long long ans = -1; for (int i = 0; i \u0026lt; (int)Q.size(); i++) { long long total = Q[i]; if (M \u0026lt; total) break; int ok = -1; int ng = (int)Q.size(); while (1 \u0026lt; abs(ok - ng)) { int mid = (ok + ng) / 2; bool is_ok = true; if (M \u0026lt; total + Q[mid]) is_ok = false; if (is_ok) ok = mid; else ng = mid; } total += Q[ok]; ans = max(ans, total); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } æœ€å¾Œã« äºŒåˆ†æ¢ç´¢ï¼šã‚½ãƒ¼ãƒˆæ¸ˆã¿ã®é…åˆ—ã«å¯¾ã—ã¦ï¼Œæ¡ä»¶$X$ã‚’æº€ãŸã™æœ€å°ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã—å½“ã¦ã‚‹\n","date":1586152521,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1586152521,"objectID":"9af09b54f422c3f5f92fef55079928b5","permalink":"/ja/post/binary-search/","publishdate":"2020-04-06T14:55:21+09:00","relpermalink":"/ja/post/binary-search/","section":"post","summary":"äºŒåˆ†æ¢ç´¢ äºŒåˆ†æ¢ç´¢ã¨ã„ã†ã¨ã€Œã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã®ä¸­ã‹ã‚‰ç›®çš„ã®å€¤ã‚’åŠ¹ç‡ã‚ˆãï¼ˆå…·ä½“çš„ã«ã¯$O(\\log n)$ï¼‰ã§æ¢ã—å‡ºã™æ‰‹æ³•ã€ã¨ã—ã¦èª¬æ˜ã•ã‚Œã‚‹ã“ã¨ãŒåœ§","tags":["AtCoder","Competitive Programming","C++","cpp","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°","ç«¶ãƒ—ãƒ­","äºŒåˆ†æ¢ç´¢","ABC"],"title":"äºŒåˆ†æ¢ç´¢","type":"post"},{"authors":[],"categories":[],"content":"å…¨æ¢ç´¢ ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ã€Œã‚­ãƒ›ãƒ³ã€ã®ã€Œã‚­ã€ï¼è«–ç†çš„ã«è€ƒãˆã‚‹ã“ã¨ã«ãªã‚Œã™ãã¦ã‚‹ã¨ï¼Œå½“ãŸã‚Šå‰éãã¦ã€Œãªã‚“ã‹ãšã‚‹ã„ã€ã£ã¦æ€ã†ã‘ã©ï¼Œç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯å½“ãŸã‚Šå‰ã«ä½¿ã†ï¼è¨ˆç®—æ©ŸãŒé«˜é€Ÿã«è¨ˆç®—ã§ãã‚‹ã‚“ã ã‹ã‚‰ï¼Œãã‚Œã‚’ä½¿ã£ã¦å•é¡Œã‚’è§£æ±ºã—ã¦ä½•ãŒæ‚ªã„ã£ã¦ã‹ï¼\nå…¨æ¢ç´¢ã¨ã¯ ã€Œã‚ã‚Šã†ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å…¨éƒ¨èª¿ã¹ä¸Šã’ã‚‹ã€ ã“ã¨ï¼\nç™¾èã¯ä¸€è¦‹ã«ã—ã‹ãšã¨ã„ã†ã“ã¨ã§ä¾‹é¡Œã‚’è¦‹ã¦ã¿ã‚‹ï¼\nä¾‹é¡Œ  ã€å•é¡Œã€‘æ•°å­—ãŒæ›¸ã‹ã‚Œã¦ã„ã‚‹$N$æšã®ç´™åˆ‡ã‚ŒãŒå…¥ã£ãŸè¢‹ãŒã‚ã‚‹ï¼ã“ã®è¢‹ã‹ã‚‰ç´™åˆ‡ã‚Œã‚’å–ã‚Šå‡ºã—ï¼Œãã®ç´™åˆ‡ã‚Œã«æ›¸ã„ã¦ã‚ã‚‹æ•°å­—ã‚’ç¢ºèªã—ã¦è¢‹ã«æˆ»ã™ã“ã¨ã‚’4å›è¡Œã„ï¼Œ4å›ã®æ•°å­—ã®å’ŒãŒ$M$ã«ãªã‚Œã°ã‚ãªãŸã®å‹ã¡ã§ã‚ã‚‹ï¼ç´™åˆ‡ã‚Œã«æ›¸ã‹ã‚Œã¦ã„ã‚‹æ•°å­—ãŒ${K_1, K_2, \u0026hellip;, K_N}$ã§ã‚ã‚‹ã¨ãï¼Œã‚ãªãŸã¯ã“ã®ã‚²ãƒ¼ãƒ ã«å‹ã¤ã“ã¨ãŒã§ãã‚‹ã ã‚ã†ã‹ï¼åˆ¤å®šã›ã‚ˆï¼\nã€åˆ¶ç´„ã€‘$N \\leq 50$ï¼Œ$M \\leq 10^8$ï¼Œ$N \\leq 10^8$\n é›£ã—ã„ã“ã¨ã‚’è€ƒãˆãšã«ï¼Œã€Œ1å›ç›®ã«$K_a$ï¼Œ2å›ç›®ã«$K_b$ï¼Œ2å›ç›®ã«$K_c$ï¼Œ1å›ç›®ã«$K_d$ã‚’å¼•ãã€ã¨ã—ã¦ï¼Œèµ·ã“ã‚Šã†ã‚‹ã™ã¹ã¦ã®æ•°å­—ã®çµ„$(a, b, c, d)$ã‚’å…¨éƒ¨èª¿ã¹ã‚Œã°åˆ¤å®šã§ãã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; k[i]; for (int a = 0; a \u0026lt; n; a++) { for (int b = 0; b \u0026lt; n; b++) { for (int c = 0; c \u0026lt; n; c++) { for (int d = 0; d \u0026lt; n; d++) { if (k[a] + k[b] + k[c] + k[d] == m) { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } } } } cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 4ç¨®é¡ã®å…¨æ¢ç´¢ å…¨æ¢ç´¢ã«ã¯4ç¨®é¡ã‚ã‚‹ï¼\n1ã¤ç›®ã¯ï¼Œç´”ç²‹ã«å…¨é€šã‚Šèª¿ã¹ä¸Šã’ã‚‹å…¨æ¢ç´¢ï¼ã‚ã¡ã‚ƒã‚ã¡ã‚ƒforãƒ«ãƒ¼ãƒ—æ›¸ãã‚¿ã‚¤ãƒ—ï¼åˆ¶ç´„æ¬¡ç¬¬ã§æœ‰åŠ¹ï¼\n2ã¤ç›®ã¯ï¼Œå·¥å¤«ã—ã¦æ¢ç´¢ã®æ•°ã‚’æ¸›ã‚‰ã™å…¨æ¢ç´¢ï¼ã“ã‚Œã‚‚ã‚ã¡ã‚ƒã‚ã¡ã‚ƒforãƒ«ãƒ¼ãƒ—æ›¸ãã‚¿ã‚¤ãƒ—ï¼å•é¡Œã®æ€§è³ªã‚„ã¡ã‚‡ã£ã¨ã—ãŸè€ƒå¯Ÿã‚’åŠ ãˆã‚‹ã“ã¨ã§ï¼Œã‚„ã‚‰ãªãã¦ã„ã„æ¢ç´¢ã‚’ã‚„ã‚‰ãšã«æ¸ˆã¾ã›ã‚‹ï¼ç´”ç²‹ã«å…¨æ¢ç´¢ã™ã‚‹ã®ã§ã¯åˆ¶ç´„çš„ã«é–“ã«åˆã‚ãªã„ã‚ˆã†ãªå•é¡Œã§ã‚‚ç­”ãˆãŒå¾—ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ï¼ã€€3ã¤ç›®ã¯ï¼Œãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ï¼forãƒ«ãƒ¼ãƒ—ã§æ›¸ãã«ãã„å•é¡Œã¯ã“ã‚Œã§è§£ãã“ã¨ãŒã§ãã‚‹ï¼\n4ã¤ç›®ã¯ï¼Œé †åˆ—å…¨æ¢ç´¢ï¼ã“ã‚Œã‚‚forãƒ«ãƒ¼ãƒ—ã§æ›¸ãã«ãã„å•é¡Œã‚’è§£ãã¨ãã«ä½¿ã†ï¼\nç´”ç²‹ãªå…¨æ¢ç´¢ ç´”ç²‹ãªå…¨æ¢ç´¢ã¯ä¸Šã§ä¸Šã’ãŸä¾‹é¡Œã®ã‚ˆã†ã«ï¼Œå¤šé‡ãƒ«ãƒ¼ãƒ—ã§å…¨é€šã‚Šã‚’èª¿ã¹ä¸Šã’ã‚‹ï¼ãƒ«ãƒ¼ãƒ—ãŒãƒã‚¹ãƒˆã—ã¦ã„ãã®ã§å•é¡Œã®åˆ¶ç´„ã«æ³¨æ„ã‚’æ‰•ã†å¿…è¦ãŒã‚ã‚‹ï¼ä¸Šã®ä¾‹é¡Œã ã¨4é‡ã®forãƒ«ãƒ¼ãƒ—ã«ãªã£ã¦ã„ã‚‹ãŒï¼Œå•é¡Œã®åˆ¶ç´„ã¨ã—ã¦$N \\leq 50$ã¨ã‚ã‚‹ã®ã§ï¼Œæœ€å¤§ã§ã‚‚$50^4 = 6.25 \\times 10^6$å›ã®ãƒ«ãƒ¼ãƒ—ãªã®ã§ï¼Œç¾ä»£çš„ãªè¨ˆç®—æ©Ÿã®æ€§èƒ½ã‚’è€ƒæ…®ã™ã‚‹ã¨ä½™è£•ã‚’æŒã£ã¦å•é¡Œã‚’è§£ãã“ã¨ãŒã§ãã‚‹ï¼\nå·¥å¤«ã—ã¦æ¢ç´¢æ•°ã‚’æ¸›ã‚‰ã—ãŸå…¨æ¢ç´¢ å•é¡Œã®æ€§è³ªã‚„ã¡ã‚‡ã£ã¨ã—ãŸè€ƒå¯Ÿã‚’åŠ ãˆã‚‹ã“ã¨ã§ï¼Œã‚„ã‚‰ãªãã¦ã„ã„ãƒ«ãƒ¼ãƒ—ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ã“ã‚Œã«ã‚ˆã£ã¦1ã¤ç›®ã®å…¨æ¢ç´¢ã‚ˆã‚Šã‚‚ã‚µã‚¤ã‚ºã®å¤§ãã„å•é¡Œã‚’è§£ãã“ã¨ãŒã§ãã‚‹ï¼\nä¾‹ãˆã°ï¼Œå…ˆç¨‹ã®ä¾‹é¡Œã ã¨ï¼Œ$(a, b, c)$ãŒæ±ºã¾ã£ã¦ã—ã¾ãˆã°ï¼Œ$X = M - K_a - K_b - K_c$ã¨ã—ã¦ï¼Œ$X$ãŒæ›¸ã‹ã‚ŒãŸç´™åˆ‡ã‚Œã‚’å¼•ãã“ã¨ãŒã§ãã‚‹ã®ã‹ã‚’èª¿ã¹ã‚Œã°å•é¡Œã‚’è§£ãã“ã¨ãŒã§ãã‚‹ï¼ãã®ãŸã‚ã«ã¯äºˆã‚é•·ã•ãŒ$10^8$ã®boolé…åˆ—ã‚’å®šç¾©ã—ã¦ãŠã„ã¦ï¼Œ$1$ä»¥ä¸Š$10^8$ä»¥ä¸‹ã®æ•´æ•°ã«ã¤ã„ã¦ï¼Œç´™åˆ‡ã‚Œã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ã®ã‹ã‚’æœ€åˆã«è¨˜éŒ²ã—ã¦ãŠã‘ã°ï¼ŒO(1)ã§ã€Œ$X$ã‚’å¼•ãã“ã¨ãŒã§ãã‚‹ã‹ã€ã¯åˆ¤å®šã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; k; vector\u0026lt;bool\u0026gt; exist(100000005, false); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; k[i]; exist[k[i]] = true; } for (int a = 0; a \u0026lt; n; a++) { for (int b = 0; b \u0026lt; n; b++) { for (int c = 0; c \u0026lt; n; c++) { int x = m - k[a] - k[b] - k[c]; if (exist[x]) { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } } } cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ ãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ã¨ã¯ï¼Œ$n$å€‹ã®è¦ç´ ã‹ã‚‰ãªã‚‹é›†åˆ${0, 1, 2, \u0026hellip;, n-1}$ã®éƒ¨åˆ†é›†åˆã‚’ã™ã¹ã¦æ•°ãˆä¸Šã’ã‚‹æ‰‹æ³•ã®ã“ã¨ã§ï¼Œ$N$å€‹ã®ã‚‚ã®ã‹ã‚‰ï¼Œã„ãã¤ã‹é¸ã¶æ–¹æ³•ã‚’å…¨åˆ—æŒ™ã—ã¦èª¿ã¹ä¸Šã’ã‚‹æ‰‹æ³•ã§ã‚ã‚‹ï¼\n$N$å€‹ã®ã‚‚ã®ã‹ã‚‰ã„ãã¤ã‹é¸ã¶å ´åˆã®æ•°ã¯ï¼Œãã‚Œãã‚Œã«ã¤ã„ã¦ã€Œé¸ã¶ã€ã€Œé¸ã°ãªã„ã€ã®2é€šã‚ŠãŒã‚ã‚‹ã®ã§ï¼Œãœã‚“ã¶ã§$2^N$é€šã‚Šã‚ã‚‹ï¼ãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ã§ã¯ï¼Œãã‚Œãã‚Œã®ã‚‚ã®ã®é¸ã³æ–¹ã‚’ãƒ“ãƒƒãƒˆåˆ—ã«å¯¾å¿œä»˜ã‘ã‚‹ã“ã¨ã§å…¨é€šã‚Šã‚’èª¿ã¹ä¸Šã’ã‚‹ï¼\nã€Œ$N$å€‹ã®ã‚‚ã®ã‹ã‚‰ã„ãã¤ã‹é¸ã¶ã€ç³»ã®å•é¡Œã¯ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ãŒã‚ã‚‹ï¼\n ã€å•é¡Œã€‘$N$å€‹ã®æ­£æ•´æ•°$a_1, a_2, \u0026hellip; a_{N-1}$ã‹ã‚‰ã„ãã¤ã‹é¸ã‚“ã§ãã®ç·å’Œã‚’$W$ã«ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼\nã€åˆ¶ç´„ã€‘$1 \\leq N \\leq 20$\n ã“ã†ã„ã†å•é¡Œã¯ï¼Œforãƒ«ãƒ¼ãƒ—ã§èª¿ã¹ä¸Šã’ã«ãã„ï¼ãã“ã§ç™»å ´ã™ã‚‹ã®ãŒãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ï¼\nãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ã§ã¯ï¼Œã€Œ$N$å€‹ã®ã‚‚ã®ã‹ã‚‰ã„ãã¤ã‹é¸ã¶æ–¹æ³•ã€ã‚’æ•´æ•°å€¤ã«ä¸€å¯¾ä¸€ã«å¯¾å¿œä»˜ã‘ã‚‹ ï¼ã‚‚ã®ã®é¸ã³æ–¹ã‚’ï¼Œ$i$å€‹ç›®ã®ã‚‚ã®ã‚’é¸ã¶ãªã‚‰$1$ï¼Œé¸ã°ãªã„ãªã‚‰$0$ã¨ã—ã¦2é€²æ•°ã®æ•´æ•°ã«ã—ã¦ã‚ã’ã‚‹ã“ã¨ã§ã“ã®å¯¾å¿œä»˜ã‘ã‚’è¨­ã‘ã‚‹ï¼\nã“ã®å¯¾å¿œä»˜ã‘ã‹ã‚‰ï¼Œ$N$å€‹ã®ã‚‚ã®ã®é¸ã³æ–¹ã®å…¨æ¢ç´¢ã¯\nfor (int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++) { ; } ã¨æ›¸ã‘ã‚‹ï¼ã“ã®ãƒ«ãƒ¼ãƒ—ã‚’å›ã‚‹ã¨ãbitã¯000...000ã‹ã‚‰111...111ã‚’1ã¤ãšã¤å·¡ã£ã¦ã„ãã“ã¨ã«ãªã‚‹ï¼\næ•°å­—ã‹ã‚‰ã€Œã‚‚ã®ã®é¸ã³æ–¹ã€ã‚’å¾©å…ƒã™ã‚‹éš›ã«ã¯ãƒ“ãƒƒãƒˆæ¼”ç®—ã‚’åˆ©ç”¨ã™ã‚‹ï¼bitã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã€Œã‚‚ã®ã®é¸ã³æ–¹ã€ã‚’ã—ãŸã¨ãã«ï¼Œ$i$ç•ªç›®ã®ã‚‚ã®ã¯é¸ã°ã‚Œã¦ã„ã‚‹ã®ã‹ã©ã†ã‹ã¯\nif (bit \u0026amp; (1 \u0026lt;\u0026lt; i)) { ; } ã§åˆ¤å®šã§ãã‚‹ï¼1 \u0026lt;\u0026lt; iã¯ã€Œ1ã‚’iãƒ“ãƒƒãƒˆã ã‘å·¦ã‚·ãƒ•ãƒˆã—ãŸå€¤ã€ãªã®ã§ï¼Œãã‚Œã¨ã®ANDã‚’å–ã‚‹ã“ã¨ã§ï¼Œbitã®$i$ç•ªç›®ã®ãƒ“ãƒƒãƒˆã ã‘ã‚’å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã‚‹ï¼\nã‚‚ã®ã®é¸ã³æ–¹ã‚’è¡¨ã™æ•´æ•°bitã‹ã‚‰ï¼Œãã®ã¨ãã®é¸ã°ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã®ç•ªå·ã‚’è¨˜éŒ²ã—ãŸé…åˆ—ã‚’è¿”ã™é–¢æ•°ã¯æ¬¡ã®ã‚ˆã†ã«æ›¸ã‘ã‚‹ï¼\nvector\u0026lt;int\u0026gt; Bit2Vec(int bit, int N) { vector\u0026lt;int\u0026gt; items; for (int i = 0; i \u0026lt; N; i++) { if (bit \u0026amp; (1 \u0026lt;\u0026lt; i)) { items.push_back(i); } } return items; } ã—ã‹ã—å®Ÿéš›ã«ã¯ï¼Œä¸Šã®ã‚ˆã†ã«ã€Œã‚‚ã®ã®é¸ã³æ–¹ã€ã‚’è¡¨ã™é…åˆ—ã‚’ç”¨æ„ã™ã‚‹ã“ã¨ãªãï¼Œå„ã‚¢ã‚¤ãƒ†ãƒ ç•ªå·i = 0, 1, ...ã«å¯¾ã—ã¦ï¼Œã‚¢ã‚¤ãƒ†ãƒ iãŒbitã§è¡¨ç¾ã•ã‚Œã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã®é›†åˆã«å«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã£ãŸã‚‰ï¼Œãã‚Œã«å¿œã˜ãŸå‡¦ç†ã‚’ãã®å ´ã§è¡Œã£ã¦ã—ã¾ã†ã‚ˆã†ãªå®Ÿè£…ã‚’ã—ã¦ã„ã‚‹äººãŒå¤šã„ï¼\nã¾ãŸï¼Œ$i$ãƒ“ãƒƒãƒˆç›®ã‚’å–ã‚Šå‡ºã™æ¼”ç®—ã¯ï¼Œ\nif ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) { ; } ã¨ã‚‚æ›¸ã‘ã¦ï¼Œã“ã£ã¡ã®ã»ã†ãŒå®‰å…¨ã ã£ãŸã‚Šã™ã‚‹ã“ã¨ãŒã‚ã‚‹ã‚ˆã†ãªã“ã¨ã‚’èã„ãŸã“ã¨ãŒã‚ã‚‹ï¼ˆè¦å‡ºå…¸ï¼‰ï¼\nãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ã®ä¾‹  ã€å•é¡Œã€‘$N$å€‹ã®æ­£æ•´æ•°$a_1, a_2, \u0026hellip; a_{N-1}$ã¨æ­£æ•´æ•°$W$ãŒä¸ãˆã‚‰ã‚Œã‚‹ï¼$a_1, a_2, \u0026hellip; a_{N-1}$ã‹ã‚‰ã„ãã¤ã‹é¸ã‚“ã§ãã®ç·å’Œã‚’$W$ã«ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚’åˆ¤å®šã›ã‚ˆï¼\nã€åˆ¶ç´„ã€‘$1 \\leq N \\leq 20$\n ã“ã®å•é¡Œã¯ï¼Œ ã€Œ$N$å€‹ã®æ­£æ•´æ•°ã‹ã‚‰ã„ãã¤ã‹é¸ã¶æ–¹æ³•ã¯$2^N$é€šã‚Šã‚ã‚Šï¼Œãã‚Œã‚’1ã¤ã¥ã¤è©¦ã—ãªãŒã‚‰ï¼Œç·å’ŒãŒ$W$ã«ãªã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹ã€ ã“ã¨ã§è§£ãã“ã¨ãŒã§ãã‚‹ï¼æ­£æ•´æ•°ã®é¸ã³æ–¹ãã‚Œãã‚Œã«å¯¾ã—ã¦ï¼Œ$O(N)$ã‹ã‘ã¦ç·å’Œã‚’å–ã‚‹ã“ã¨ã«ãªã‚‹ã®ã§ï¼Œå…¨ä½“ã®è¨ˆç®—é‡ã¯$O(2^N \\times N)$ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; vector\u0026lt;int\u0026gt; Bit2Vec(int bit, int N) { vector\u0026lt;int\u0026gt; items; for (int i = 0; i \u0026lt; N; i++) { if ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) { items.push_back(i); } } return items; } int main() { int N, W; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; vector\u0026lt;int\u0026gt; a(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; a[i]; for (int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); i++) { vector\u0026lt;int\u0026gt; items = Bit2Vec(bit, N); int sum = 0; for (int i : items) sum += a[i]; if (sum == W) { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ä¸Šã®å®Ÿè£…ã§ã‚‚æ­£ã—ã„ãŒï¼Œbitã«å¯¾å¿œã™ã‚‹ã‚‚ã®ã®é¸ã³æ–¹ã«ãŠã„ã¦ï¼Œã‚¢ã‚¤ãƒ†ãƒ iãŒé¸ã°ã‚Œã‚‹ã®ã‹ã®åˆ¤å®šã¨ï¼Œé¸ã°ã‚Œã‚‹ãªã‚‰ãã®éš›ã®å‡¦ç†ï¼ˆã“ã“ã§ã¯ç·å’Œã®è¨ˆç®—ã«ç”¨ã„ã‚‹ï¼‰ã‚’ãã®å ´ã§ã‚„ã£ã¦ã—ã¾ã†ã‚ˆã†ãªå®Ÿè£…ã«ã™ã‚‹ã“ã¨ã‚‚ã§ãã¦ï¼Œãã†ã™ã‚‹ã“ã¨ã§Bit2Vecé–¢æ•°ã‚’æ›¸ã‹ãªãã¦æ¸ˆã‚€ã‚ˆã†ã«ãªã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int N, W; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; vector\u0026lt;int\u0026gt; a(N); for (int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; a[i]; for (int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); i++) { int sum = 0; for (int i = 0; i \u0026lt; N; i++) { if ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) { sum += a[i]; } } if (sum == W) { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } é †åˆ—å…¨æ¢ç´¢ é †åˆ—å…¨æ¢ç´¢ã¯ï¼Œé †åºä»˜ãã®ã‚‚ã®ã®é¸ã³æ–¹ã¨ã—ã¦è€ƒãˆã‚‰ã‚Œã‚‹ã‚‚ã®ã‚’å…¨ã¦èª¿ã¹ä¸Šã’ã‚‹å…¨æ¢ç´¢ï¼ä¾‹ãˆã°ã€Œ$N$å€‹ã®éƒ½å¸‚ã‚’ï¼Œå¥½ããªéƒ½å¸‚ã‹ã‚‰å‡ºç™ºã—ã¦ï¼Œå…¨ã¦ã®éƒ½å¸‚ã‚’ã¡ã‚‡ã†ã©1å›ãšã¤è¨ªã‚Œã‚‹æ–¹æ³•ã®ã†ã¡ï¼Œæœ€çŸ­ã®æ‰€è¦æ™‚é–“ã‚’æ±‚ã‚ã‚‹ã€ã¨ã„ã†å·¡å›ã‚»ãƒ¼ãƒ«ã‚¹ãƒãƒ³å•é¡Œã‚’è€ƒãˆã‚‹ã¨ãï¼Œéƒ½å¸‚ã®ã‚ãã‚Šæ–¹ã®ç·æ•°ã¯$N!$é€šã‚Šãªã®ã§ï¼Œãã®å…¨ã¦ã‚’è©¦ã›ã°åŸç†çš„ã«è§£ã‘ã‚‹ï¼\nC++ã§ã¯std::next_permutation()ã¨ã„ã†ä¾¿åˆ©é–¢æ•°ãŒã‚ã‚Šï¼Œé †åˆ—å…¨æ¢ç´¢ã‚’ã‹ã‚“ãŸã‚“ã«æ›¸ãã“ã¨ãŒã§ãã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int INF = 100000000; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n, vector\u0026lt;int\u0026gt;(n)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { cin \u0026gt;\u0026gt; g[i][j]; } } vector\u0026lt;int\u0026gt; order(n); for (int i =0 ; i \u0026lt; n; i++) order[i] = i; // éƒ½å¸‚ç•ªå·é †ã«è¨ªã‚Œã‚‹æ–¹æ³•ã§åˆæœŸåŒ–  int res = INF; // é †åˆ—å…¨æ¢ç´¢ã®å…¸å‹çš„ãªæ›¸ãæ–¹  do { int tmp = 0; for (int i = 1; i \u0026lt; n; i++) { tmp += g[order[i-1]][order[i]]; } if (tmp \u0026lt; res) { res = tmp; } } while (next_permutation(order.begin(), order.end())); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; end; return 0; } do {...} while (next_permutation(...));ã§$n!$å›ãƒ«ãƒ¼ãƒ—ã—ã¦ï¼Œãã‚Œãã‚Œã«ã¤ã„ã¦ï¼Œ$O(n)$ã‹ã‘ã¦ã‚³ã‚¹ãƒˆã®ç·å’Œã‚’å–ã‚‹ã®ã§å…¨ä½“ã¨ã—ã¦ã¯$O(n! \\times n)$\nå…¨æ¢ç´¢ã®ç·´ç¿’å•é¡Œ å˜ç´”ãªå…¨æ¢ç´¢ãƒ»ã¡ã‚‡ã£ã¨å·¥å¤«ã™ã‚‹å…¨æ¢ç´¢  ITP 1-7 B ABC 144 B ABC 150 B ABC 122 B ABC 136 B ABC 106 B ABC 120 B ABC 57 C ABC 95 C ä½éŠ€2019 D ãƒ‘ç ”æ¯2019 C JOI2017 æœ¬é¸3 Square869120Contest #6 B JOI2008 äºˆé¸4  ãƒ“ãƒƒãƒˆå…¨æ¢ç´¢  ABC 128 C ABC 147 C ABC 2 D JOI2008 äºˆé¸5 Square869120Contest #4 B  é †åˆ—å…¨æ¢ç´¢  ABC 145 C ABC 150 C ABC 54 C ALDS 1-13 A  è§£èª¬ å˜ç´”ãªå…¨æ¢ç´¢ãƒ»ã¡ã‚‡ã£ã¨å·¥å¤«ã™ã‚‹å…¨æ¢ç´¢ ITP 1-7 B ã€Œ$1$ã‹ã‚‰$n$ã¾ã§ã®æ•´æ•°ã®ä¸­ã‹ã‚‰ï¼Œé‡è¤‡ç„¡ã—ã§3ã¤ã®æ•°ã‚’é¸ã¶ã€ã¨ãã®æ•°ã®é¸ã³æ–¹ã¯${}_n\\mathrm{P}_3$é€šã‚Šã‚ã‚Šï¼Œå…¨é€šã‚Šè©¦ã—ã¦ã¿ã‚Œã°åŸç†çš„ã«è§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n, x; while (cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x) { int cnt = 0; if (n == 0 \u0026amp;\u0026amp; x == 0) break; for (int i = 1; i \u0026lt;= n-2; i++) { for (int j = i+1; j \u0026lt;= n-1; j++) { for (int k = j+1; k \u0026lt;= n; k++) { if (i + j + k == x) cnt++; } } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } ABC 144 B ä¸ãˆã‚‰ã‚ŒãŸæ•´æ•°$N$ãŒ$1$ä»¥ä¸Š$9$ä»¥ä¸‹ã®2æ•´æ•°ã®ç©ã¨ç­‰ã—ã„ã‹ã‚’ï¼Œ$1$ä»¥ä¸Š$9$ä»¥ä¸‹ã®2æ•´æ•°ã®ç©ã‚’ãœã‚“ã¶è©¦ã—ãªãŒã‚‰èª¿ã¹ã‚‹ã“ã¨ã§åŸç†çš„ã«è§£ã‘ã‚‹ï¼åˆ¶ç´„ã‚’è€ƒæ…®ã—ã¦ã‚‚ï¼Œç‰¹ã«å·¥å¤«ã™ã‚‹ã“ã¨ãªãè§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= 9; i++) { for (int j = 1; j \u0026lt;= 9; j++) { if (i * j == n) { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } } cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ABC 150 B å…¥åŠ›æ–‡å­—åˆ—Sã®$i$æ–‡å­—ç›®ã‹ã‚‰$i+3$æ–‡å­—ç›®ã¾ã§ãŒABCã¨ä¸€è‡´ã™ã‚‹ã‹ã‚’å…¨ã¦ã®$i$ã«å¯¾ã—ã¦èª¿ã¹ã‚‹ï¼å…¥åŠ›æ–‡å­—åˆ—ã®å¤§ãã•ãŒãã“ã¾ã§å¤§ãããªã„ã®ã§ç‰¹ã«å·¥å¤«ã›ãšè§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; int ans = 0; for (int i = 0; i \u0026lt;= n-3; i++) { if (s[i] == \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s[i+1] == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; s[i+2] == \u0026#39;C\u0026#39;) { ans++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ABC 122 B å…¥åŠ›æ–‡å­—åˆ—ã‚’å…ˆé ­ã‹ã‚‰ä¸€æ–‡å­—ã¥ã¤èˆã‚ã¦ã„ã£ã¦ï¼Œãã®æ–‡å­—ãŒA/C/G/Tãªã‚‰æ–‡å­—åˆ—ã®é•·ã•ã«1ã‚’åŠ ãˆã¦ï¼Œãã†ã§ãªã„ãªã‚‰ãã“ã§ä¸€æ—¦ãƒªã‚»ãƒƒãƒˆï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { string s; cin \u0026gt;\u0026gt; s; int len = 0; int ans = 0; for (int i = 0; i \u0026lt; s.size(); i++) { if (s[i] == \u0026#39;A\u0026#39; || s[i] == \u0026#39;C\u0026#39; || s[i] == \u0026#39;G\u0026#39; || s[i] == \u0026#39;T\u0026#39;) { len += 1; ans = max(ans, len); } else { len = 0; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ABC 136 B $N$ä»¥ä¸‹ã®æ­£æ•´æ•°ã«å¯¾ã—ã¦ï¼Œæ¡æ•°ãŒå¥‡æ•°ã«ãªã‚‹ã®ã‹ã‚’èª¿ã¹ã¦ã‚„ã‚‹ã ã‘ï¼æ•´æ•°ã‚’æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹é–¢æ•°ã¯å¤§ä½“ã®è¨€èªã§ã‚‚ã§ãã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { string ns; cin \u0026gt;\u0026gt; ns; int n = stoi(ns); int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { string s = to_string(i); if (s.size() % 2 == 1) ans++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ABC 106 B $N$ä»¥ä¸‹ã®å„æ­£å¥‡æ•°ã«å¯¾ã—ã¦ï¼Œæ­£ã®ç´„æ•°ãŒ8å€‹ã§ã‚ã‚‹ã‹ã‚’èª¿ã¹ã¦ã‚ã’ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; bool check(int n) { int cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { if (n%i == 0) cnt++; } if (cnt == 8) return true; else return false; } int main() { int n; cin \u0026gt;\u0026gt; n; int ans = 0; for (int i = 1; i \u0026lt;= n; i += 2) { if (check(i)) ans++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ABC 120 B ä¸ãˆã‚‰ã‚ŒãŸ2æ•´æ•°$A$ï¼Œ$B$ã®ç´„æ•°ã‚’ãœã‚“ã¶èª¿ã¹ä¸Šã’ã‚Œã°è‰¯ã„ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int a, b, k; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k; if (b \u0026lt; a) swap(a, b); int cnt = 0; for (int i = a; 1 \u0026lt;= i; i--) { if (a%i == 0 \u0026amp;\u0026amp; b%i == 0) { cnt++; if (cnt == k) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } } } return 0; } ABC 57 C $A \u0026lt; B$ã¨ã—ã¦ã‚‚ä¸€èˆ¬æ€§ã¯å¤±ã‚ã‚Œãªã„ã®ã§ï¼Œ$1 \\leq A \\leq \\sqrt N$ã¾ã§èª¿ã¹ã‚Œã°ã„ã„ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using ll = long long; int main() { ll N; cin \u0026gt;\u0026gt; N; ll digit = 1; for (ll i = 2; i \u0026lt;= sqrt(N); i++) { if (N%i == 0) { digit = i; } } cout \u0026lt;\u0026lt; to_string(N/digit).length() \u0026lt;\u0026lt; endl; return 0; } ABC 95 C ABãƒ”ã‚¶ã‚’å¥‡æ•°æšè²·ã£ã¦ä¸€æšä½™ã‚‰ã›ã‚‹ã“ã¨ã—ã¦ã‚‚ãŸã ã®ç„¡é§„ã§ã—ã‹ãªã„ã®ã§ï¼ŒABãƒ”ã‚¶ã¯2æš1çµ„ã®ABã‚»ãƒƒãƒˆã¨ã—ã¦è€ƒãˆã‚‹ï¼ã“ã“ã§å•é¡Œã®åˆ¶ç´„ã‹ã‚‰ï¼ŒAãƒ”ã‚¶ã§ã‚‚Bãƒ”ã‚¶ã§ã‚‚ABã‚»ãƒƒãƒˆã§ã‚‚ï¼Œè²·ã†å€‹æ•°ã‚’$0$ã‹ã‚‰$10^5$ã¾ã§ãœã‚“ã¶è©¦ã›ã°ï¼Œè²·ã„æ–¹ã®å ´åˆã®æ•°ã¯å…¨ã¦ç¶²ç¾…ã™ã‚‹ã®ã§åŸç†çš„ã«è§£ã‘ã‚‹ã“ã¨ã«ãªã‚‹ï¼\nã¨ã„ã†ã‹ï¼Œãœã‚“ã¶ABã‚»ãƒƒãƒˆã§è²·ã£ã¦ä½™ã‚‰ã›ã‚‹ã‹ï¼ŒAãƒ”ã‚¶ or Bãƒ”ã‚¶ãŒè¶³ã‚Šã‚‹åˆ†ã¾ã§ABã‚»ãƒƒãƒˆã§è²·ã£ã¦ä¸è¶³åˆ†ã‚’å˜å“ã§è²·ã„è¶³ã™ã‹ï¼ŒABã‚»ãƒƒãƒˆã‚’ä½¿ã‚ãšã«å˜å“ã§è²·ã„æƒãˆã‚‹ã‹ï¼Œã®ã„ãšã‚Œã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§æœ€ã‚‚å®‰ä¸ŠãŒã‚Šã®ã‚‚ã®ã‚’èª¿ã¹ã‚Œã°è‰¯ã„ã®ã§ï¼Œæ¢ç´¢ã¯ã„ã‚‰ãªã„ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int a, b, c, x, y; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int res = a * x + b * y; res = min(res, (c * 2) * max(x, y)); res = min(res, min(x, y) * 2 * c + a * (x - min(x, y)) + b * (y - min(x, y))); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } ä½éŠ€2019 D ã¾ã˜ã‚ã«ï¼Œå…¥åŠ›ã•ã‚ŒãŸãƒ©ãƒƒã‚­ãƒ¼ãƒŠãƒ³ãƒãƒ¼ã‹ã‚‰3æ¡å–ã£ã¦ãã¦\u0026hellip;ã¨ã‚„ã‚‹ã¨ï¼Œãƒ©ãƒƒã‚­ãƒ¼ãƒŠãƒ³ãƒãƒ¼ã®æ¡æ•°ãŒæœ€å¤§30000ã‚‚ã‚ã‚‹ã®ã§åˆ¶é™æ™‚é–“å†…ã«çµ‚ã‚ã‚‰ãªã„ï¼ã“ã“ã§ï¼Œ3æ¡ã®æš—è¨¼ç•ªå·ã¯000ã‹ã‚‰999ã®ã©ã‚Œã‹ã«ã—ã‹ãªã‚‰ãªã„ã®ã§ï¼Œæš—è¨¼ç•ªå·ã‚’æ±ºã‚æ‰“ã¡ã—ã¦ã‹ã‚‰ï¼Œãã®æš—è¨¼ç•ªå·ã‚’ä¸ãˆã‚‰ã‚ŒãŸãƒ©ãƒƒã‚­ãƒ¼ãƒŠãƒ³ãƒãƒ¼ã‹ã‚‰ä½œã‚Œã‚‹ã‹ã‚’èª¿ã¹ãŸã»ã†ãŒè‰¯ã„ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int N, cnt = 0; string S; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; for (int i = 0; i \u0026lt; 1000; i++) { vector\u0026lt;int\u0026gt; c = {i/100, (i/10)%10, i%10}; int f = 0; for (int j = 0; j \u0026lt; N; j++) { if (S.at(j) == (\u0026#39;0\u0026#39; + c.at(f))) { f++; } if (f == 3) { break; } } if (f == 3) { cnt++; } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } ãƒ‘ç ”æ¯2019 C ã‚³ãƒ³ãƒ†ã‚¹ãƒˆã§å®Ÿéš›ã«æ­Œã†æ­Œã®çµ„ã¿åˆã‚ã›ã¯ãœã‚“ã¶ã§${}_M\\mathrm{C}_2$é€šã‚Šã‚ã‚Šï¼Œ$2 \\leq M \\leq 100$ã¨ã„ã†åˆ¶ç´„ã‚’è€ƒæ…®ã—ã¦ï¼Œå…¨é€šã‚Šè©¦ã›ã°åŸç†çš„ã«è§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; a(n+1, vector\u0026lt;long long\u0026gt;(m+1, -1)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; } } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; done(m+1, vector\u0026lt;bool\u0026gt;(m+1, false)); long long ans = -1; for (int i = 1; i \u0026lt;= m-1; i++) { for (int j = i+1; j \u0026lt;= m; j++) { if (done[j][i]) continue; done[i][j] = done[j][i] = true; long long s = 0; for (int k = 1; k \u0026lt;= n; k++) { s += max(a[k][i], a[k][j]); } ans = max(ans, s); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } JOI2017 æœ¬é¸3 å…¥åŠ›ã•ã‚ŒãŸ$n$å€‹ã®ç‚¹ã‹ã‚‰$2$ç‚¹é¸ã³ï¼Œãã®$2$ç‚¹ã‚’çµã¶ç·šåˆ†ã‚’1è¾ºã¨ã™ã‚‹æ­£æ–¹å½¢ã‚’æ§‹æˆã™ã‚‹ä»–ã®2ç‚¹ã‚’è¨ˆç®—ã—ï¼Œãã®é ‚ç‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’èª¿ã¹ã‚Œã°æ­£æ–¹å½¢ã‚’æ§‹æˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹ã“ã¨ãŒã§ãï¼Œ$n$ã®å¤§ãã•ã«å¯¾ã™ã‚‹åˆ¶ç´„ã‚’è€ƒãˆã‚‹ã¨ï¼Œå…¨éƒ¨è©¦ã—ã¦ã‚‚é–“ã«åˆã†ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; points; for (int i = 0; i \u0026lt; n; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; points.insert(pair\u0026lt;int, int\u0026gt;(x, y)); } long long sum, ans = 0; for (auto c: points) { for (auto v: points) { if (c == v) continue; int dx = v.first - c.first; int dy = v.second - c.second; int nx1 = v.first - dy; int ny1 = v.second + dx; int nx2 = c.first - dy; int ny2 = c.second + dx; if (points.count(pair\u0026lt;int, int\u0026gt;(nx1, ny1)) \u0026amp;\u0026amp; points.count(pair\u0026lt;int, int\u0026gt;(nx2, ny2))) { sum = dy * dy + dx * dx; ans = max(ans ,sum); } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } Square869120Contest #6 B å‡ºå…¥ã‚Šå£ã‚’ï¼Œã‚ã–ã‚ã–è²·ã„ç‰©ã—ãªã„åº—ã«è¨­ã‘ã‚‹ã®ã¯ç„¡é§„ã§ã—ã‹ãªã„ã®ã§ï¼Œå‡ºå…¥ã‚Šå£ã®å€™è£œã¯$a_1, a_2, \u0026hellip;, a_N$ï¼Œ$b_1, b_2, \u0026hellip;, b_N$ï¼å‡ºå…¥ã‚Šå£ã®å€™è£œã¯$O(n^2)$é€šã‚Šã‚ã‚Šï¼Œè²·ã„ç‰©å®¢ãã‚Œãã‚Œã«å¯¾ã—ã¦ç§»å‹•æ™‚é–“ã‚’$O(n)$ã§è¨ˆç®—ã—ï¼Œãã®åˆè¨ˆã‚’èª¿ã¹ä¸Šã’ã‚Œã°åŸç†çš„ã«è§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using ll = long long; int main() { int n;cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n), b(n); set\u0026lt;ll\u0026gt; ab; for (int i = 0; i \u0026lt; n; i++) { ll _a, _b; cin \u0026gt;\u0026gt; _a \u0026gt;\u0026gt; _b; ab.insert(_a); ab.insert(_b); a[i] = _a; b[i] = _b; } ll s, t; ll ans = 9223372036854775807; for (auto s : ab) { for (auto t : ab) { ll elapsed = 0; for (int k = 0; k \u0026lt; n; k++) { elapsed += abs(s - a[k]) + abs(a[k] - b[k]) + abs(t - b[k]); } ans = min(ans, elapsed); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } JOI2008 äºˆé¸4 $n$å€‹ã®ä¸ãˆã‚‰ã‚ŒãŸæ˜Ÿã®ä½ç½®ã‹ã‚‰1ã¤ãšã¤å–ã‚Šå‡ºã—ã¦ï¼Œãã‚Œã‚’æ˜Ÿåº§ã‚’æ§‹æˆã™ã‚‹$m$å€‹ã®æ˜Ÿã®ä½ç½®ã®1ã¤ã¨ä»®å®šã—ã¦ï¼Œæ˜Ÿåº§ã‚’æ§‹æˆã™ã‚‹æ˜Ÿã‚’ç§»å‹•ã—ï¼Œç§»å‹•ã—ãŸå…ˆã®ä½ç½®ãŒæ˜Ÿã®ä½ç½®ã¨ã—ã¦å¦¥å½“ã‹ã©ã†ã‹ã‚’å…¨ã¦ã®å ´åˆã«ã¤ã„ã¦èª¿ã¹ä¸Šã’ã‚Œã°åŸç†çš„ã«è§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int m; cin \u0026gt;\u0026gt; m; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sign; for (int i = 0; i \u0026lt; m; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; sign.insert(pair\u0026lt;int, int\u0026gt;(x, y)); } int n; cin \u0026gt;\u0026gt; n; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; night_sky; for (int i = 0; i \u0026lt; n; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; night_sky.insert(pair\u0026lt;int, int\u0026gt;(x, y)); } for (auto star: night_sky) { pair\u0026lt;int, int\u0026gt; ss = *begin(sign); int dx = star.first - ss.first; int dy = star.second - ss.second; bool flag = true; for (auto sstar: sign) { int nx = sstar.first + dx; int ny = sstar.second + dy; if (!(night_sky.count(pair\u0026lt;int, int\u0026gt;(nx, ny)))) flag = false; } if (flag) { cout \u0026lt;\u0026lt; dx \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; dy \u0026lt;\u0026lt; endl; return 0; } } return 0; } ãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ ABC 128 C $N$å€‹ã®ã‚¹ã‚¤ãƒƒãƒã®çŠ¶æ…‹ã¯ãœã‚“ã¶ã§$2^N$é€šã‚Šã§ï¼Œãã‚Œã‚’å…¨éƒ¨è©¦ã—ã¦ï¼Œ$M$å€‹ã‚ã‚‹é›»çƒãŒå…¨éƒ¨ç‚¹ç¯ã™ã‚‹ã‹ã‚’èª¿ã¹ã‚Œã°åŸç†çš„ã«ã¯è§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec(M); for (int i = 0; i \u0026lt; M; i++) { int k; cin \u0026gt;\u0026gt; k; vec[i].resize(k); for (int j = 0; j \u0026lt; k; j++) { cin \u0026gt;\u0026gt; vec[i][j]; vec[i][j] -= 1; } } vector\u0026lt;int\u0026gt; p(M); for (int i = 0; i \u0026lt; M; i++) { cin \u0026gt;\u0026gt; p[i]; } int ans = 0; for (int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++) { bool ok = true; for (int j = 0; j \u0026lt; M; j++) { int c = 0; // é›»çƒjã«ã¤ãªãŒã£ã¦ã„ã¦ï¼Œã‹ã¤onã«ãªã£ã¦ã„ã‚‹ã‚¹ã‚¤ãƒƒãƒã®å€‹æ•°  for (auto id : vec[j]) { if ((bit \u0026gt;\u0026gt; id) \u0026amp; 1) { c++; } } c %= 2; if (c != p[j]) { ok = false; } } if (ok) ans++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ABC 147 C ã€Œã ã‚ŒãŒæ­£ç›´è€…ã§ï¼Œã ã‚ŒãŒä¸è¦ªåˆ‡ãªã®ã‹ã€ã‚’å…ˆã«æ±ºã‚æ‰“ã¡ã—ã¦ã—ã¾ã„ï¼Œãã‚Œã«å¯¾ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸæƒ…å ±ãŒçŸ›ç›¾ã—ãªã„ã‹ã‚’è€ƒãˆã¦ã‚„ã‚‹ã“ã¨ã§è§£ãã“ã¨ãŒã§ãã‚‹ï¼æ•°å­¦ãƒ‘ã‚ºãƒ«ãŒå¥½ããªäººã«ã¯ã€Œãã‚Œã¯ãšã‚‹ã„ã€ã£ã¦è¨€ã‚ã‚Œã‚‹æ°—ãŒã™ã‚‹ãŒã¾ã‚ã„ã„ã‚„ï¼ã€Œã ã‚ŒãŒæ­£ç›´è€…ã§ï¼Œã ã‚ŒãŒä¸è¦ªåˆ‡ãªã®ã‹ã€ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ãœã‚“ã¶ã§$2^N$é€šã‚Šã§ï¼Œãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ãŒä½¿ãˆã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using testimony = pair\u0026lt;int, int\u0026gt;; // first: äºº, second: æ­£ç›´è€…ã‹ä¸è¦ªåˆ‡ã‹  int N; vector\u0026lt;vector\u0026lt;testimony\u0026gt;\u0026gt; testimonies; bool check(int bit) { // Näººãã‚Œãã‚Œã«ã¤ã„ã¦  for (int i = 0; i \u0026lt; N; i++) { // ãã®äººãŒã€Œä¸è¦ªåˆ‡ãªäººã€ãªã‚‰ãã®äººã®è¨¼è¨€ã¯èª¿ã¹ãªãã¦è‰¯ã„  if (!((bit \u0026gt;\u0026gt; i) \u0026amp; 1)) continue; // å„è¨¼è¨€ã®æ•´åˆæ€§ã‚’å–ã‚‹  for (auto test : testimonies[i]) { int x = test.first; int y = test.second; if (y == 0 \u0026amp;\u0026amp; ((bit \u0026gt;\u0026gt; x) \u0026amp; 1)) return false; if (y == 1 \u0026amp;\u0026amp; !((bit \u0026gt;\u0026gt; x) \u0026amp; 1)) return false; } } return true; } int main() { cin \u0026gt;\u0026gt; N; testimonies.resize(N); for (int i = 0; i \u0026lt; N; i++) { int A; cin \u0026gt;\u0026gt; A; testimonies[i].resize(A); for (int j = 0; j \u0026lt; A; j++) { cin \u0026gt;\u0026gt; testimonies[i][j].first \u0026gt;\u0026gt; testimonies[i][j].second; testimonies[i][j].first -= 1; } } int res = 0; // å…¨é€šã‚Šã‚’èª¿ã¹ä¸Šã’ã‚‹  for (int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++) { // æ±ºã‚æ‰“ã¡ã—ãŸã€Œæ­£ç›´è€…-ä¸è¦ªåˆ‡ãªäººåˆ†å¸ƒã€ä¸ãˆã‚‰ã‚ŒãŸè¨¼è¨€ã¨æ•´åˆæ€§ãŒã‚ã‚‹ã‹  if (check(bit)) { int cnt = 0; // æ­£ç›´è€…ã‚’ã‚«ã‚¦ãƒ³ãƒˆ  for (int i = 0; i \u0026lt; N; i++) { if ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) { cnt++; } } res = max(res, cnt); } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } ABC 2 D $N$äººã„ã‚‹å›½ä¼šè­°å“¡ã«ã¤ã„ã¦ï¼Œæœ€å¤§æ´¾é–¥ã«æ‰€å±ã™ã‚‹ã‹å¦ã‹ã®å ´åˆã®æ•°ã®ç·æ•°ã¯$2^N$é€šã‚Šã§ã‚ã‚Šï¼Œ$1 \\leq N \\leq 12$ã¨ã„ã†$N$ã®åˆ¶ç´„ã‚’è€ƒãˆã‚‹ã¨å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’èª¿ã¹ä¸Šã’ã‚‹ã“ã¨ã§åŸç†çš„ã«è§£ã‘ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; friends(n, vector\u0026lt;bool\u0026gt;(n, false)); for (int i = 0; i \u0026lt; m; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--; y--; friends[x][y] = friends[y][x] = true; } int ans = 0; for (int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; n); bit++) { bool flag = true; for (int i = 0; i \u0026lt; n; i++) { if ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) { for (int j = 0; j \u0026lt; i; j++) { if ((bit \u0026gt;\u0026gt; j) \u0026amp; 1) { if (!friends[i][j]) flag = false; } } } } if (flag) ans = max(ans, __builtin_popcount(bit)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } JOI2008 äºˆé¸5 è¡Œã®ã²ã£ãã‚Šè¿”ã—æ–¹ã‚’å›ºå®šã—ãŸã¨ãï¼Œã‚ã‚‹åˆ—ã‚’ã²ã£ãã‚Šè¿”ã™ã‹å¦ã‹ã¯ä»–ã®åˆ—ã‚’ã²ã£ãã‚Šè¿”ã™ã‹å¦ã‹ã®åˆ¤æ–­ã«å½±éŸ¿ã‚’ä¸ãˆãªã„ï¼ã‚ˆã£ã¦ï¼Œå„åˆ—ã«ãŠã„ã¦å‡ºè·å¯èƒ½ãªã›ã‚“ã¹ã„ã®æšæ•°ã‚’æœ€å¤§åŒ–ã™ã‚‹ã—ãŸã¨ãï¼Œå…¨ä½“ã¨ã—ã¦å‡ºè·ã§ãã‚‹ã›ã‚“ã¹ã„ã®æšæ•°ã‚’ï¼ˆãã®è¡Œã®ã²ã£ãã‚Šè¿”ã—æ–¹ã«ãŠã„ã¦ï¼‰æœ€å¤§åŒ–ã§ãã‚‹ã¨ã„ãˆã‚‹ï¼å„åˆ—ã®ã²ã£ãã‚Šè¿”ã™ã‹ä¸­ã®åˆ¤æ–­ã¯ï¼Œã€Œåˆ—ã‚’ä¸Šã‹ã‚‰èˆã‚ã¦ã„ãï¼Œè¡¨ã«ãªã£ã¦ã„ã‚‹ã›ã‚“ã¹ã„ã®æšæ•°ã®ã»ã†ãŒè£ã«ãªã£ã¦ã„ã‚‹ã›ã‚“ã¹ã„ã‚ˆã‚Šå¤šã‘ã‚Œã°ã²ã£ãã‚Šè¿”ã™ï¼ãã†ã§ãªã‘ã‚Œã°ã²ã£ãã‚Šè¿”ã•ãªã„ã€ã¨ã™ã‚Œã°ãã®åˆ—ã§ç„¼ã„ã¦ã„ã‚‹ã›ã‚“ã¹ã„ã®ã†ã¡ï¼Œå‡ºè·å¯èƒ½ãªã›ã‚“ã¹ã„ã®æšæ•°ã‚’æœ€å¤§ã«ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\nã¾ã¨ã‚ã‚‹ã¨ï¼Œè¡Œã®ã²ã£ãã‚Šè¿”ã—æ–¹ï¼ˆç·æ•°$2^C$é€šã‚Šï¼‰ã®ãã‚Œãã‚Œã«å¯¾ã—ã¦ï¼Œå„åˆ—ã®çŠ¶æ…‹ã‚’è¦‹ã¦ã„ãï¼Œã€Œè¡¨ã«ãªã£ã¦ã„ã‚‹ã›ã‚“ã¹ã„ã®æšæ•°ã®ã»ã†ãŒè£ã«ãªã£ã¦ã„ã‚‹ã›ã‚“ã¹ã„ã‚ˆã‚Šå¤šã‘ã‚Œã°ã²ã£ãã‚Šè¿”ã™ï¼ãã†ã§ãªã‘ã‚Œã°ã²ã£ãã‚Šè¿”ã•ãªã„ã€ã¨ã„ã†æ“ä½œã‚’è¡Œã£ã¦ï¼Œå…¨ä½“ã¨ã—ã¦å‡ºè·ã§ãã‚‹ã›ã‚“ã¹ã„ã®æšæ•°ã‚’èª¿ã¹ï¼Œãã®æœ€å¤§å€¤ã‚’è¨ˆç®—ã™ã‚‹ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int table[10][10000]; int main() { int row, col; cin \u0026gt;\u0026gt; row \u0026gt;\u0026gt; col; for (int i = 0; i \u0026lt; row; i++) { for (int j = 0; j \u0026lt; col; j++) { cin \u0026gt;\u0026gt; table[i][j]; } } int ans = 0; for (int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; row); bit++) { int cnt = 0; for (int j = 0; j \u0026lt; col; j++) { int omote = 0, ura = 0, state; for (int r = 0; r \u0026lt; row; r++) { state = table[r][j]; if ((bit \u0026gt;\u0026gt; r) \u0026amp; 1) { state = !state; } if (state) omote++; else ura++; } cnt += max(omote, ura); } ans = max(ans, cnt); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } Square869120Contest #4 B $N$å€‹ã‚ã‚‹å»ºç‰©ã«ã¤ã„ã¦ï¼Œã©ã®å»ºç‰©ãŒè¦‹ãˆã¦ï¼Œã©ã®å»ºç‰©ãŒè¦‹ãˆãªã„ã‹ã¯ãœã‚“ã¶ã§$2^N$é€šã‚Šã§ã‚ã‚‹ãŒï¼Œ$K$è‰²è¦‹ãˆã¦ã»ã—ã„ã®ã§ï¼Œ$N$æ¡ã®ãƒ“ãƒƒãƒˆåˆ—ã‹ã‚‰$K$æ¡ã ã‘1ãŒç«‹ã£ã¦ã„ã‚‹ã‚ˆã†ãªãƒ“ãƒƒãƒˆåˆ—ã‚’è¨ˆç®—ã§ããŸã‚‰ï¼Œãƒ“ãƒƒãƒˆå…¨æ¢ç´¢ã¨åŒæ§˜ã«è€ƒãˆã‚‹ã“ã¨ãŒã§ãã‚‹ï¼å»ºç‰©ã®è¦‹ãˆæ–¹ã‚’å›ºå®šã—ãŸã¨ãï¼Œå»ºç‰©ã‚’å·¦ã‹ã‚‰é †ç•ªã«è¦‹ã¦ã„ã£ã¦ï¼Œè¦‹ãˆã¦ã»ã—ã„å»ºç‰©ã¯ãã®å»ºç‰©ã‚ˆã‚Šå·¦å´ã«ã‚ã‚‹æœ€ã‚‚èƒŒã®é«˜ã„å»ºç‰©ã‚ˆã‚Š1ã ã‘é«˜ãï¼Œè¦‹ãˆãªãã¦ã‚‚ã„ã„å»ºç‰©ã¯ãã®ã¾ã¾ã«ã—ã¦ãŠãï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int next_combination(int bit) { int x = bit \u0026amp; -bit; int y = bit + x; return (((bit \u0026amp; ~y) / x) \u0026gt;\u0026gt; 1) | y; } int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; k--; vector\u0026lt;long long\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; if (k == 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } n--; long long res = 1001001001001; int bit = (1 \u0026lt;\u0026lt; k) - 1; for (; bit \u0026lt; (1 \u0026lt;\u0026lt; n); bit = next_combination(bit)) { long long highest = a[0]; long long tmp = 0; for (int i = 0; i \u0026lt; n; i++) { if ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) { if (a[i+1] \u0026lt;= highest) { tmp += (highest - a[i+1] + 1); highest += 1; } else { highest = a[i+1]; } } else { if (highest \u0026lt; a[i+1]) { highest = a[i+1]; } } } res = min(res, tmp); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt;endl; return 0; } é †åˆ—å…¨æ¢ç´¢ ABC 145 C é †åˆ—å…¨æ¢ç´¢ã‚’ä½¿ãˆã£ã¦ã„ã†æ„å›³ãŒä¸¸è£¸ã£ã¦æ„Ÿã˜ã®å•é¡Œï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int N; double x[10], y[10]; double dist(int i, int j) { double dx = x[i] - x[j]; double dy = y[i] - y[j]; return pow(dx*dx + dy*dy, 0.5); } int main() { cin \u0026gt;\u0026gt; N; for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; double sum = 0.0; vector\u0026lt;int\u0026gt; towns(N); for (int i = 0; i \u0026lt; N; i++) towns[i] = i+1; do { for (int i = 0; i \u0026lt; N-1; i++) { sum += dist(towns[i], towns[i+1]); } } while (next_permutation(towns.begin(), towns.end())); int fact = 1; for (int i = 2; i \u0026lt;= N; i++) fact *= i; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(12) \u0026lt;\u0026lt; sum/fact \u0026lt;\u0026lt; endl; return 0; } ABC 150 C do {...} while (next_permutation());ã®ç·´ç¿’å•é¡Œï¼ã‚½ãƒ¼ãƒˆã—ç›´ã™ã®ã‚’å¿˜ã‚Œãªã„ã‚ˆã†ã«ï¼\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; p(n), q(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; p[i]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; q[i]; vector\u0026lt;int\u0026gt; s(n); for (int i = 0; i \u0026lt; n; i++) s[i] = i+1; int i = 0; int pidx = 0; int qidx = 0; do { bool pflag = true; for (int i = 0; i \u0026lt; n; i++) { if (s[i] != p[i]) pflag = false; } if (pflag) { pidx = i; break; } else i++; } while (next_permutation(s.begin(), s.end())); sort(s.begin(), s.end()); i = 0; do { bool qflag = true; for (int i = 0; i \u0026lt; n; i++) { if (s[i] != q[i]) qflag = false; } if (qflag) { qidx = i; break; } else i++; } while (next_permutation(s.begin(), s.end())); cout \u0026lt;\u0026lt; abs(pidx - qidx) \u0026lt;\u0026lt; endl; return 0; } ABC 54 C 1ã‚’å§‹ç‚¹ã¨ã™ã‚‹DFSã§æ¡ä»¶ã‚’æº€ãŸã™ãƒ‘ã‚¹ã‚’æ•°ãˆä¸Šã’ã‚‹æ–¹æ³•ãŒä¸€ç•ªç´ ç›´ã ã‘ã‚Œã©ã‚‚ï¼Œåˆ¶ç´„ã«æ³¨ç›®ã™ã‚‹ã¨ï¼Œä¸ãˆã‚‰ã‚Œã‚‹ã‚°ãƒ©ãƒ•ã®é ‚ç‚¹æ•°ãŒæœ€å¤§ã§ã‚‚8ã¨ã„ã†ã“ã¨ã‚’è€ƒæ…®ã™ã‚‹ã¨ï¼Œé ‚ç‚¹ã®è¨ªå•é †åºã‚’ï¼Œç”Ÿãˆã¦ã„ã‚‹è¾ºã‚’ç„¡è¦–ã—ã¦é †åˆ—å…¨æ¢ç´¢ã‚’ã—ã¦ï¼Œç·¨ã®ç”Ÿãˆæ–¹ã«çŸ›ç›¾ã—ãªã„ã‚‚ã®ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ã¨ã—ã¦ã‚‚è§£ã‘ã‚‹ï¼ã¾ã‚æ•™è‚²çš„ãªè¦³ç‚¹ã‹ã‚‰ã¯DFSã®ç·´ç¿’ã¨ã—ã¦æ€ã£ãŸæ–¹ãŒè‰¯ã•ãã†ã ã‘ã‚Œã©ï¼\n DFSã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; // 1ã‚’å§‹ç‚¹ã¨ã—ã¦DFSã§ã‚°ãƒ©ãƒ•ä¸Šã‚’æ¢ç´¢ã—æ¡ä»¶ã‚’æº€ãŸã™ãƒ‘ã‚¹ã‚’æ•°ãˆä¸Šã’ã‚‹  const int nmax = 8; bool graph[nmax][nmax]; int dfs(int v, int N, bool has_visited[nmax]) { bool has_visited_all = true; for (int i = 0; i \u0026lt; N; i++) { if (has_visited[i] == false) { has_visited_all = false; } } if (has_visited_all) { return 1; } int ret = 0; for (int i = 0; i \u0026lt; N; i++) { if (graph[v][i] == false) continue; if (has_visited[i]) continue; has_visited[i] = true; ret += dfs(i, N, has_visited); has_visited[i] = false; } return ret; } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for (int i = 0; i \u0026lt; M; i++) { int A, B; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; graph[A-1][B-1] = graph[B-1][A-1] = true; } bool has_visited[nmax]; for (int i = 0; i \u0026lt; N; i++) { has_visited[i] = false; } has_visited[0] = true; cout \u0026lt;\u0026lt; dfs(0, N, has_visited) \u0026lt;\u0026lt; endl; return 0; }  é †åˆ—å…¨æ¢ç´¢ã«ã‚ˆã‚‹è§£ç­”  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int nmax = 8; bool graph[nmax][nmax]; int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for (int i = 0; i \u0026lt; M; i++) { int A, B; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; graph[A-1][B-1] = graph[B-1][A-1] = true; } vector\u0026lt;int\u0026gt; nodes(N); for (int i = 0; i \u0026lt; N; i++) nodes[i] = i; int cnt = 0; do { bool flag = true; if (nodes[0] != 0) continue; for (int i = 0; i \u0026lt; N-1; i++) { if (graph[nodes[i]][nodes[i+1]] == false) flag = false; continue; } if (flag) cnt++; } while (next_permutation(nodes.begin(), nodes.end())); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } ãŠã‚ã‚Šã« ğŸ˜„ ã“ã‚Œã§ã¼ãã‚‚å…¨æ¢ç´¢ãƒã‚¹ã‚¿ãƒ¼ï¼\n","date":1586086353,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1586086353,"objectID":"fd690ac4ec57b7488c94b4772e3fbd7e","permalink":"/ja/post/check-all-cases/","publishdate":"2020-04-05T20:32:33+09:00","relpermalink":"/ja/post/check-all-cases/","section":"post","summary":"å…¨æ¢ç´¢ ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ã€Œã‚­ãƒ›ãƒ³ã€ã®ã€Œã‚­ã€ï¼è«–ç†çš„ã«è€ƒãˆã‚‹ã“ã¨ã«ãªã‚Œã™ãã¦ã‚‹ã¨ï¼Œå½“ãŸã‚Šå‰éãã¦ã€Œãªã‚“ã‹ãšã‚‹ã„ã€ã£ã¦æ€ã†ã‘ã©ï¼Œç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ","tags":["AtCoder","Competitive Programming","C++","cpp","ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°","ç«¶ãƒ—ãƒ­","å…¨æ¢ç´¢","ãƒ“ãƒƒãƒˆå…¨æ¢ç´¢","é †åˆ—å…¨æ¢ç´¢","ABC"],"title":"å…¨æ¢ç´¢","type":"post"},{"authors":[],"categories":[],"content":"è‰¯ã•ã’ãªå®Ÿè£…ãƒ†ã‚¯ã‚’ç™ºè¦‹ã—ãŸã®ã§å¿˜ã‚Œãªã„ã‚ˆã†ã«ãƒ¡ãƒ¢ï¼\nfunctional optionsã¨ã¯ ä½•ã‹ã‚’ã€Œè¨­å®šã€ã—ãŸã„ã¨ãã«ãã‚Œã„ã«æ›¸ã‘ã‚‹APIã®ãŠä½œæ³•ï¼ä½•ã‹ã‚’è¨­å®šã—ãŸã„ã ã‘ãªã‚‰ï¼Œè‰²ã‚“ãªæ–¹æ³•ãŒã‚ã‚‹ã‘ã©ï¼Œã“ã®ãŠä½œæ³•ã«å‰‡ã£ã¦ã‚‹ã¨èª­ã¿ã‚„ã™ã„ã—æ›¸ãã‚„ã™ã„ï¼ èª­ã¿ã‚„ã™ãã¦æ›¸ãã‚„ã™ã„ã“ã¨ã¯å¤§äº‹ãªã®ã§ï¼ŒçŸ¥ã£ã¦ãŠãã¨è‰¯ã„ï¼\nä½•ã‹ã‚’è¨­å®šã™ã‚‹ä»–ã®æ–¹æ³•ã ã¨ï¼Œä¾‹ãˆã°è¨­å®šæƒ…å ±ã‚’è¡¨ç¾ã™ã‚‹æ§‹é€ ä½“ã‚’å®šç¾©ã—ã¦ãã‚Œã‚’ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã™ã¨ã‹ï¼Œè¨­å®šã®setterã‚’è¨­ã‘ã‚‹ã¨ã‹ï¼ã“ã‚Œã‚‰ã®æ–¹æ³•ã ã¨ï¼ŒãŸãã•ã‚“è¨­å®šäº‹é …ãŒã‚ã‚‹ã¨ãã«å›°ã£ãŸã‚Šã™ã‚‹ï¼\nä½•ã‚‰ã‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã¨ãï¼Œå¤§æŠµã®å ´åˆã“ã‚“ãªæ„Ÿã˜ã§æ›¸ãï¼\nobj := New(arg0, arg1) functional optionsã®ãŠä½œæ³•ã«å‰‡ã£ã¦æ›¸ãã¨\nobj := New(arg0, arg1) ã¨ã‚‚æ›¸ã‘ã‚‹ã—ï¼Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆæ™‚ã«è¨­å®šã‚‚ä¸€ç·’ã«ä»•è¾¼ã‚€ãªã‚‰\nobj := New(arg0, arg1, option0, option1) ã¨ã‚‚æ›¸ã‘ã‚‹ï¼\nfunctional optionsã®ãŠä½œæ³•ã¯ï¼Œãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ã€Œä»»æ„å€‹ã®å¼•æ•°ã‚’å–ã‚‹ã€è¨˜æ³•ã‚’ä½¿ã†ï¼ã“ã®è¨˜æ³•ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ãªã„ã¨ã§ããªã„ã‹ã‚‚ï¼è‹±èªã ã¨ï¼Œã€Œä»»æ„å€‹ã®å¼•æ•°ã‚’å–ã‚‹ã€ã¨ã„ã†æ§˜ã‚’variadicã¨è¨€ã†ã‚‰ã—ã„ï¼\nå…·ä½“çš„ãªã‚³ãƒ¼ãƒ‰ã§ãªã„ã¨æ„å‘³ãŒã‚ˆãã‚ã‹ã‚‰ãªã„ã®ã§å…·ä½“çš„ã«ã—ã¦ã¿ã‚‹ï¼ãªã‚“ã‚‰ã‹ã®ã‚µãƒ¼ãƒã‚’æƒ³å®šã™ã‚‹ã¨ã‚ã‹ã‚Šã‚„ã™ã„ï¼\ntype Server struct { addr string } func NewServer(addr string) *Server { return \u0026amp;Server { addr: addr, } } ã“ã‚Œã¯ã¾ã‚æ™®é€šã«ã‚ˆãã‚ã‚‹æ›¸ãæ–¹ï¼ã§ã¯ï¼Œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®è¨­å®šã‚’ã—ãŸã‚µãƒ¼ãƒã‚’ç”Ÿæˆã™ã‚‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’æ›¸ã„ã¦ã¿ã‚ˆã†ï¼functional optionsã®ãŠä½œæ³•ã«å¾“ã£ã¦æ›¸ãã¨ã“ã‚“ãªæ„Ÿã˜ï¼\ntype Server struct { addr string timeout time.Duration } func Timeout(timeout time.Duration) func(*Server) { return func(s *Server) { s.timeout = timeout } } func NewServer(addr string, opts ...func(*Server)) *Server { server := \u0026amp;Server { addr: addr, } for _, opt := range opts { opts(server) } return server } ã“ã†ã‚„ã£ã¦æ›¸ã„ã¦ã‚ã‚‹ã¨ï¼Œã“ã®ã‚³ãƒ¼ãƒ‰ã®åˆ©ç”¨è€…å´ã¯ã“ã‚“ãªæ„Ÿã˜ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã“ã¨ã«ãªã‚‹ï¼\n// no options, use defaults server := NewServer(\u0026#34;:8080\u0026#34;) // configured to timeout after 10 seconds with address server := NewServer(\u0026#34;:8080\u0026#34;, Timeout(10 * time.Second)) // configured to timeout after 10 seconds and use TLS for connection with address server := NewServer(\u0026#34;8080\u0026#34;, Timeout(10 * time.Second), TLS(\u0026amp;TLSConfig{})) ãªã‚‹ã»ã©ï¼Œã‚ã‹ã‚Šã‚„ã™ã„ï¼ã“ã‚Œã‚’ä¾‹ãˆã°ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ãŸãã•ã‚“å¼•æ•°ã‚’æ¸¡ã—ã¦è¨­å®šã™ã‚‹ã‚„ã‚Šæ–¹ã§ã‚„ã‚‹ã¨ã“ã‚“ãªæ„Ÿã˜ã«ãªã‚‹ï¼\nserver := NewServer(\u0026#34;:8080\u0026#34;) server := NewServerWithTimeout(\u0026#34;:8080\u0026#34;, 10 * time.Second) server := NewServerWithTimeoutAndTLS(\u0026#34;:8080\u0026#34;, 10 * time.Second, \u0026amp;TLSConfig{}) æ¸¡ã™è¨­å®šã«ã‚ˆã£ã¦å¼•æ•°ãŒå¤‰ã‚ã£ã¡ã‚ƒã†ã®ã§ãã‚Œã«åˆã‚ã›ãŸã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå¿…è¦ã«ãªã£ã¦ã—ã¾ã†ï¼ã“ã‚Œã¯å¤§å¤‰ï¼\nã˜ã‚ƒã‚ãã‚Œã‚‰ã‚’ã¾ã¨ã‚ã¦Configæ§‹é€ ä½“ã‚’ä½œã‚‹ãã£ã¦ã‚„ã‚‹ã¨\nserver := NewServer(\u0026#34;:8080\u0026#34;, Config{}) server := NewServer(\u0026#34;:8080\u0026#34;, Config{ Timeout: 10 * time.Second }) server := NewServer(\u0026#34;:8080\u0026#34;, Config{ Timeout: 10 * time.Second, TLS: \u0026amp;TLSConfig{} }) ã¨ãªã‚‹ï¼ã¾ã‚ã“ã‚Œã§ã‚‚ã„ã„ã‚“ã ã‘ã©ï¼Œä½•ã‚‚è¨­å®šã—ãªã„ã¨ãã«ç©ºã®Config{}ã‚’æ¸¡ã•ãªã„ã¨ã„ã‘ãªã„ã®ã¯ãƒãƒ§ãƒƒãƒˆä¸æ ¼å¥½ã ã—ï¼Œä½•ã‚ˆã‚Šè¨­å®šäº‹é …ãŒå¢—ãˆãŸã¨ãã«èª­ã¿ã¥ã‚‰ããªã‚Šãã†ï¼\nã¨ã„ã†ã‚ã‘ã§ï¼Œè¨­å®šã—ãŸã„ã‚‚ã®ã‚’å¼•æ•°ã«å–ã£ã¦ï¼Œè¨­å®šã‚’ã€Œé©ç”¨ã€ã—ã¦ã„ãã‚ˆã†ãªé–¢æ•°ã‚’ç”¨æ„ã™ã‚‹ã¨ã‹ã£ã“ã‚ˆãæ›¸ã‘ã‚‹ï¼\nã•ã‚‰ã«èª­ã¿ã‚„ã™ãã™ã‚‹å·¥å¤« func (s *Server)ã«åå‰ã‚’ã¤ã‘ã¦ã—ã¾ãˆã°ã‚‚ã£ã¨ã‚ã‹ã‚Šã‚„ã™ããªã‚‹ï¼\ntype Option func(s *Server) ã“ã†ã™ã‚Œã°\nfunc Timeout(timeout time.Duration) Option { /*...*/ } func NewServer(addr string, opts ...Option) *Server { /*...*/ } ã¨ãªã£ã¦ï¼Œã‚ˆã‚Šã€Œã‚ï¼Œã‚ªãƒ—ã‚·ãƒ§ãƒ³å–ã‚‹ã‚“ã ãªã€ã£ã¦ã®ãŒã‚ã‹ã‚‹ï¼ã†ã‚Œã—ã„ğŸ˜„\nã“ã†ãªã‚‹ã¨è¤‡æ•°ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚‚ã„ã„æ„Ÿã˜ã«ã¾ã¨ã‚ã‚‹ã“ã¨ãŒã§ããã†ï¼\ndefaultOptions := []Option{Timeout(5 * time.Second)} server1 := NewServer(\u0026#34;:8080\u0026#34;, append(defaultOptions, MaxConnections(10))...) server2 := NewServer(\u0026#34;:8080\u0026#34;, append(defaultOptions, RateLimit(10, time.Minute))...) server3 := NewServer(\u0026#34;:8080\u0026#34;, append(defaultOptions, Timeout(10 * time.Second))...) []Optionã‚’ã‚‚ã£ã¨è³¢ãã—ãŸã„ã®ã§ï¼Œ\nfunc Options(opts ...Option) Option { return func(s *Server) { for _, opt := range opts { opt(s) } } } ã‚’ç”¨æ„ã™ã‚Œã°ï¼Œ\ndefaultOptions := Options(Timeout(5 * time.Second)) server1 := NewServer(\u0026#34;:8080\u0026#34;, defaultOptions, MaxConnections(10)) server2 := NewServer(\u0026#34;:8080\u0026#34;, defaultOptions, RateLimit(10, time.Minute)) server3 := NewServer(\u0026#34;:8080\u0026#34;, defaultOptions, Timeout(10 * time.Second)) ã¨ã§ãã¦ï¼Œã‚¤ã‚¤æ„Ÿã˜ï¼\nWith/Set Loggerã¨ã‹ã‚‚è¨­å®šã—ãŸã„ã‚‚ã®ã¨ã—ã¦ã¯ã‚ˆãã‚ã‚‹ï¼\ntype Logger interface { Info(msg string) Error(msg string) } ã¨ã‹ã‚’ç”¨æ„ã—ã¦ãŠã„ã¦ï¼Œ\nfunc WithLogger(logger Logger) Option { return func(s *Server) { s.logger = logger } } NewServer(\u0026#34;:8080\u0026#34;, WithLogger(logger)) ã¨ã™ã‚‹ã¨ï¼Œãªã‚‹ã»ã©ã‚ã‹ã‚Šã‚„ã™ã„ï¼\næ›´ã«ä»–ã®ä¾‹ã ã¨ï¼Œ\ntype Server struct { // ...  whitelistIPs []string } func WithWhitelistedIP(ip string) Option { return func(s *Server) { s.whitelistIPs = append(s.whitelistIPs, ip) } } func SetWhitelistedIP(ip string) Option { return func(s *Server) { s.whitelistIPs = []string{ip} } } NewServer( \u0026#34;:8080\u0026#34;, WithWhitelistedIP(\u0026#34;10.0.0.0/8\u0026#34;), WithWhitelistedIP(\u0026#34;172.16.0.0/12\u0026#34;), SetWhitelistedIP(\u0026#34;192.168.0.0/16\u0026#34;), // overwrites any previous values ) Withã¯ã€Œè¿½åŠ ã€ã§ï¼ŒSetã¯ã€Œä¸Šæ›¸ãã€ã¨ã„ã†é›°å›²æ°—ï¼\nOptionå‹ã®é–¢æ•°ã‚’è¿”ã™é–¢æ•°ã‚’ç”¨æ„ã™ã‚‹ã“ã¨ã§ï¼Œç‰¹å®šã®è¨­å®šã®ãƒ—ãƒªã‚»ãƒƒãƒˆã¿ãŸã„ãªã‚‚ã®ã‚’å®šç¾©ã§ãã¦ã“ã‚Œã¾ãŸä¾¿åˆ©ï¼\nConfigæ§‹é€ ä½“ã¨ã®æ›ã‘åˆã‚ã› Configæ§‹é€ ä½“ã‚’ç”¨æ„ã—ã¦ï¼ŒConfigæ§‹é€ ä½“ã‚’å¼•æ•°ã«å–ã‚‹Optionå‹ã®é–¢æ•°ã¨ã—ã¦ã‚‚ã„ã„ï¼ãŸãã•ã‚“ã‚ã‚‹è¨­å®šã‚’Configã¨ã„ã†ä¸€ã¤ã®å ´æ‰€ã«é–‰ã˜è¾¼ã‚ã‚‰ã‚Œã‚‹ã®ã§ï¼Œè¨­å®šäº‹é …ãŒã‚ã¡ã‚ƒã‚ã¡ã‚ƒã‚ã‚‹å ´åˆã«ã¯ä¾¿åˆ©ï¼\ntype Config struct { Timeout time.Duration } type Option func(c *Config) type Server struct { // ...  config Config } config := Config{ Timeout: 10 * time.Second // ...  // lots of other options } NewServer(\u0026#34;:8080\u0026#34;, WithConfig(config), WithTimeout(20 * time.Second)) Optionã‚’é–¢æ•°å‹ã§ã¯ãªãã¦interfaceã¨ã—ã¦ã•ã‚‰ã«æŸ”è»Ÿã«è¨­å®šã‚’å—ã‘å…¥ã‚Œã‚‹ Optionã‚’interfaceã«ã—ã¦ã—ã¾ãˆã°ï¼Œã‚‚ã£ã¨ã„ã‚ã‚“ãªè¨­å®šã‚’å—ã‘å…¥ã‚Œã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ï¼\n// Option configures a Server. type Option interface { // apply is unexported,  // so only the current package can implement this interface.  apply(s *Server) } // Timeout configures a maximum length of idle connection in Server. type Timeout time.Duration func (t Timeout) apply(s *Server) { s.timeout = time.Duration(t) } // Options turns a list of Option instances into an Option. type Options []Option func (o Options) apply(s *Server) { for _, opt := range o { o.apply(s) } } type Config struct { Timeout time.Duration } func (c Config) apply(s *Server) { s.config = c } Futher readings   https://sagikazarmark.hu/blog/functional-options-on-steroids/\n  https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis\n  https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html\n  https://www.sohamkamani.com/blog/golang/options-pattern/\n  https://www.calhoun.io/using-functional-options-instead-of-method-chaining-in-go/\n  ","date":1585827806,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1585827806,"objectID":"ffef49b047ff2408e373841e5647c10a","permalink":"/ja/post/functional-options/","publishdate":"2020-04-02T20:43:26+09:00","relpermalink":"/ja/post/functional-options/","section":"post","summary":"è‰¯ã•ã’ãªå®Ÿè£…ãƒ†ã‚¯ã‚’ç™ºè¦‹ã—ãŸã®ã§å¿˜ã‚Œãªã„ã‚ˆã†ã«ãƒ¡ãƒ¢ï¼ functional optionsã¨ã¯ ä½•ã‹ã‚’ã€Œè¨­å®šã€ã—ãŸã„ã¨ãã«ãã‚Œã„ã«æ›¸ã‘ã‚‹APIã®ãŠä½œæ³•ï¼ä½•ã‹ã‚’è¨­å®šã—ãŸ","tags":["Golang","Functional","Functional Options","Configuration"],"title":"Functional Options","type":"post"},{"authors":[],"categories":[],"content":"\u0026ldquo;-oriented\u0026quot;ã£ã¦ã©ã†ã„ã†æ„å‘³ãªã‚“ã ã‚ã†ï¼Ÿ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ãŠå‹‰å¼·ã—ã¦ã„ã‚‹ã®ã§ï¼Œã„ã‚ã‚“ãªã‚«ã‚¿ã‚«ãƒŠç”¨èªã«é­é‡ã™ã‚‹ï¼ã‚«ã‚¿ã‚«ãƒŠç”¨èªã£ã¦ãã®è¨€è‘‰ã®æŒ‡ã™æ„å‘³ãŒå­—é¢ã«ç¾ã‚Œã¦ã“ãªãã¦ï¼Œã€Œãã‚Œã£ã¦ã©ã†ã„ã†æ„å‘³ï¼Ÿã€ã¨ãªã‚ŠãŒã¡ã ï¼\næœ€è¿‘æ°—ã«ãªã£ãŸã®ã¯ã€ŒXXX-orientedã€ã¨ã„ã†è¨€è‘‰ã ï¼Object-orientedã¨ã‹service-orientedã¨ã‹ã§ç›®ã«ã™ã‚‹ï¼æ—¥æœ¬èªã«è¨³ã•ã‚Œã‚‹ã¨ãã¯ã€ŒXXXæŒ‡å‘ã€ã£ã¦è¨³ã•ã‚Œã¦ã„ã‚‹ï¼ãŒï¼Œæ—¥æœ¬èªã«è¨³ã•ã‚ŒãŸã¨ã“ã‚ã§æ„å‘³ã¯åˆ¤ç„¶ã¨ã—ãªã„ï¼ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ ã¨ã¯ã€ã§ã‚°ã‚°ã‚‹ã¨ã‚ã¡ã‚ƒã‚ã¡ã‚ƒãŸãã•ã‚“ã®ãƒ–ãƒ­ã‚°è¨˜äº‹ãŒå‡ºã¦ãã‚‹ï¼ã ã„ãŸã„ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã£ã¦ã‚ˆãã‚ã‹ã‚“ã­ã‡ã‚ˆãªï¼ä¿ºãŒè§£èª¬ã—ã¦ã‚„ã‚‹ï¼ã€ã£ã¦ã„ã†è¶£æ—¨ã®è¨˜äº‹ã§ï¼Œä¸–ç•Œä¸€ã‚ã‹ã‚Šã‚„ã™ã„ã¨è¬³ã£ã¦ã„ã‚‹ï¼\nåƒ•ã‚‚ãã‚Œã‚‰ã®é¡ã®è¨˜äº‹ã¯ã„ãã¤ã‹å‘¼ã‚“ã ã“ã¨ãŒã‚ã‚‹ã—ï¼Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’æ–‡æ³•ã‹ã‚‰ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã„ã‚ã‚“ãªè¨€èªã§ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã—ãŸã“ã¨ãŒã‚ã‚‹ã®ã§ï¼Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã¨ã¯ãªã‚“ãªã®ã‹ï¼Œã¿ãŸã„ãªã¨ã“ã‚ã®ã€Œæ‰‹è§¦ã‚Šæ„Ÿã€ã¯ãªã‚“ã¨ãªãåˆ†ã‹ã£ã¦ã„ã‚‹ã‘ã©ï¼Œã‚‚ã†ã¡ã‚‡ã£ã¨ãƒ¡ã‚¿ãªè¦–ç‚¹ã‹ã‚‰ã€ŒXXX-orientedã€ã®æ„å‘³ã‚’è€ƒãˆã¦ã¿ãŸããªã£ãŸï¼\nã€ŒXXX-orientedã€ã®ä¸­ã§ã‚‚ä¸€ç•ªæœ‰åãªã®ã‹ã‚‚çŸ¥ã‚Œãªã„ã®ãŒã€ŒObject-orientedã€ã ã¨æ€ã†ã®ã§ï¼Œãã“ã‹ã‚‰è€ƒãˆã¦ã¿ã‚‹ï¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã™ã‚‹ã¨ï¼Œè¨˜è¿°ã—ãŸã„äº‹æŸ„ã‚’ã€Œãƒ‡ãƒ¼ã‚¿ã¨ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹æ“ä½œã‚’ä¸€æ‹¬ã«ã¾ã¨ã‚ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãªã‚‹ã‚‚ã®ã‚’ãŸãã•ã‚“å®šç¾©ã—ã¦ï¼Œãã‚Œã‚‰ã®ç›¸äº’ä½œç”¨ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨˜è¿°ã—ã¦ã„ãã“ã¨ã«ãªã‚‹ï¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã§ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã‘ã‚‹ä¸»å½¹ã¯ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã§ã‚ã‚Šï¼Œãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ãã‚Œã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒå£«ã®å‹•ãã‚’ï¼Œã‚ãŸã‹ã‚‚æ¼”åŠ‡ã«ãŠã‘ã‚‹è„šæœ¬ã‚’æ›¸ã„ã¦ã„ã‚‹ã‹ã®ã‚ˆã†ã«æ“ã£ã¦1ã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ä»•ç«‹ã¦ä¸Šã’ã‚‹ï¼åƒ•ãŒæ€ã†ã«ï¼Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã§å¤§äº‹ãªã®ã¯ã€Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã‘ã‚‹ä¸»å½¹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã€ã¨ã„ã†ç‚¹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã®æœ¬å½“ã®ã¨ã“ã‚ãªã®ã ã¨æ€ã†ï¼ã€ŒObject-orientedã€ãŒã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä¸»å½¹ã€ã®æ„å‘³ãªã‚‰ã€ŒXXX-orientedã€ã¯ã€ŒXXXãŒä¸»å½¹ã€ã£ã¦ã“ã¨ãªã®ã ã‚ã†ã‹ï¼Ÿ\nã€Œorientedã€ã‚’é©å½“ã«è‹±èªè¾å…¸ã§å¼•ã„ã¦ã¿ã‚‹ã¨ï¼Œã€Œç‰¹å®šã®æ–¹å‘ã«å‘ãï¼Œä½ç½®ã‚’å®šã‚ã‚‹ã€ã¨ã„ã†æ„å‘³ã®ã€Œorientã€ã®éå»åˆ†è©ãŒè»¢ã˜ãŸå½¢å®¹è©ã¨æ›¸ã„ã¦ã‚ã£ãŸï¼ã¨ã„ã†ã“ã¨ã¯ï¼Œå­—é¢ã§è¨€ãˆã°ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ–¹ã‚’å‘ã„ãŸã€ã£ã¦æ„å‘³ãªã®ã‹ï¼Ÿã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã€ã¨ã„ã†æ¼¢å­—ã¯ãã†ã„ã†é›°å›²æ°—ãŒç¢ºã‹ã«æ„Ÿã˜ã‚‰ã‚Œã‚‹ï¼\nObject-orientedã£ã¦è¨€ã†ã¨ãã¯ãŠãã‚‰ãã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸»å½¹ã¨ã™ã‚‹ï¼ˆã¨ã„ã†æ–¹å‘ã‚’å‘ã„ãŸï¼‰æ€æƒ³ã«åŸºã¥ãæŠ€è¡“ã€ã£ã¦æ„å‘³ãªã‚“ã ã‚ã†ãªãï¼ã¨ãªã‚‹ã¨Object-oriented programmingã£ã¦ã„ã†ã®ã¯ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸»å½¹ã¨ã™ã‚‹ï¼ˆã¨ã„ã†æ–¹å‘ã‚’å‘ã„ãŸï¼‰æ€æƒ³ã«åŸºã¥ã„ã¦ç¢ºç«‹ã•ã‚ŒãŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ‰‹æ³•ã€çš„ãªæ„å‘³åˆã„ã«ãªã‚Šãã†ã ã—ï¼Œåƒ•ã®è‚Œæ„Ÿã¨ã‚‚ã‚ã£ã¦ãã‚‹ï¼\nãªã‚‹ã»ã©ï¼ŒService-Oriented Architectureã‚‚ãã†è€ƒãˆã‚‹ã¨ï¼Œã€Œã‚µãƒ¼ãƒ“ã‚¹ã€ãŒä¸»å½¹ã¨ã—ã¦æŒ¯ã‚‹èˆã†ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã£ã¦ã“ã¨ãªã‚“ã ã‚ã†ãª\u0026hellip;ã˜ã‚ƒã‚æœ€è¿‘è©±é¡Œã®ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨ä½•ãŒé•ã†ã‚“ã ã‚ã†\u0026hellip;åŒã˜ã‚ˆã†ãªåå‰ã ã‘ã©\u0026hellip;æš‡ãªã¨ãã«ã§ã‚‚èª¿ã¹ã¦ã¿ã‚‹ã‹ï¼\n ã€ŒXXX-orientedã€ã¨ã¯ã€ŒXXXã¨ã„ã†æ–¹å‘æ€§ã«åŸºã¥ãï¼ˆæŠ€è¡“ï¼‰ã€ãã‚‰ã„ã®æ„å‘³\n ","date":1583642839,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1583642839,"objectID":"7cdba072803c0050e5c4198525e26daf","permalink":"/ja/post/what-is-object-oriented/","publishdate":"2020-03-08T13:47:19+09:00","relpermalink":"/ja/post/what-is-object-oriented/","section":"post","summary":"\u0026ldquo;-oriented\u0026quot;ã£ã¦ã©ã†ã„ã†æ„å‘³ãªã‚“ã ã‚ã†ï¼Ÿ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ãŠå‹‰å¼·ã—ã¦ã„ã‚‹ã®ã§ï¼Œã„ã‚ã‚“ãªã‚«ã‚¿ã‚«ãƒŠç”¨èªã«é­é‡ã™ã‚‹ï¼","tags":["Terminology","Object-Oriented Programming","OOP"],"title":"ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã€ã«ã¤ã„ã¦è€ƒãˆã‚‹","type":"post"},{"authors":[],"categories":[],"content":"èª­ã¿ãŸã„  ï¼»æ”¹è¨‚æ–°ç‰ˆï¼½ãƒ—ãƒ­ã‚°ãƒ©ãƒã®ãŸã‚ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰æŠ€è¡“å…¥é–€ ã¿ã‚“ãªã®ãƒ‡ãƒ¼ã‚¿æ§‹é€  ãƒ—ãƒ­ã‚°ãƒ©ãƒã®æ•°å­¦ ç¬¬2ç‰ˆ ç´”ç²‹é–¢æ•°å‹ãƒ‡ãƒ¼ã‚¿æ§‹é€  Understanding Compression å‹ã‚·ã‚¹ãƒ†ãƒ å…¥é–€ â€• ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨å‹ã®ç†è«– ãã®æ•°å¼ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ãã¾ã™ã‹ï¼Ÿ è¨ˆç®—æ©Ÿãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ§‹é€ ã¨è§£é‡ˆ æ­£è¦è¡¨ç¾æŠ€è¡“å…¥é–€ â€• æœ€æ–°ã‚¨ãƒ³ã‚¸ãƒ³å®Ÿè£…ã¨ç†è«–çš„èƒŒæ™¯ ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚¿ãƒ³ãƒ‡ã‚£ãƒ³ã‚° ã‚³ãƒ³ãƒ”ãƒ¥ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ â€• å˜ç´”ãªæ©Ÿæ¢°ã‹ã‚‰ä¸å¯èƒ½ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¾ã§ ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ â€• è‡ªå‹•çš„ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’æ§‹æˆã™ã‚‹ç†è«–ã¨å®Ÿè£… ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å­¦ã¼ã† ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨å®Ÿè£… ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚¤ãƒ³ãƒˆãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç¬¬ä¸‰å·» â€• ç²¾é¸ãƒˆãƒ”ãƒƒã‚¯ã‚¹ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚¤ãƒ³ãƒˆãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç¬¬äºŒå·»ï¼ˆæ”¹è¨‚ 2 ç‰ˆï¼‰ â€• é«˜åº¦ãªè¨­è¨ˆã¨è§£ææ‰‹æ³•ãƒ»é«˜åº¦ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ãƒ»ã‚°ãƒ©ãƒ•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚¤ãƒ³ãƒˆãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç¬¬ä¸€å·»ï¼ˆæ”¹è¨‚ 2 ç‰ˆï¼‰ â€• åŸºç¤ãƒ»ã‚½ãƒ¼ãƒˆãƒ»ãƒ‡ãƒ¼ã‚¿æ§‹é€ ãƒ»æ•°å­¦ ã‚ªãƒ¼ãƒˆãƒãƒˆãƒ³è¨€èªç†è«–ã€€è¨ˆç®—è«– Iï¼ˆç¬¬äºŒç‰ˆï¼‰ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆå²©æ³¢è¬›åº§ ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ç§‘å­¦ 3ï¼‰ åŸºç¤æƒ…å ±ç†è«– æ±Ÿæ·»äº®ã® C++ å…¥é–€ Modern C++ ãƒãƒ£ãƒ¬ãƒ³ã‚¸ â€• C++17 ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°åŠ›ã‚’é›ãˆã‚‹ 100 å• More Effective C# 6.0/7.0 ä½ãƒ¬ãƒ™ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° Optimized C++ C++ ã®ãŸã‚ã® API ãƒ‡ã‚¶ã‚¤ãƒ³ C++ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ï¼ˆç¬¬äºŒç‰ˆï¼‰ The Architecture of Open Source Applications - Volume II: Structure, Scale, and a Few More Fearless Hacks The Architecture of Open Source Applications - Elegance, Evolution, and a Few Fearless Hacks ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æ§‹æˆã¨æœ€é©åŒ– æœ€æ–°ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æ§‹æˆæŠ€æ³•ï¼ˆã‚¿ã‚¤ã‚¬ãƒ¼ãƒ–ãƒƒã‚¯ï¼‰ Linkers and Loaders ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© ä½œã‚ŠãªãŒã‚‰å­¦ã¶ 7 ã¤ã®è¨€èª 7 ã¤ã®ä¸–ç•Œ æ±Ÿæ·»äº®ã®è©³èª¬ C++17 Effective Modern C++ â€• C++11/14 ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’é€²åŒ–ã•ã›ã‚‹ 42 é …ç›® ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æ”¯ãˆã‚‹æŠ€è¡“ ls ã‚’èª­ã¾ãšã«ãƒ—ãƒ­ã‚°ãƒ©ãƒã‚’åä¹—ã‚‹ãªï¼ Effective STL â€• STL ã‚’åŠ¹æœçš„ã«ä½¿ã„ã“ãªã™ 50 ã®é‰„å‰‡ More Effective C++ â€• ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’æ”¹è‰¯ã™ã‚‹ãŸã‚ã®æ–° 35 é …ç›® Effective C++ â€• ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’æ”¹è‰¯ã™ã‚‹ãŸã‚ã® 55 é …ç›® ã‚²ãƒ¼ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒã®ãŸã‚ã® C++ è¨€èªå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ â€• ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æŠ€è¡“ã«ã‚ˆã‚‹ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†ã‹ã‚‰è¨€èªå®Ÿè£…ã¾ã§ ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆ JavaScript Effective Javaï¼ˆç¬¬äºŒç‰ˆï¼‰ Binary Hacks â€• ãƒãƒƒã‚«ãƒ¼ç§˜ä¼ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ 100 é¸ ãƒªãƒ³ã‚«ãƒ»ãƒ­ãƒ¼ãƒ€å®Ÿè·µé–‹ç™ºãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ â€• å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«å¿…é ˆã®æŠ€è¡“ çœãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° â€• ãƒ¡ãƒ¢ãƒªåˆ¶é™ã®ã‚ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã®ãŸã‚ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ‘ã‚¿ãƒ¼ãƒ³é›† ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ Objective-C ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° iPhone ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° UIKit è©³è§£ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚¨ãƒ³ã‚¸ãƒ³ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚¢ãƒ‰ãƒãƒ³ã‚¹ â€• å®Ÿè·µçš„ UNIX ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã«ã¿ã‚‹ç ç‰ã®æ‰‹æ³• ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ â€• UNIX ã‚³ãƒãƒ³ãƒ‰ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã«ã¿ã‚‹å®Ÿè·µãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ‰‹æ³• ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ Python ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° GNU Makeï¼ˆç¬¬ä¸‰ç‰ˆï¼‰ ãµã¤ã†ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚’ã¤ãã‚ã† â€• è¨€èªå‡¦ç†ç³»ã‚’ã¤ãã‚ŠãªãŒã‚‰å­¦ã¶ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã¨å®Ÿè¡Œç’°å¢ƒã®ä»•çµ„ã¿ æ˜å¿«å…¥é–€ã€€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ»ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å‡¦ç†ç³»ã‚’ä½œã‚ŠãªãŒã‚‰å­¦ã¶ ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ C ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° çŸ¥ã‚‰ã‚Œã–ã‚‹ C ã®æ·±å±¤ ãƒ¡ã‚¿ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° Ruby Ruby ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å®Œå…¨è§£èª¬ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª Ruby Boost C++ Libraries ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ï¼ˆç¬¬äºŒç‰ˆï¼‰ Java ã®åœ°å›³å¸³ã€€å›³è§£ãƒ»å®Ÿä¾‹ãƒ»ãƒªãƒ³ã‚¯ã§å­¦ã¶ Java ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° ã‚³ã‚¢ Java 2 åŸºç¤ç·¨ åŸºç¤ã‹ã‚‰ã® PHP ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© â€• åŸç†ãƒ»æŠ€æ³•ãƒ»ãƒ„ãƒ¼ãƒ«ï¼ˆãƒ‰ãƒ©ã‚´ãƒ³ãƒ–ãƒƒã‚¯ï¼‰ Raspberry Pi ã§å­¦ã¶ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ å‹•ã‹ã—ã¦ã‚ã‹ã‚‹ CPU ã®ä½œã‚Šæ–¹ 10 è¬› FPGA ã®åŸç†ã¨æ§‹æˆ ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«å›è·¯è¨­è¨ˆã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ [ARMç‰ˆ] ç†±è¡€ï¼ã‚¢ã‚»ãƒ³ãƒ–ãƒ©å…¥é–€ è‡ªä½œã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§å­¦ã¶ x86 ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€€å®šé‡çš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆãƒ˜ãƒãƒ‘ã‚¿ï¼‰ é‡å­ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãŒäººå·¥çŸ¥èƒ½ã‚’åŠ é€Ÿã™ã‚‹ GPU ã‚’æ”¯ãˆã‚‹æŠ€è¡“ â€• è¶…ä¸¦åˆ—ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã®å¿«é€²æ’ƒï¼»æŠ€è¡“åŸºç¤ï¼½ ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«å›è·¯è¨­è¨ˆã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ ã¯ã˜ã‚ã¦èª­ã‚€486 - 32ãƒ“ãƒƒãƒˆã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚’ã‚„ã•ã—ãèªã‚‹ æ§‹é€ åŒ–ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿æ§‹æˆï¼ˆç¬¬å››ç‰ˆï¼‰ ãƒ—ãƒ­ã‚»ãƒƒã‚µã‚’æ”¯ãˆã‚‹æŠ€è¡“ ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®æ§‹æˆã¨è¨­è¨ˆï¼ˆãƒ‘ã‚¿ãƒ˜ãƒï¼‰ ä½œã‚ŠãªãŒã‚‰å­¦ã¶ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ ä½œã£ã¦ç†è§£ã™ã‚‹ OS â€• x86 ç³»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚’å‹•ã‹ã™ç†è«–ã¨å®Ÿè£… Android ã‚’æ”¯ãˆã‚‹æŠ€è¡“ II â€• æ–°ã®ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯ã«æŒ‘ã‚“ã ãƒ¢ãƒã‚¤ãƒ« OS ã®å¿ƒè‡“éƒ¨ è©³è§£ ã‚·ã‚¹ãƒ†ãƒ ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ Windows æ–°è£…æ”¹è¨‚ç‰ˆ Linux ã®ãƒ–ãƒ¼ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚’ã¿ã‚‹ Linux ãƒ‡ãƒã‚¤ã‚¹ãƒ‰ãƒ©ã‚¤ãƒ Unix è€ƒå¤å­¦ Truth of the Legend ã‚¤ãƒ³ã‚µã‚¤ãƒ‰ Windows [è©¦ã—ã¦ç†è§£] Linux ã®ã—ãã¿ â€• å®Ÿé¨“ã¨å›³è§£ã§å­¦ã¶ OS ã¨ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã®åŸºç¤çŸ¥è­˜ Android ã‚’æ”¯ãˆã‚‹æŠ€è¡“ I - 60 fps ã‚’é”æˆã™ã‚‹ãƒ¢ãƒ€ãƒ³ãª GUI ã‚·ã‚¹ãƒ†ãƒ  Linux ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ ã¯ã˜ã‚ã¦ã® OS ã‚³ãƒ¼ãƒ‰ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚° â€• UNIX V6 ã§å­¦ã¶ã‚«ãƒ¼ãƒãƒ«ã®ã—ãã¿ ä½œã‚ŠãªãŒã‚‰å­¦ã¶ OS ã‚«ãƒ¼ãƒãƒ« â€• ä¿è­·ãƒ¢ãƒ¼ãƒ‰ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®åŸºæœ¬ã¨å®Ÿè·µ 30 æ—¥ã§ã§ãã‚‹ï¼OS è‡ªä½œå…¥é–€ Write Portable Code â€• è¤‡æ•°ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ç§»æ¤å¯èƒ½ãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®é–‹ç™ºæŠ€æ³• Linux ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° ä¾‹è§£ UNIX ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ•™å®¤ â€• ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’ä½¿ã„ã“ãªã™ãŸã‚ã® 12 è¬› ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ä»•çµ„ã¿ è©³è§£ Linux ã‚«ãƒ¼ãƒãƒ« æ§‹é€ åŒ–ä¸¦åˆ—ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° â€• åŠ¹ç‡è‰¯ã„è¨ˆç®—ã‚’è¡Œã†ãŸã‚ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ SRE ã‚µã‚¤ãƒˆãƒªãƒ©ã‚¤ã‚¢ãƒ“ãƒªãƒ†ã‚£ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚° â€• Google ã®ä¿¡é ¼æ€§ã‚’æ”¯ãˆã‚‹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãƒãƒ¼ãƒ  ãƒ“ãƒƒã‚°ãƒ‡ãƒ¼ã‚¿ã‚’æ”¯ãˆã‚‹æŠ€è¡“ â€• åˆ»ã€…ã¨ãƒ‡ãƒ¼ã‚¿ãŒè„ˆæ‰“ã¤è‡ªå‹•åŒ–ã®ä¸–ç•Œ Shared Memory Application Programming ä¸¦è¡Œã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°æŠ€æ³• â€• å®Ÿè·µãƒãƒ«ãƒã‚³ã‚¢/ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° (The Art of Concurrency) The Art of Multiprocessor Programming â€• ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®åŸç†ã‹ã‚‰å®Ÿè·µã¾ã§ Pthreads ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° Google ã‚’æ”¯ãˆã‚‹æŠ€è¡“ TCP æŠ€è¡“å…¥é–€ â€• é€²åŒ–ã‚’ç¶šã‘ã‚‹åŸºæœ¬ãƒ—ãƒ­ãƒˆã‚³ãƒ« ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã§ä½“æ„Ÿã™ã‚‹ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ä»•çµ„ã¿ â€• æ‰‹ã‚’å‹•ã‹ã—ãªãŒã‚‰åŸºç¤ã‹ã‚‰ TCP/IP ã®å®Ÿè£…ã¾ã§ãŒã‚ã‹ã‚‹ ã‚¢ã‚«ãƒã‚¤ â€• çŸ¥ã‚‰ã‚Œã–ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã®å·¨äºº UNIX ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° (Vol.2) IPC: ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡ UNIX ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° (Vol.1) ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ API: ã‚½ã‚±ãƒƒãƒˆã¨ XTI ä½“ç³»çš„ã«å­¦ã¶ å®‰å…¨ãª Web ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä½œã‚Šæ–¹ (ç¬¬ 2 ç‰ˆ) â€• è„†å¼±æ€§ãŒç”Ÿã¾ã‚Œã‚‹åŸç†ã¨å¯¾ç­–ã®å®Ÿè·µ ãƒ–ãƒ©ã‚¦ã‚¶ãƒãƒƒã‚¯ è¶…é€Ÿ! Web ãƒšãƒ¼ã‚¸é€Ÿåº¦æ”¹å–„ã‚¬ã‚¤ãƒ‰ â€• ä½¿ã„ã‚„ã™ã•ã¯ã€Œé€Ÿã•ã€ã‹ã‚‰å§‹ã¾ã‚‹ Web ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚° ãƒã‚¤ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ–ãƒ©ã‚¦ã‚¶ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚­ãƒ³ã‚° â€• ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŸã‚ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ– ã‚ã‚“ã©ã†ãã•ã„ Web ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ Ruby on Rails 3 ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° Web é–‹ç™ºè€…ã®ãŸã‚ã®å¤§è¦æ¨¡ã‚µãƒ¼ãƒ“ã‚¹æŠ€è¡“å…¥é–€ â€• ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã€ãƒ¡ãƒ¢ãƒªã€OSã€DBã€ã‚µãƒ¼ãƒ/ã‚¤ãƒ³ãƒ•ãƒ© 24 æ™‚é–“ 365 æ—¥ ã‚µãƒ¼ãƒ/ã‚¤ãƒ³ãƒ•ãƒ©ã‚’æ”¯ãˆã‚‹æŠ€è¡“ â€• ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã€ãƒã‚¤ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã€çœåŠ›é‹ç”¨ ä»•äº‹ã§ã¯ã˜ã‚ã‚‹æ©Ÿæ¢°å­¦ç¿’ ã“ã‚Œãªã‚‰ã‚ã‹ã‚‹æ·±å±¤å­¦ç¿’å…¥é–€ ã‚¼ãƒ­ã‹ã‚‰ä½œã‚‹ Deep Learning 2/3 ä½œã£ã¦å‹•ã‹ã™ ALife TensorFlow ã§ã¯ã˜ã‚ã‚‹ DeepLearning å®Ÿè£…å…¥é–€ ã¯ã˜ã‚ã¦ã®ãƒ‘ã‚¿ãƒ¼ãƒ³èªè­˜ é€²åŒ–çš„ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ â€• çµ¶ãˆé–“ãªã„å¤‰åŒ–ã‚’æ”¯ãˆã‚‹ Clean Architecture é”äººã«å­¦ã¶ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®æ§‹é€ ã¨è¨­è¨ˆ ã‚¨ãƒªãƒƒã‚¯ãƒ»ã‚¨ãƒ´ã‚¡ãƒ³ã‚¹ã®ãƒ‰ãƒ¡ã‚¤ãƒ³é§†å‹•è¨­è¨ˆ ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ API ãƒ‡ã‚¶ã‚¤ãƒ³ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ Rubyã®å®Ÿä¾‹ã‹ã‚‰å­¦ã¶ã€‚å•é¡Œã«å³ã—ãŸãƒ‡ã‚¶ã‚¤ãƒ³ã¨æ™®éã®è€ƒãˆæ–¹ ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã®ãŸã‚ã®ãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆã‚­ãƒ£ãƒªã‚¢ãƒ‘ã‚¹ â€• ãƒ†ãƒƒã‚¯ãƒªãƒ¼ãƒ‰ã‹ã‚‰ CTO ã¾ã§ãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆã‚¹ã‚­ãƒ«å‘ä¸Šã‚¬ã‚¤ãƒ‰ ã‚µã‚¤ãƒãƒ¼æ”»æ’ƒ â€• ãƒãƒƒãƒˆä¸–ç•Œã®è£å´ã§èµ·ãã¦ã„ã‚‹ã“ã¨ ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°çµ„ç¹”è«–ã¸ã®æ‹›å¾… â€• ä¸ç¢ºå®Ÿæ€§ã«å‘ãåˆã†æ€è€ƒã¨çµ„ç¹”ã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚° ãƒ—ãƒªãƒ³ã‚·ãƒ—ãƒ« ã‚ªãƒ– ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° â€• 3 å¹´ç›®ã¾ã§ã«èº«ã«ã¤ã‘ãŸã„ ä¸€ç”Ÿå½¹ç«‹ã¤ 101 ã®åŸç†åŸå‰‡ Joel on Software OSS ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®æ•™ç§‘æ›¸ ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã®çŸ¥çš„ç”Ÿç”£è¡“ â€• åŠ¹ç‡çš„ã«å­¦ã³ã€æ•´ç†ã—ã€ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆã™ã‚‹ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚³ãƒ³ãƒ†ã‚¹ãƒˆã®ãŸã‚ã® CTF å•é¡Œé›† ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚³ãƒ³ãƒ†ã‚¹ãƒˆãƒãƒ£ãƒ¬ãƒ³ã‚¸ãƒ–ãƒƒã‚¯ â€• CTF ã§å­¦ã¼ã†! æƒ…å ±ã‚’å®ˆã‚‹ãŸã‚ã®æˆ¦ã„æ–¹ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚³ãƒ³ãƒ†ã‚¹ãƒˆãƒãƒ£ãƒ¬ãƒ³ã‚¸ãƒ–ãƒƒã‚¯ ç›®æŒ‡ã›ï¼ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ä¸–ç•Œä¸€ â€• å¤§å­¦å¯¾æŠ—ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚³ãƒ³ãƒ†ã‚¹ãƒˆ ICPC ã¸ã®æŒ‘æˆ¦  èª­ã‚“ã   ã‚¯ãƒ©ã‚¦ãƒ‰ã‚’æ”¯ãˆã‚‹ã“ã‚Œã‹ã‚‰ã®æš—å·æŠ€è¡“ ãƒªãƒ¼ãƒ€ãƒ–ãƒ«ã‚³ãƒ¼ãƒ‰ã€€ã‚ˆã‚Šè‰¯ã„ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ããŸã‚ã®ã‚·ãƒ³ãƒ—ãƒ«ã§å®Ÿè·µçš„ãªãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ GitHub å®Ÿè·µå…¥é–€ â€• Pull Request ã«ã‚ˆã‚‹é–‹ç™ºã®å¤‰é© äººå·¥çŸ¥èƒ½ã¯äººé–“ã‚’è¶…ãˆã‚‹ã‹ ã‚¼ãƒ­ã‹ã‚‰ä½œã‚‹ Deep Learning Real World HTTP â€• æ­´å²ã¨ã‚³ãƒ¼ãƒ‰ã«å­¦ã¶ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã¨ã‚¦ã‚§ãƒ–æŠ€è¡“ Writing An Interpreter In Go Writing A Compiler In Go å®Ÿè·µ Rust å…¥é–€ â€• è¨€èªä»•æ§˜ã‹ã‚‰é–‹ç™ºæ‰‹æ³•ã¾ã§ Programming Rust ã™ã”ã„ Haskell ãŸã®ã—ãå­¦ã¼ã†ï¼ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª Go Go ãªã‚‰ã‚ã‹ã‚‹ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚·ã‚¹ãƒ†ãƒ ã®ç†è«–ã¨å®Ÿè£… Go è¨€èªã«ã‚ˆã‚‹ä¸¦è¡Œå‡¦ç† Distributed Systems: Principles and Paradigms (2nd Edition) Computer Networking: A Top-Down Approach (4th Edition) ãµã¤ã†ã® Linux ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° (ç¬¬ 2 ç‰ˆ) â€• Linux ã®ä»•çµ„ã¿ã‹ã‚‰å­¦ã¹ã‚‹ gcc ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ç‹é“ Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems Cracking the Coding Interview: 189 Programming Questions and Solutions  ","date":1574693821,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1574693821,"objectID":"745e7f09618fcaaee4cd2fca60ef29e7","permalink":"/ja/post/book-shelf/","publishdate":"2019-11-25T23:57:01+09:00","relpermalink":"/ja/post/book-shelf/","section":"post","summary":"èª­ã¿ãŸã„ ï¼»æ”¹è¨‚æ–°ç‰ˆï¼½ãƒ—ãƒ­ã‚°ãƒ©ãƒã®ãŸã‚ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰æŠ€è¡“å…¥é–€ ã¿ã‚“ãªã®ãƒ‡ãƒ¼ã‚¿æ§‹é€  ãƒ—ãƒ­ã‚°ãƒ©ãƒã®æ•°å­¦ ç¬¬2ç‰ˆ ç´”ç²‹é–¢æ•°å‹ãƒ‡ãƒ¼ã‚¿æ§‹é€  Understanding Compression å‹ã‚·ã‚¹ãƒ†ãƒ å…¥é–€ â€• ãƒ—ãƒ­","tags":["book shelf"],"title":"Book Shelf","type":"post"},{"authors":[],"categories":[],"content":"Golangã§ã‚ˆãè¦‹ã‹ã‘ã‚‹æ§‹é€ ä½“å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ ã‚ˆãè¦‹ã‹ã‘ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã¾ã¨ã‚ã¦ã¿ãŸï¼\nã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã—ã¦ã®NewXXXX() æ§‹é€ ä½“ã®åˆæœŸåŒ–ã¨ç”Ÿæˆã«ä½¿ã†ãƒ‘ã‚¿ãƒ¼ãƒ³\n  ğŸ‘ æ§‹é€ ä½“ã®ç”Ÿæˆã¨åˆæœŸåŒ–ã®å†…éƒ¨å®Ÿè£…ã‚’åˆ©ç”¨è€…ã«è¦‹ã›ãªã„ ğŸ‘ æ§‹é€ ä½“ãã®ã‚‚ã®ã®æ§‹é€ ã‚’åˆ©ç”¨è€…ã«è¦‹ã›ãªã„  ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦å¤–éƒ¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ã‚’åˆ©ç”¨ã—ãŸã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ ã€Œæ§‹é€ ä½“åã®å…ˆé ­ã‚’å¤§æ–‡å­—ã«ã™ã‚‹ã“ã¨ã§å¤–éƒ¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã™ã‚‹ã€ã¨ã„ã†Golangã®ç‰¹å¾´ã‚’ç”Ÿã‹ã—ã¦ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚’ç”Ÿæˆã§ãã‚‹ï¼\npackage singleton // æ§‹é€ ä½“è‡ªä½“ã‚’å¤–éƒ¨ã«å…¬é–‹ã—ãªã„ type singleton struct { } // æ§‹é€ ä½“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä¿æŒã™ã‚‹å¤‰æ•°ã‚‚å¤–éƒ¨ã«å…¬é–‹ã—ãªã„ var instance *singleton // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã®ã¿ã‚’å¤–éƒ¨ã«å…¬é–‹ func GetInstance() *singleton { if instance == nil { instance = \u0026amp;singleton{} } return instance } interfaceã§ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ  Golangã«ã¯ã€Œå‹ã®ç¶™æ‰¿ã€ãŒãªã„ï¼ä¸€æ–¹ã§ï¼Œinterfaceã‚’ç”¨ã„ã‚‹ã“ã¨ã§ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã‚’å®Ÿç¾ã§ãã‚‹ï¼interfaceã«ã‚ˆã£ã¦æŒ¯ã‚‹èˆã„ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ï¼Œã€ŒåŒã˜ã‚ˆã†ãªæŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹ã‚‚ã®ã€ã‚’ã¾ã¨ã‚ã¦æ‰±ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ï¼\n æ§‹é€ ä½“ã®åŸ‹ã‚è¾¼ã¿ã«ã‚ˆã‚‹ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ  ã‚ã‚‹æ§‹é€ ä½“ã«å¯¾ã—ã¦ï¼Œç‰¹å®šã®æŒ¯ã‚‹èˆã„ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹æ§‹é€ ä½“ã‚’åŸ‹ã‚è¾¼ã‚€ã“ã¨ã§ï¼Œãã®æ§‹é€ ä½“ã‚‚ã€ŒåŸ‹ã‚è¾¼ã¾ã‚ŒãŸæ§‹é€ ä½“ã¨åŒæ§˜ãªæŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹ã‚‚ã®ã€ã¨ã—ã¦æ‰±ã†ã“ã¨ãŒã§ãã‚‹ï¼ãŸã ï¼Œã“ã‚Œã‚’ã‚„ã‚‹ã¨æ§‹é€ ä½“ã®åˆæœŸåŒ–æ™‚ã«æ§‹é€ ä½“ã®å†…éƒ¨ã‚’æ„è­˜ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ï¼ŒåˆæœŸåŒ–ã®ãŸã‚ã®NewXXXX()ã‚’ç”¨æ„ã—ã¦ã‚ã’ã‚‹ã¨è‰¯ã„ï¼\n åŸ‹ã‚è¾¼ã¾ã‚ŒãŸæ§‹é€ ä½“ãŒä¸Šä½ã®æ§‹é€ ä½“ã®é–¢æ•°ã‚’ä½¿ã† ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã§ã¯ã€Œå­ã‚¯ãƒ©ã‚¹ãŒè¦ªã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç”¨ã„ã‚‹ã“ã¨ã€ãŒã§ãã‚‹ãŒï¼ŒGolangã§ã‚‚ã§ããªã„ã“ã¨ã¯ãªã„ï¼\n æ§‹é€ ä½“ã«ã‚ˆã‚‹å‡¦ç†ã®ç§»è­² æ§‹é€ ä½“ã®ãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦ï¼Œç‰¹å®šã®å‡¦ç†ã«å¯¾ã—ã¦è²¬ä»»ã‚’æŒã¤æ§‹é€ ä½“ã‚’æŒã¤ã“ã¨ã§ï¼Œå‡¦ç†ã®ç§»è­²ã‚’å®Ÿç¾ã§ãã‚‹ï¼\n é–¢æ•°ã«ã‚ˆã‚‹å‡¦ç†ã®ç§»è­² Golangã§ã¯é–¢æ•°ã¯ç¬¬1ç´šå¸‚æ°‘ãªã®ã§å€¤ã¨ã—ã¦æ‰±ã†ã“ã¨ãŒã§ãã‚‹ï¼å‡¦ç†ã‚’å®šç¾©ã—ãŸé–¢æ•°ã‚’ã‚„ã‚Šã¨ã‚Šã™ã‚‹ã“ã¨ã§å‡¦ç†ã‚’ç§»è­²ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\n ","date":1573711075,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1573711075,"objectID":"fa774c736aab16ca1698d6384c703d4a","permalink":"/ja/post/golang-structure-implementation-patterns/","publishdate":"2019-11-14T14:57:55+09:00","relpermalink":"/ja/post/golang-structure-implementation-patterns/","section":"post","summary":"Golangã§ã‚ˆãè¦‹ã‹ã‘ã‚‹æ§‹é€ ä½“å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ ã‚ˆãè¦‹ã‹ã‘ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã¾ã¨ã‚ã¦ã¿ãŸï¼ ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã—ã¦ã®NewXXXX() æ§‹é€ ä½“ã®åˆæœŸåŒ–ã¨ç”Ÿæˆ","tags":["Golang","Implementation Pattern"],"title":"Golangã§ã‚ˆãè¦‹ã‹ã‘ã‚‹æ§‹é€ ä½“å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³","type":"post"},{"authors":[],"categories":[],"content":"ãƒ‡ãƒ¼ã‚¿ã®serialization/deserialization ã‚¤ãƒãƒ‰ã‚­ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯ï¼Œæ©Ÿèƒ½ã”ã¨ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ•´ç†æ•´é “ã—ã¦ï¼Œãã‚Œã‚‰ãŒæƒ…å ±ã‚’ã‚„ã‚Šã¨ã‚Šã—ãªãŒã‚‰ã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›ã—ã¾ã™ï¼ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹æˆã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–“ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ã‚’ã—ãªã‘ã‚Œã°ãªã‚‰ãšï¼Œãã®éš›ã«ã‚„ã‚Šã¨ã‚Šã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã€Œã©ã†ã„ã†è¡¨ç¾ã§ã‚ã‚‹ã®ã‹ã€ã«ã¤ã„ã¦å…±æœ‰ã—ã¦ãŠã‹ãªã„ã¨ã„ã‘ã¾ã›ã‚“ï¼äººé–“ã®ä¼šè©±ã§è¨€ã†ãªã‚‰ã°ã€Œä½•èªã‚’å–‹ã‚‹ã‹ã€ã«è¿‘ã„ã®ã‹ãªï¼\nã€Œã©ã‚“ãªå½¢å¼ã§ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹ã‹ã€ã«ã¤ã„ã¦ã¯ã„ãã¤ã‹ã®å½¢å¼ãŒææ¡ˆã•ã‚Œã¦ã„ã¦ï¼Œãã‚Œãã‚Œã«ã¤ã„ã¦ä¸€é•·ä¸€çŸ­ãŒã‚ã‚‹ï¼ä»£è¡¨çš„ãªã®ã¯XMLï¼ŒJSONï¼ŒBSONï¼ŒProtocol Buffersï¼ŒFlatBuffersï¼ä»–ã«ã‚‚ã„ã‚ã„ã‚ã‚ã‚Šã¾ã™ï¼\nXML XMLã¨ã¯ã€ŒeXtended Markdown Languageã€ã®ç•¥ã§ï¼Œæ–‡ç« ã®é›»å­åŒ–ã«æºæµãŒã‚ã‚‹ãƒ‡ãƒ¼ã‚¿å½¢å¼ï¼å‰æã«ã€Œæ–‡ç« ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ã€ãŒã‚ã‚‹ã®ã§ï¼ŒXMLã®ä»•æ§˜ã«ã¯ãƒ‡ãƒ¼ã‚¿ã®ã€Œå‹ã€ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;breakfast_menu\u0026gt; \u0026lt;food\u0026gt; \u0026lt;name\u0026gt;Belgian Waffles\u0026lt;/name\u0026gt; \u0026lt;price\u0026gt;$5.95\u0026lt;/price\u0026gt; \u0026lt;description\u0026gt; Two of our famous Belgian Waffles with plenty of real maple syrup \u0026lt;/description\u0026gt; \u0026lt;calories\u0026gt;650\u0026lt;/calories\u0026gt; \u0026lt;/food\u0026gt; \u0026lt;food\u0026gt; \u0026lt;name\u0026gt;Strawberry Belgian Waffles\u0026lt;/name\u0026gt; \u0026lt;price\u0026gt;$7.95\u0026lt;/price\u0026gt; \u0026lt;description\u0026gt; Light Belgian waffles covered with strawberries and whipped cream \u0026lt;/description\u0026gt; \u0026lt;calories\u0026gt;900\u0026lt;/calories\u0026gt; \u0026lt;/food\u0026gt; \u0026lt;/breakfast_menu\u0026gt; XMLã¯æ–‡ç« ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–ãŒå‰æã«ã‚ã‚‹ã®ã§ï¼ŒHTMLã¿ãŸã„ãªè¦‹ãŸç›®ã«ãªã£ã¦ã„ã¾ã™ï¼\nXMLã®ç‰¹å¾´ã¨ã—ã¦ã€ŒXMLã¯self-describingã§ã‚ã‚‹ã€ã¨è©•ã•ã‚Œã‚‹ã“ã¨ãŒå¤šãã‚ã‚Šã¾ã™ï¼ã“ã‚Œã¯ã€Œãƒ‡ãƒ¼ã‚¿è‡ªä½“ã®æ§‹é€ ãŒãƒ‡ãƒ¼ã‚¿ãã®ã‚‚ã®ã«è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã§ã™ï¼ã¤ã¾ã‚Šäº‹å‰ã«é€šä¿¡ã®ä¸¡ç«¯ã§ã‚„ã‚Šå–ã‚Šã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®æ–¹ã«ã¤ã„ã¦ã®åˆæ„ã‚’ã¨ã£ã¦ã„ãªãã¦ã‚‚ï¼ˆã‚„ã‚Šå–ã‚Šã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’çœºã‚ã‚Œã°ï¼‰ãƒ‡ãƒ¼ã‚¿ã®é½Ÿé½¬ã®ãªã„è§£é‡ˆãŒå¯èƒ½ã§ã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ï¼JSONã ã¨ã“ã‚Œã¯ã§ãã¾ã›ã‚“ï¼XMLã¯ã‚¿ã‚°ã ã‘ã‚’ã¿ã‚‹ã“ã¨ã§ï¼Œãã®ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ ã‚’å³åº§ã«èª­ã¿å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼JSONã§ã¯ï¼Œã‚¿ã‚°ã«ç›¸å½“ã™ã‚‹ã‚‚ã®ã‚’ãƒãƒƒã‚·ãƒ¥ã®ã‚­ãƒ¼ã¨ã—ã¦è¡¨ç¾ã™ã‚Œã°ã§ããªã„ã‚ã‘ã§ã¯ãªã„ãŒï¼Œãã‚Œã¯ãƒ‡ãƒ¼ã‚¿ã®å‹ã‚’è¡¨ç¾ã—ãŸã‚ã‘ã§ã¯ãªãã¦ï¼Œãƒãƒƒã‚·ãƒ¥ã‚’ç”¨ã„ã¦ä¼¼ãŸã‚ˆã†ãªãƒ‡ãƒ¼ã‚¿å‹ã‚’è¡¨ç¾ã—ãŸã ã‘ã§ã™ï¼\nXMLã§è¨˜è¿°ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã¯ãã‚Œè‡ªèº«ã®ãƒ¡ã‚¿ãªæ§‹é€ ã‚’ã‚‚è¡¨ç¾ã—ã¦ã„ã‚‹ã¨ã„ã†ç‚¹ãŒåˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ã‚„ã‚Šå–ã‚Šã§éå¸¸ã«æœ‰ç”¨ãªã®ã§ï¼Œå¤ãã‹ã‚‰ã‚ˆãä½¿ã‚ã‚Œã¦ã„ã¾ã™ï¼\nJSON JSONã¨ã¯ã€ŒJavaScript Object Notationã€ã®ç•¥ï¼JSONã‚’ã‚·ã‚¹ãƒ†ãƒ é–“ã®ãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¾å½¢å¼ã¨ã—ã¦ç”¨ã„ã‚‹ã¨ã€ŒJavaScriptã§ã®ãƒ‡ãƒ¼ã‚¿ã®ãƒªãƒ†ãƒ©ãƒ«ãªè¡¨ç¾ã‚’ãã®ã¾ã¾ã‚·ã‚¹ãƒ†ãƒ é–“ã®ãƒ‡ãƒ¼ã‚¿è¡¨ç¾å½¢å¼ã€ã¨ã—ã¦ç”¨ã„ã‚‹ã“ã¨ã«ãªã£ã¦ï¼Œwebãªä¸–ç•Œã ã¨JavaScriptã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã§ãã®ã¾ã¾å‡¦ç†ã§ãã‚‹ã®ã§æ‰±ã„ã‚„ã™ãã¦ã‚ˆãç”¨ã„ã‚‰ã‚ŒãŒã¡ï¼ã—ã‹ã‚‚ï¼ŒJSONã¯äººé–“ã«ã¨ã£ã¦ã‚‚ãƒ‘ãƒƒã¨è¦‹ã§ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ ãŒæŠŠæ¡ã—ã‚„ã™ãã¦äººæ°—ãŒå‡ºã¾ã—ãŸï¼ãã‚Œãªã‚Šã«å¤å‚ãªãƒ‡ãƒ¼ã‚¿å½¢å¼ã§ã™ãŒï¼Œç¾åœ¨ã‚‚ãƒãƒªãƒãƒªã®ç¾å½¹ã§ã™ï¼è¦–èªæ€§ãŒè‰¯ã„ã®ãŒã‚„ã£ã±ã‚Šäººæ°—ã®ç†ç”±ãªã‚“ã§ã™ã‹ã­ï¼ãƒ‡ãƒãƒƒã‚°ã—ã‚„ã™ã„ã—ï¼\nJSONã¯ã€Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ãƒªãƒ†ãƒ©ãƒ«è¡¨ç¾ã€ãŒå‡ºæ‰€ãªã®ã§ï¼Œä»•æ§˜ã¨ã—ã¦ã€Œå‹ã€ãŒå«ã¾ã‚Œã¦ã„ã¦ï¼Œæ‰±ã„ã‚„ã™ã„ã§ã™ï¼ã€Œå‹ã€ãŒä»•æ§˜ã¨ã—ã¦å­˜åœ¨ã—ã¦ã„ã‚‹ã®ã§ã€Œç©ºã®å€¤ã€ã‚’å‹ã”ã¨ã«åŒºåˆ¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼\n{ \u0026#34;null\u0026#34;: null, \u0026#34;string\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;array\u0026#34;: [], \u0026#34;dict\u0026#34;: {} } JSONã¯ï¼Œã“ã‚“ãªã«ã‚·ã‚¹ãƒ†ãƒ é–“ã§æƒ…å ±ã‚’ã‚„ã‚Šã¨ã‚Šã™ã‚‹éš›ã®ãƒ‡ãƒ¼ã‚¿å½¢å¼ã¨ã—ã¦ç”¨ã„ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã“ã¨ã‚’å…¨ç„¶æƒ³å®šã—ã¦ã„ãªã‹ã£ãŸã®ã§ï¼Œæ‰±ã„ã¥ã‚‰ã•ãŒã‚ã£ãŸã‚Šã™ã‚‹ã‚‰ã—ã„ï¼åƒ•ã¯å…·ä½“çš„ã«è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ããªã„ãŒã€Œå¤è‡­ã„ã€ãªã‚“ã¦è¨€ã‚ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ï¼\nã€Œã©ã†ã„ã†ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã£ãŸJSONãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†ã®ã‹ã€ã«ã¤ã„ã¦é€šä¿¡ã®ä¸¡ç«¯ç‚¹ã§åˆæ„ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹ã®ã¯ã‚‚ã¡ã‚ã‚“ã§ã™ãŒï¼ŒJSONã®ãƒ‡ãƒ¼ã‚¿å½¢å¼ã¯ã‚¹ã‚­ãƒ¼ãƒã‚’ç›´æ¥çš„ã«è¡¨ç¾ã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ï¼ˆã¤ã¾ã‚Šã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’JSONãŒè¦å®šã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ï¼‰ã¨ã„ã†èªè­˜ã‚‚å¤§äº‹ã ã¨æ€ã„ã¾ã™ï¼ãã®ã¾ã¾ã®JSONã¯ãŸã ã®ãƒ‡ãƒ¼ã‚¿å½¢å¼ã«éããªãã¦ï¼Œã‚¹ã‚­ãƒ¼ãƒè¨€èªã¨ã—ã¦ã®ã€Œãƒ‡ãƒ¼ã‚¿å‹ã‚’å®šç¾©ã™ã‚‹ã€ã¨ã„ã†ãƒ¡ã‚¿ãªæ©Ÿèƒ½ã¯ãªã„ã¨ã„ã†ã“ã¨ã§ã™ï¼\nJSONãªã©ã§ã‚‚ã€ŒJSONã§JSONã®ã‚¹ã‚­ãƒ¼ãƒã‚’æ›¸ã„ã¦ã—ã¾ãŠã†ã€ã¨ã„ã†JSON Schemaãªã‚‹ã‚‚ã®ãŒå­˜åœ¨ã—ã¦ã„ã‚‹ãã†ã§ã™ãŒï¼Œã‚„ã£ã±ã‚Šã ã„ã¶æ›¸ãã«ããã†ã§ã™ï¼\n{ \u0026#34;productId\u0026#34;: 1, \u0026#34;productName\u0026#34;: \u0026#34;An ice sculpture\u0026#34;, \u0026#34;price\u0026#34;: 12.50, \u0026#34;tags\u0026#34;: [ \u0026#34;cold\u0026#34;, \u0026#34;ice\u0026#34; ], \u0026#34;dimensions\u0026#34;: { \u0026#34;length\u0026#34;: 7.0, \u0026#34;width\u0026#34;: 12.0, \u0026#34;height\u0026#34;: 9.5 }, \u0026#34;warehouseLocation\u0026#34;: { \u0026#34;latitude\u0026#34;: -78.75, \u0026#34;longitude\u0026#34;: 20.4 } } ã¨ã„ã†ã‚¹ã‚­ãƒ¼ãƒã‚’JSONã§æ›¸ãã¨\n{ \u0026#34;$schema\u0026#34;: \u0026#34;http://json-schema.org/draft-07/schema#\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;http://example.com/product.schema.json\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Product\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A product from Acme\u0026#39;s catalog\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;productId\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;The unique identifier for a product\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;productName\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Name of the product\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;price\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;The price of the product\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;exclusiveMinimum\u0026#34;: 0 }, \u0026#34;tags\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Tags for the product\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;minItems\u0026#34;: 1, \u0026#34;uniqueItems\u0026#34;: true }, \u0026#34;dimensions\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;length\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;width\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;height\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;length\u0026#34;, \u0026#34;width\u0026#34;, \u0026#34;height\u0026#34; ] }, \u0026#34;warehouseLocation\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Coordinates of the warehouse where the product is located.\u0026#34;, \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/geographical-location.schema.json\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;productId\u0026#34;, \u0026#34;productName\u0026#34;, \u0026#34;price\u0026#34; ] } ğŸ¤” ï¾ï½®ï½¯ï¾„ï¾ï¾†ï½¸ï½²\u0026hellip;\nBSON JSONã¯ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ï¼ˆã¤ã¾ã‚Šã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºãƒ»ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã®éš›ã«æ‰±ã‚ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã®å˜ä½ãŒbitã˜ã‚ƒãªãã¦byteï¼‰ã§ã—ãŸãŒï¼Œãã‚Œã‚’æ”¹ã‚ãŸBSON = Binary JSONã¨ã„ã†ã®ã‚‚å­˜åœ¨ã—ã¾ã™ï¼ã¤ã¾ã‚ŠBSONã§ã¯ãƒ‡ãƒ¼ã‚¿ãŒãƒã‚¤ãƒŠãƒªãƒ™ãƒ¼ã‚¹ï¼ˆã¤ã¾ã‚Šã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºãƒ»ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã®éš›ã«æ‰±ã‚ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã®å¤§ãã•ã®å˜ä½ãŒbitï¼‰ã«ãªã£ã¦ã„ã¾ã™ï¼BSONã¯å¾Œè¿°ã™ã‚‹Protocol Buffersã¨ã‚ˆãä¼¼ã¦ã„ã¦ï¼Œåº¦ã€…æ¯”è¼ƒã•ã‚Œã¦ã„ã¾ã™ï¼å…¬å¼ã«ã‚ˆã‚‹ã¨ï¼Œ\n Lightweight\n KeepÂ­ing spaÂ­tial overÂ­head to a minÂ­imÂ­um is imÂ­portÂ­ant for any data repÂ­resÂ­entÂ­aÂ­tion format, esÂ­peÂ­cially when used over the netÂ­work.  Traversable\n BSON is deÂ­signed to be traÂ­versed easÂ­ily. This is a viÂ­tal propÂ­erty in its role as the primary data repÂ­resÂ­entÂ­aÂ­tion for MonÂ­goDB.  Efficient\n EnÂ­codÂ­ing data to BSON and deÂ­codÂ­ing from BSON can be perÂ­formed very quickly in most lanÂ­guages due to the use of C data types.   ã¨ã„ã†ç‰¹å¾´ãŒã‚ã‚Šã¾ã™ï¼\nBSONã¯ï¼ŒProtocol Buffersã¨æ¯”è¼ƒã—ã¦\n more \u0026ldquo;schema-less\u0026rdquo;\n ã§ã‚ã‚‹ã¨ã•ã‚Œã¦ã„ã¾ã™ï¼ã¤ã¾ã‚Šï¼Œã‚µãƒ¼ãƒ“ã‚¹é–“ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®ä»•æ§˜ãã®ã‚‚ã®ã¨ã‚„ã‚Šã¨ã‚Šã™ã‚‹ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®é–¢ä¿‚æ€§ãŒï¼ˆProtocol Buffersã¨æ¯”è¼ƒã—ã¦ï¼‰ç–ã§ï¼Œã‚ˆã‚ŠæŸ”è»Ÿæ€§ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ï¼ä¸€æ–¹ã§ï¼ŒBSONã¯Protocol Buffersã¨æ¯”ã¹ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã«é–¢ã—ã¦ã‚„ã‚„å†—é•·ã§ã‚ã‚‹ã¨ã•ã‚Œã¦ã„ã¾ã™ï¼\nMongoDBãŒBSONã‚’ãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¾æ–¹å¼ã¨ã—ã¦æ¡ç”¨ã—ã¦ã„ã‚‹ã®ãŒèˆˆå‘³æ·±ã„ã§ã™ã­ï¼å¤šãã®ä¸»è¦è¨€èªã§BSONã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ãƒ»ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå®Ÿè£…ã•ã‚Œã¦ã„ã¦æ‰‹è»½ã«ä½¿ãˆãã†ãªå°è±¡ã§ã™ï¼ãŸã ï¼Œãƒã‚¤ãƒŠãƒªãƒ™ãƒ¼ã‚¹ã¨ã„ã†ã“ã¨ã‚‚ã‚ã£ã¦ï¼ŒBSONã‚’ãã®ã¾ã¾çœºã‚ã¦ã‚‚äººé–“ã«ã¯æ„å‘³ãŒã‚ã‹ã‚‰ãªã„ã®ã§ï¼Œãƒ‡ãƒãƒƒã‚°ã¯ã¡ã‚‡ã£ã¨å¤§å¤‰ãªã®ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã­ï¼\nä¾‹ãˆã°{\u0026quot;hello\u0026quot;: \u0026quot;world\u0026quot;}ã‚’BSONã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼\n \\x16\\x00\\x00\\x00 // total document size \\x02 // 0x02 = type String hello\\x00 // field name \\x06\\x00\\x00\\x00world\\x00 // field value \\x00 // 0x00 = type EOO ('end of object') Protocol Buffers Protocol Buffersã¯GoogleãŒç¤¾å†…ã®ã‚·ã‚¹ãƒ†ãƒ é–“ã§æƒ…å ±ã‚’ã‚„ã‚Šã¨ã‚Šã™ã‚‹éš›ã«ç”¨ã„ã¦ã„ãŸãƒ‡ãƒ¼ã‚¿å½¢å¼ã§2008å¹´ã«ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹åŒ–ã•ã‚Œã¾ã—ãŸï¼GoogleãŒå‡ºã—ã¦ã„ã‚‹å…¬å¼ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ˆã‚Œã°\n Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data â€“ think XML, but smaller, faster, and simpler.\n ã¨ã„ã†ã“ã¨ã‚‰ã—ã„ã§ã™ï¼Protocol Buffersã¯ã‚·ã‚¹ãƒ†ãƒ é–“ã§æƒ…å ±ã‚’ã‚„ã‚Šã¨ã‚Šã™ã‚‹éš›ã«ç”¨ã„ã‚‹ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®ä¸€ç¨®ãªã‚“ã§ã™ãŒï¼Œãã‚Œã¯å˜˜ã˜ã‚ƒãªã„ã‚“ã§ã™ã‘ã©ï¼ŒProtocol Buffersã®æŒ‡ã™æ„å‘³ç¯„å›²ã¯ãã‚Œã ã‘ã«ã¨ã©ã¾ã‚‰ãšï¼Œã‚µãƒ¼ãƒ“ã‚¹é–“ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã™ã‚‹ã‚¹ã‚­ãƒ¼ãƒè¨€èªã¨ã—ã¦ã®é¡”ã‚‚ã‚ã‚‹ã®ãŒç‰¹å¾´ã§ã™ï¼ã‚‚ã£ã¨ã„ã†ã¨ï¼Œã“ã®ã‚¹ã‚­ãƒ¼ãƒè¨€èªãŒå„ªç§€ã§ã‚ã‚‹ã¨ã„ã†ã®ãŒProtocol Buffersã®äººæ°—ã‚’å¤§ããæ”¯ãˆã¦ã„ã‚‹ç†ç”±ãªã®ã ã¨æ€ã„ã¾ã™ï¼ã€ŒProtocol BuffersãŒã‚¹ã‚­ãƒ¼ãƒè¨€èªã§ã‚ã‚‹ã€ã¨ã„ã†ã®ã¯ã©ã†ã„ã†ã“ã¨ã‹ã¨ã„ã†ã¨ï¼ŒProtocol Buffersã§ã¯ã€Œã‚·ã‚¹ãƒ†ãƒ ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆã¤ã¾ã‚Šï¼Œã©ã‚“ãªå‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚„ã‚Šã¨ã‚Šã™ã‚‹ã®ã‹ï¼‰ã‚’å®šç¾©ã™ã‚‹ç‹¬è‡ªè¨€èªã€ã§ã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ï¼\nsyntax = \u0026#34;proto3\u0026#34;;package example.protobuf;message SimpleMessage {\tmessage HeaderItem {\tstring name = 1;\tstring value = 2;\t}\tenum Type {\tSTART = 0;\tBLOB = 1;\tEND = 2;\t}\tuint64 id = 1;\tType message_type = 2;\trepeated HeaderItem headers = 3;\tbytes blob = 4; }Protocol Buffersã¯ï¼Œã‚µãƒ¼ãƒ“ã‚¹é–“ã§ã‚„ã‚Šã¨ã‚Šã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®å‹ã‚’è¡¨ç¾ã™ã‚‹ç‹¬è‡ªè¨€èªã¨ã¨ã‚‚ã«ï¼Œãã®ç‹¬è‡ªè¨€èªã§è¨˜è¿°ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ç‰¹å®šã®è¨€èªã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã¾ã§ã‚‚ãŒåŒæ¢±ã•ã‚Œã¦ã„ã¾ã™ï¼\nã‚¹ã‚­ãƒ¼ãƒè¨€èªãŒå­˜åœ¨ã™ã‚‹ã¨ï¼Œéå¸¸ã«ä¾¿åˆ©ã§ã™ï¼ãƒ¢ãƒ€ãƒ³ãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ï¼Œã„ã‚ã‚“ãªã¨ã“ã‚ã«ãƒ‡ãƒ¼ã‚¿ãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã—ï¼Œãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§å‹•ã„ã¦ã„ã‚‹ã‚µãƒ¼ãƒãƒ¼ã‚‚ã„ãã¤ã‹ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã—ï¼Œã‚‚ã¯ã‚„ãã‚ŒãŒæ™®é€šã«ãªã£ã¦ãã¦ã„ã¾ã™ï¼ã¨ãªã‚‹ã¨ï¼Œã‚·ã‚¹ãƒ†ãƒ ã®ä¸­ã®ã‚ã‚Šã¨ã‚ã‚‰ã‚†ã‚‹å ´æ‰€ã§ãƒ‡ãƒ¼ã‚¿ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºãƒ»ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã‚’ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã—ï¼Œé€šä¿¡ã—ã¦ã„ã‚‹ä¸¡è€…ã§ãƒ‡ãƒ¼ã‚¿ã®è§£é‡ˆã«çŸ›ç›¾ãŒç™ºç”Ÿã—ãªã„ã‚ˆã†ã«æ•´ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼ã‚¹ã‚­ãƒ¼ãƒè¨€èªãŒã‚ã‚‹ã¨ï¼Œã“ã®ã€Œæ•´ãˆã‚‹ä½œæ¥­ã€ãŒã¨ã¦ã‚‚ã‚„ã‚Šã‚„ã™ããªã‚Šã¾ã™ï¼è‡ªç„¶è¨€èªã¨é•ã£ã¦ï¼Œã‚¹ã‚­ãƒ¼ãƒè¨€èªã§ã¯è§£é‡ˆã«å·®ç•°ãŒç™ºç”Ÿã—ãªã„ã‹ã‚‰ã§ã™ï¼ã€Œç®¡ç†è€…ãŒä¸€äººã€ã¿ãŸã„ãªã‚·ã‚¹ãƒ†ãƒ ã§ã¯ï¼Œã‚¹ã‚­ãƒ¼ãƒè¨€èªãªã‚“ã¦ãŸã„ãã†ãªã‚‚ã®ã‚’æŒã¡å‡ºã—ã¦ãã‚‹å¿…è¦ã¯ãªã„ã¨æ€ã†ã‚“ã§ã™ã‘ã©ï¼Œwebã¿ãŸã„ãªè‡ªå¾‹åˆ†æ•£çš„ãªç³»ã ã¨ï¼Œã¾ã™ã¾ã™ã‚¹ã‚­ãƒ¼ãƒè¨€èªã¨ã—ã¦ã®Protocol Buffersã®è‰¯ã•ãŒéš›ç«‹ã£ã¦ãã‚‹ã‚ã‘ã§ã™ï¼\nProtocol Buffersã®ã‚¹ã‚­ãƒ¼ãƒè¨€èªã¨ã—ã¦ã®è‰¯ã•ã¯ï¼Œãã®ç°¡æ½”ã•ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ï¼ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãäººé–“ã«ã¨ã£ã¦ã¯ï¼Œç‰¹ã«é›£ã—ã„ã“ã¨ã‚’è€ƒãˆãšã«æ„å›³ãŒæ±²ã¿å–ã‚Œã‚‹ç¨‹åº¦ã®æ±ºã¾ã‚Šã”ã¨ã—ã‹ãªã„ã—ï¼Œã‚¹ã‚­ãƒ¼ãƒè¨€èªã¨ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã‹ã‚‰ç‹¬ç«‹ã—ã¦ã„ã‚‹ç‚¹ã‚‚ï¼Œãƒ„ãƒ¼ãƒ«ã®ä½œã‚Šã‚„ã™ã•ã¨ã‹ã«å½±éŸ¿ã—ã¦ã„ã¦ï¼ŒProtocol BuffersãŒäººæ°—ãªç†ç”±ãªã‚“ã ã¨æ€ã„ã¾ã™ï¼\nProtocol Buffersã§ã¯ï¼Œ.protoãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’è¨˜è¿°ã—ã¾ã™ï¼\nmessage Person {\trequired string name = 1;\trequired int32 id = 2;\toptional string email = 3;\tenum PhoneType {\tMOBILE = 0;\tHOME = 1;\tWORK = 2;\t}\tmessage PhoneNumber {\trequired string number = 1;\toptional PhoneType type = 2 [default = HOME];\t}\trepeated PhoneNumber phone = 4;}æ˜ç¢ºãªã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦é©åˆ‡ã«æ‰€æœ›ã®è¨€èªã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«å¤‰æ›ã—ã¦ãã‚Œã‚‹ã®ã§ï¼Œé–‹ç™ºã‚’é€²ã‚ã‚„ã™ããªã‚Šã¾ã™ï¼\nProtocol Buffersã§ã¯ã‚µãƒ¼ãƒ“ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã®å¤‰æ›´ã«å¯¾ã—ã¦å¾Œæ–¹äº’æ›æ€§ã‚’ç¶­æŒã—ãŸå½¢ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚„ã‚Šå–ã‚Šã‚’ã§ãã‚‹ã‚ˆã†ã«ã€ŒæœªçŸ¥ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«é­é‡ã—ãŸã‚‰ç„¡è¦–ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã«ãªã£ã¦ã„ã¾ã™ï¼ã“ã†ã™ã‚Œã°ï¼Œã‚µãƒ¼ãƒ“ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ãŒæ›´æ–°ã•ã‚ŒãŸã¨ã—ã¦ã‚‚ï¼Œæ—¢å­˜ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯å‹•ãã“ã¨ã«ã¯å‹•ãã“ã¨ã«ãªã‚Šã¾ã™ï¼\nProtocol Buffersã®å…¬å¼ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ï¼ŒXMLã¨æ¯”è¼ƒã—ã¦\n Protocol buffers\n are simpler are 3 to 10 times smaller are 20 to 100 times faster are less ambiguous generate data access classes that are easier to use programmatically   ã¨ä¸»å¼µã—ã¦ã„ã¾ã™ï¼ç¢ºã‹ã«XMLã¯ã„ã¡ã„ã¡ã‚¿ã‚°ã§æ‹¬ã‚‰ãªãã‚ƒã„ã‘ãªã„ã—Protocol Buffersã¯åŠ¹ç‡ãŒè‰¯ã•ãã†ã§ã™ï¼\nProtocol Buffersã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã¯ãƒã‚¤ãƒŠãƒªãƒ™ãƒ¼ã‚¹ã§ã™ï¼äººé–“ãŒçœºã‚ã¦æ§‹é€ ãŒå–ã‚Œã‚‹ã‚ˆã†ãªè¦‹ãŸç›®ã«ã¯ãªã£ã¦ã„ã¾ã›ã‚“ï¼ã—ã‹ã—Protocol Buffersã¯ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¨ã—ã¦æ§˜ã€…ãªå½¢å¼ï¼ˆä¾‹ãˆã°JSONãªã©ï¼‰ã‚‚æ‰±ãˆã‚‹ã‚ˆã†ã«å‘¨è¾ºãƒ„ãƒ¼ãƒ«ãŒå……å®Ÿã—ã¦ã„ã‚‹ã®ã§ï¼Œã€Œã‚¹ã‚­ãƒ¼ãƒè¨€èªã¨ã—ã¦ã®Protocol Buffersã§ã‚µãƒ¼ãƒ“ã‚¹ã®ã‚¤ãƒ³ãƒ•ã‚§ãƒ¼ã‚¹ã‚’è¨˜è¿°ã—ã¦ï¼Œå®Ÿéš›ã«ã‚„ã‚Šå–ã‚Šã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯JSONã€ã¨ã„ã†ã“ã¨ã‚‚å¯èƒ½ã«ãªã£ã¦ã„ã¾ã™ï¼\nFlat Buffers ã“ã‚Œã‚‚Googleã«ã‚ˆã£ã¦ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºãƒ»ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºæ–¹å¼ï¼å…¬å¼ã«ã‚ˆã‚Œã°ï¼Œ\n  Access to serialized data without parsing/unpacking Memory efficiency and speed Flexible Tiny code footprint Strongly typed Convenient to use Cross platform code with no dependencies   ã¨ã„ã†ç‰¹å¾´ãŒã‚ã‚Šã¾ã™ï¼é¢ç™½ã„ã®ãŒã€ŒAccess to serialized data without parsing/unpackingã€ã£ã¦ã¨ã“ã‚ã§ã™ã­ï¼FlatBuffersã§ã¯éšå±¤æ§‹é€ ã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿ã‚’ï¼Œãƒ‘ãƒ¼ã‚¹ã™ã‚‹ã“ã¨ãªãç›´æ¥æ‰±ã†ã“ã¨ãŒã§ãã‚‹ã‚‰ã—ã„ã§ã™ï¼\nProtocol Buffersã®é€²åŒ–ç³»ã¨ã—ã¦è‡ªã‚‰ã‚’ä½ç½®ã¥ã‘ã¦ã„ã¦ï¼ŒFlat Buffersã§ã¯ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‘ãƒ¼ã‚¹ã™ã‚‹å¿…è¦ãŒãªã„ã®ã§Protocol Buffersã¨æ¯”è¼ƒã—ã¦ã‚³ãƒ¼ãƒ‰é‡ãŒæ¡é•ã„ã§å‰Šæ¸›ã§ãã¦ï¼Œã•ã‚‰ã«Flat Buffersã§ã¯Protocol Buffersã‚ˆã‚Šå¼·åŠ›ã«å‹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã¨ã“ã‚ãŒé€²åŒ–ãƒã‚¤ãƒ³ãƒˆã§ã™ã­ï¼white paperã®motivationã®ç« ã«ã¯\n In particular, FlatBuffers focus is on mobile hardware (where memory size and memory bandwidth is even more constrained than on desktop hardware), and applications that have the highest performance needs: games.\n ã¨ã‚ã‚Šï¼Œã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã®åŠ¹ç‡ã«ã¤ã„ã¦é«˜æ°´æº–ãªã‚‚ã®ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹çŠ¶æ³ã§ç”¨ã„ã‚‰ã‚Œã‚‹ã“ã¨ãŒæƒ³å®šã•ã‚Œã¦ã„ã‚‹ãã†ã§ã™ï¼\nFacebookã§ç”¨ã„ã‚‰ã‚Œã¦ã„ã‚‹ã‚‰ã—ã„ã§ã™ãŒï¼ŒProtocol Buffersã®äººæ°—ã«æŠ¼ã•ã‚Œã¦ï¼Œã‚ã¾ã‚Šæµè¡Œã£ã¦ã„ã‚‹æ„Ÿã˜ã¯ã—ãªã„ã‚“ã§ã™ãŒã©ã†ãªã‚“ã§ã—ã‚‡ã†ã‹ï¼\nRef XML  hoge hoge  JSON  What is JSON - W3Schools JSON Introduction - W3Schools JSON Schema  BSON  BSON  Protocol Buffers  Protocol Buffers  Flat Buffers  Flat Buffers  ","date":1572796985,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572796985,"objectID":"5151db0bcc6ba8833835903e97cc00dd","permalink":"/ja/post/json-vs-protobuf-vs-flatbuf/","publishdate":"2019-11-04T01:03:05+09:00","relpermalink":"/ja/post/json-vs-protobuf-vs-flatbuf/","section":"post","summary":"èã„ãŸã“ã¨ã®ã‚ã‚‹ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³å½¢å¼ã«ã¤ã„ã¦èª¿ã¹ã¦ã¿ã¾ã—ãŸ","tags":["XML","JSON","ProtoBuf","FlatBuf","Data Serializing"],"title":"Data Serializationã®ã•ã¾ã–ã¾","type":"post"},{"authors":[],"categories":[],"content":"Identity is\u0026hellip;  The fact of being who or what a person or thing is.\n Self-Sovereign Identity - è‡ªå·±ä¸»æ¨©å‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã¨ã¯ Self-Sovereign Identityã¨ã¯ï¼Œä¸€è¨€ã§è¨€ãˆã°ã€Œç‰©ç†ä¸–ç•Œã«ãŠã‘ã‚‹èº«åˆ†è¨¼æ˜æ›¸ã¨åŒã˜ãƒ¬ãƒ™ãƒ«ã®æ­£å½“æ€§ã¨æºå¸¯æ€§ã¨æƒ…å ±ã®åˆ¶å¾¡å¯èƒ½æ€§ã‚’å‚™ãˆãŸãƒ‡ã‚¸ã‚¿ãƒ«ãªèº«åˆ†è¨¼æ˜æ›¸ã€ã§ã™ï¼Self-Sovereign IdentityãŒå®Ÿç¾ã™ã‚Œã°ï¼Œå…¬çš„ã«æœ‰åŠ¹ãªèº«åˆ†è¨¼æ˜æ›¸ã¨ã—ã¦æ©Ÿèƒ½ã™ã‚‹ã ã‘ã§ãªãï¼Œç‰©ç†ä¸–ç•Œã«ãŠã‘ã‚‹ã€Œé‹è»¢å…è¨±è¨¼ã€ã®ã‚ˆã†ã«æ‰‹è»½ã«æºå¸¯ã§ãã¦ï¼Œç¬¬äºŒè€…ã«å¯¾ã—ã¦è¨¼æ˜ã—ãŸã„äº‹æŸ„ã«é–¢é€£ã™ã‚‹å¿…è¦ååˆ†ãªæƒ…å ±ã®ã¿ã‚’é–‹ç¤ºã™ã‚‹ï¼ˆä¾‹ãˆã°ï¼Œå¹´é½¢ç¢ºèªã™ã‚‹éš›ã«ã¯èª•ç”Ÿå¹´ã ã‘æç¤ºã—ã¦ä½æ‰€ã¯è¦‹ã›ãªã„ï¼‰ã¨ã„ã£ãŸå€‹äººæƒ…å ±ã®åˆ¶å¾¡ã‚‚å¯èƒ½ã¨ãªã‚Šã¾ã™ï¼\nç¾çŠ¶ã®Digital Identityã®å•é¡Œç‚¹ãƒ»Self-Sovereign IdentityãŒå¿…è¦ã¨ã•ã‚Œã‚‹èƒŒæ™¯ ãã‚‚ãã‚‚ãªãœSelf-Sovereign Identityãªã‚‹ã‚‚ã®ãŒå¿…è¦ãªã®ã§ã—ã‚‡ã†ã‹ï¼ãã‚Œã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã¨ã„ã†è¨ˆç®—æ©Ÿã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãŒã€Œæ¥ç¶šã«ãŠã„ã¦ï¼Œé€šä¿¡ã®ä¸¡ç«¯ç‚¹ã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã‚’å…¨ãè€ƒæ…®ã—ãªã„ã€ã¨ã„ã†ç³»ã ã‹ã‚‰ã§ã™ï¼\nã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã§ã¯ã€Œèª°ãŒç¹‹ãŒã£ã¦ã„ã‚‹ã®ã‹ã€ã«ã¤ã„ã¦å…¨ãé–¢çŸ¥ã—ã¾ã›ã‚“ï¼ã ã‹ã‚‰ã“ãè‡ªå¾‹åˆ†æ•£ãªç³»ã¨ã—ã¦æˆç«‹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ä¸­å¤®ã§æ¥ç¶šã‚’ç®¡ç†ã™ã‚‹è€…ãŒå­˜åœ¨ã™ã‚‹å¿…è¦ãŒãªã„ã‚ã‘ã§ã™ã­ï¼\nã—ã‹ã—ï¼ŒSNSã®ç™»å ´ã«ã‚ˆã£ã¦ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆä¸Šã§ã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã®ã‚ˆã†ãªã‚‚ã®ãŒç¢ºç«‹ã•ã‚Œã¦ãã¾ã—ãŸï¼SNSã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±ã§ã™ï¼SNSã¯ã€Œç‰©ç†ä¸–ç•Œã«ãŠã‘ã‚‹äººé–“ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã€ã‚’è¨ˆç®—æ©Ÿä¸Šã«å®Ÿç¾ã—ãŸã‚‚ã®ã§ã‚ã‚‹ã‹ã‚‰ï¼ŒSNSã¨ã„ã†ç³»ã«ç™»å ´ã™ã‚‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯ç‰©ç†ä¸–ç•Œã®äººé–“ã¨éå¸¸ã«å¯†ã«é–¢é€£ã—ã¦ã„ã‚‹æƒ…å ±ã ã—ï¼Œãã®å´é¢ã‚’æŒã£ã¦ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼çš„ãªã‚‚ã®ã¨è¦‹ã‚‹ã“ã¨ã‚‚ã§ããªãã‚‚ãªã„ã§ã™ï¼ã—ã‹ã—SNSã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯ç‰©ç†ä¸–ç•Œã«ãŠã‘ã‚‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ï¼ˆãƒ‘ã‚¹ãƒãƒ¼ãƒˆã‚„é‹è»¢å…è¨±è¨¼ï¼‰ã¨ç­‰ä¾¡ãªã‚‚ã®ã¨ã—ã¦ã¯æ‰±ãˆã¾ã›ã‚“ï¼\nç‰©ç†ä¸–ç•Œã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã¯ã€Œå›½å®¶ã®ã‚ˆã†ãªä¿¡é ¼ã§ãã‚‹ç¬¬ä¸‰è€…ã«ã‚ˆã£ã¦ç™ºè¡Œã•ã‚Œã‚‹è¨¼æ˜æ›¸ã€ã¨ã—ã¦å­˜åœ¨ã—ã¦ã„ã¾ã™ï¼ãƒ‘ã‚¹ãƒãƒ¼ãƒˆï¼Œé‹è»¢å…è¨±è¨¼ã¯ã¾ã•ã—ããã‚Œã§ã™ï¼å›½å®¶ãŒã€Œã“ã®äººã¯ã“ã†ã„ã†äººã§\u0026hellip;ã€ã¨ã„ã†ä¿è¨¼ã‚’ã—ã¦ãã‚Œã¦ã„ã‚‹ã®ã§ã™ï¼ã ã‹ã‚‰ï¼ˆå°‘ãªãã¨ã‚‚ãã®è¨¼æ˜æ›¸ã‚’ç™ºè¡Œã—ã¦ã„ã‚‹ç¬¬ä¸‰è€…ã‚’ä¿¡é ¼ã§ãã‚‹è€…ã¨ã„ã†å…±é€šèªè­˜ã®ã‚ã‚‹ç¯„å›²å†…ã§ã¯ï¼‰è¨¼æ˜æ›¸ã‚’è¦‹ã›ã¤ã‘ã‚‹ã“ã¨ã§ç¬¬äºŒè€…ã«å¯¾ã—ã¦è‡ªåˆ†ã®èº«åˆ†ã‚’è¨¼æ˜ã™ã‚‹ã“ã¨ãŒå¯èƒ½ãªã®ã§ã™ï¼\nãƒ‘ã‚¹ãƒãƒ¼ãƒˆã‚„é‹è»¢å…è¨±è¨¼ã¯ãƒã‚±ãƒƒãƒˆã«å…¥ã‚Œã¦æŒã¡é‹ã¶ã“ã¨ãŒã§ãã¾ã™ï¼ã•ã‚‰ã«ç¬¬äºŒè€…ã«å¯¾ã—ã¦é–‹ç¤ºã™ã‚‹å€‹äººæƒ…å ±ã‚’ï¼Œè‡ªåˆ†ã®æ‰‹ã§åˆ¶å¾¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ç›¸æ‰‹ã«å¹´é½¢ç¢ºèªã‚’æ±‚ã‚ã‚‰ã‚ŒãŸãªã‚‰ï¼Œç”Ÿå¹´æœˆæ—¥ã ã‘ã§ååˆ†ï¼ˆä½æ‰€ã¾ã§æ•™ãˆã‚‹å¿…è¦ã¯ãªã„ï¼‰ã§ã™ã‹ã‚‰ï¼Œé‹è»¢å…è¨±è¨¼ã®è©²å½“éƒ¨åˆ†ã ã‘è¦‹ã›ã¦ã‚ã¨ã¯é»’å¡—ã‚Šã¨ã‹ã§ã‚‚ä¸»å¼µã®æ­£å½“æ€§ã¯è¨¼æ˜ã§ãã‚‹ã‚ã‘ã§ã™ã­ï¼ã“ã®æºå¸¯æ€§ã¨æƒ…å ±é–‹ç¤ºã«å¯¾ã™ã‚‹åˆ¶å¾¡æ€§ãŒç‰©ç†ä¸–ç•Œã«ãŠã‘ã‚‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã®æŒã¤é‡è¦ãªæ€§è³ªã§ã™ï¼\nSNSã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯å®Ÿã¯ã“ã®ã€Œæºå¸¯æ€§ã€ã¨ã€Œæƒ…å ±é–‹ç¤ºã«å¯¾ã™ã‚‹åˆ¶å¾¡æ€§ã€ã‚’å…¼ã­å‚™ãˆã¦ã„ã¾ã›ã‚“ï¼Facebookã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§Twitterã«ã¯ãƒ­ã‚°ã‚¤ãƒ³ã§ããªã„ã—ï¼ŒFacebookã¯åƒ•ã®æŒã£ã¦ã„ã‚‹Facebookã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æƒ…å ±ã®å®Œå…¨ãªã‚³ãƒ”ãƒ¼ã‚’æŒã£ã¦ã„ã¾ã™ã—ï¼ŒFacebookãŒãã‚Œã‚’å¤–éƒ¨ã«å…¬é–‹ã—ã¦ã—ã¾ãˆã°ï¼Œåƒ•ã«ã¯ãã‚Œã‚’æ­¢ã‚ã‚‹æ‰‹æ®µãŒã‚ã‚Šã¾ã›ã‚“ï¼\nSelf-Sovereign Identityã¯ãƒ‡ã‚¸ã‚¿ãƒ«ãªã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã«ã‚µãƒ¼ãƒ“ã‚¹ã‚’è·¨ã„ã æºå¸¯æ€§ã¨ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼æƒ…å ±ã«å¯¾ã™ã‚‹åˆ¶å¾¡æ€§ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å–ã‚Šæˆ»ã™ã“ã¨ã‚’ç›®æŒ‡ã—ã¦è€ƒæ¡ˆã•ã‚ŒãŸæ¦‚å¿µã§ã™ï¼\nSelf-Sovereign Identityã«è‡³ã‚‹ã¾ã§ã®ãƒ‡ã‚¸ã‚¿ãƒ«ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã®å¤‰é· ãƒ‡ã‚¸ã‚¿ãƒ«ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã®é¡å‹ã¯ã ã„ãŸã„ä»¥ä¸‹ã®4å€‹ã§ã™ï¼ã©ã‚Œã‚‚ç¾å½¹ã§ç”¨ã„ã‚‰ã‚Œã¦ã„ã‚‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã§ï¼Œå¾ŒåŠã®ã‚‚ã®ã»ã©æ–°ã—ç›®ãªè€ƒãˆæ–¹ã§ï¼Œã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã¤ã„ã¦ã„ã‚‹ã¨æ€ã†ã¨ã‚ã‹ã‚Šã‚„ã™ã„ã§ã™ï¼\n Centralized Identity - ä¸­å¤®é›†æ¨©å‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ Federated Identity - é€£åˆå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ User-Centric Identity - ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ Self-Sovereign Identity - è‡ªå·±ä¸»æ¨©å‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£  Centralized Identity - ä¸­å¤®é›†æ¨©å‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ ã“ã“ã®ã‚µãƒ¼ãƒ“ã‚¹ã”ã¨ã«ï¼Œã‚µãƒ¼ãƒ“ã‚¹é‹å–¶è€…ãŒIDã‚’ç™ºè¡Œãƒ»ç®¡ç†ã™ã‚‹ã‚¿ã‚¤ãƒ—ã®IDã§ã™ï¼ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹ã‚¿ã‚¤ãƒ—ã®IDã¯ã“ã‚Œã§ã™ï¼IDã®ç®¡ç†æ¨©é™ãŒç™ºè¡Œä¸»ä½“ã«ã‚ã‚‹ã¨ã„ã†ã®ãŒç‰¹å¾´ã§ï¼Œç¾åœ¨ä¸–ã®ä¸­ã§é‹å–¶ã•ã‚Œã¦ã„ã‚‹ã»ã¨ã‚“ã©ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã‚µãƒ¼ãƒ“ã‚¹ãŒã“ã®æ–¹å¼ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã­ï¼\nã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ“ã‚¸ãƒã‚¹ãƒ¢ãƒ‡ãƒ«ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å›²ã„è¾¼ã¿ã«ã‚ˆã£ã¦æˆç«‹ã—ã¦ã„ã‚‹ã¨ã„ã†å´é¢ã‚’è€ƒæ…®ã™ã‚‹ã¨ï¼Œç™ºè¡Œã¨ã¨ã‚‚ã«ç®¡ç†ã§ãã‚‹æ–¹ãŒï¼Œã‚µãƒ¼ãƒ“ã‚¹é‹å–¶è€…ã¨ã—ã¦ã¯ã‚„ã‚Šã‚„ã™ã„ã—ï¼Œå®Ÿè£…ã‚‚å®¹æ˜“ã§ã‚ã‚‹ã‹ã‚‰ã ã¨æ€ã„ã¾ã™ï¼\nã“ã®ã‚¿ã‚¤ãƒ—ã®IDã¯ï¼Œç™ºè¡Œã•ã‚ŒãŸIDã‚’ãã®ã‚µãƒ¼ãƒ“ã‚¹ã®å¤–ã«æŒã¡å‡ºã™ã“ã¨ãŒé›£ã—ã„ã“ã¨ã‹ã‚‰ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚µãƒ¼ãƒ“ã‚¹ã«å¯¾ã™ã‚‹ãƒ­ãƒƒã‚¯ã‚¤ãƒ³ã‚„ï¼Œã‚µãƒ¼ãƒ“ã‚¹ã”ã¨ã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã®åˆ†æ–­ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹IDã®ç®¡ç†ãŒä¸å¯èƒ½ï¼ˆã‚µãƒ¼ãƒ“ã‚¹é‹å–¶è€…ãŒæ‚ªæ„ã‚’åƒã„ã¦ã‚‚ãã‚Œã‚’æ­¢ã‚ã‚‹æ‰‹æ®µã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æŒã¡åˆã‚ã›ã¦ã„ãªã„ï¼‰ã¨ã„ã†å•é¡Œç‚¹ãŒã‚ã‚Šã¾ã™ï¼\nFederated Identity - é€£åˆå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ è¤‡æ•°ã®ã‚µãƒ¼ãƒ“ã‚¹é–“ã§IDã«ã¤ã„ã¦åˆæ„ã‚’å–ã‚‹ã“ã¨ã§ï¼Œé€£åˆå†…ã§ã¯IDã®æŒã¡é‹ã³ãŒå¯èƒ½ã¨ãªã‚‹ã‚ˆã†ãªIDã®ã“ã¨ã§ã™ï¼Single Sign-Onã¨å‘¼ã°ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ï¼1ã¤ã®IDã§è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹ã«ãƒ­ã‚°ã‚¤ãƒ³ã§ãã‚‹ã‚µãƒ¼ãƒ“ã‚¹é–“ã§ã®ç›¸äº’é‹ç”¨æ€§Interoperabilityã‚’å®Ÿç¾ã—ã¾ã™ï¼\né€£åˆå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã¯ä¸­å¤®é›†æ¨©å‹ã®ãã‚Œã‚ˆã‚Šã‚‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®åˆ©ä¾¿æ€§ã¯å‘ä¸Šã™ã‚‹ä¸€æ–¹ã§ï¼Œé€£åˆå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã§ã‚ã£ã¦ã‚‚ï¼ŒIDãã®ã‚‚ã®ã®ç®¡ç†ã¯é€£åˆã‚’çµ„ã‚“ã§ã„ã‚‹ã‚µãƒ¼ãƒ“ã‚¹æä¾›è€…å´ã«ã‚ã‚Šã¾ã™ï¼\nå®Ÿã¯é€£åˆå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã«å¯¾ã™ã‚‹å–ã‚Šçµ„ã¿ã¯ï¼Œã“ã‚Œã¾ã§ä¸€éƒ¨ã§å®Ÿéš›ã«è¡Œã‚ã‚Œã¦ããŸæ­´å²ãŒã‚ã‚Šã¾ã™ï¼1999å¹´ã«ã¯MicrosoftãŒPassportã¨ã„ã†é€£åˆå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã«å–ã‚Šçµ„ã‚‚ã†ã¨ã—ã¦ã„ã¾ã—ãŸï¼\nã“ã‚Œã¯ï¼Œãã®å½“æ™‚ã«å¢—åŠ ã—ã¦ãã¦ã„ãŸEã‚³ãƒãƒ¼ã‚¹äº‹æ¥­ã«å¯¾ã—ã¦ãã®åˆ©ä¾¿æ€§ã‚’é«˜ã‚ã‚‹ã“ã¨ã‚’ç‹™ã£ã¦MicrosoftãŒå–ã‚Šçµ„ã‚“ã§ã„ãŸã‚‚ã®ã§ï¼ŒWindows XPã¸ã®Passportã§ã®ã‚µã‚¤ãƒ³ã‚¤ãƒ³ãŒå¯èƒ½ã ã£ãŸã‚Šã¨çµæ§‹æ–°ã—ç›®ãªã“ã¨ã«å–ã‚Šçµ„ã‚‚ã†ã¨ã—ãŸã®ã ã¨æ€ã„ã¾ã™ï¼Eã‚³ãƒãƒ¼ã‚¹ã‚µã‚¤ãƒˆã«æ‰‹å…ƒã®ãƒ‘ã‚½ã‚³ãƒ³ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³ã§ãã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã‹ã‚‰ï¼Œè¦šãˆãªãã‚ƒã„ã‘ãªã„æƒ…å ±ãŒæ¸›ã‚‹ã®ã§åŠ©ã‹ã‚Šã¾ã™ã­ï¼\nä¸€æ–¹ã§ï¼ŒMicrosoftãŒä¸€ç¤¾ã§IDã‚’ç®¡ç†ã™ã‚‹ã¨ã„ã†è‰²åˆã„ãŒå¼·ã‹ã£ãŸã®ã‚‚äº‹å®Ÿã§ï¼Œãã‚Œã‚’å«Œã£ã¦ã‹ï¼Œåºƒãåˆ©ç”¨ã•ã‚Œã‚‹ã«ã¯è‡³ã‚‰ãªã‹ã£ãŸã‚ˆã†ã§ã™ï¼\nå®Ÿã¯Microsoftã®Passportã«å¯¾æŠ—ã—ã¦Sun Microsystemsã‚’ä¸­å¿ƒã¨ã—ãŸä¼æ¥­é€£åˆã«ã‚ˆã£ã¦Liberty Allianceã¨ã„ã†åŒã˜ãé€£åˆå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã®å®Ÿç¾ã‚’ç›®æŒ‡ã—ãŸå›£ä½“ãŒã‚ã£ãŸã‚ˆã†ãªã‚“ã§ã™ãŒï¼Œã“ã‚Œã‚‚é“åŠã°ã§é “æŒ«ã—ã¦ã—ã¾ã„ã¾ã—ãŸï¼\nUser-Centric Identity - ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªèº«ã®IDã‚’è‡ªã‚‰ã®æ‰‹ã§åˆ¶å¾¡ã™ã¹ãã ã€ã¨ã„ã†è€ƒãˆã«åŸºã¥ã„ã¦è€ƒæ¡ˆã•ã‚ŒãŸã®ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã§ã™ï¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã§ã¯ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã®åŒæ„Consentã€ã¨ã€Œç›¸äº’é‹ç”¨æ€§Interoperabilityã€ã«ç‰¹ã«é‡ããŒãŠã‹ã‚Œã¾ã—ãŸï¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã¯The Identity Commonsã¨ã„ã†å›£ä½“ãŒãƒªãƒ¼ãƒ‰ã—ã¦ã„ãŸãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ï¼ŒThe Identity Commonsã¯Internet Identity Workshopã‚’è¨­ç«‹ã—ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã®ä»•æ§˜ç­–å®šã‚’æ¨é€²ã—ã¦ãã¾ã—ãŸï¼Internet Identity Workshopã¯OpenIDï¼ŒOpenID Connectï¼ŒOAuthã¨ã„ã£ãŸç¾åœ¨å¤šãSingle Sign-Onã§åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ä»•æ§˜ã‚’èª•ç”Ÿã•ã›ã¦ã„ã¾ã™ï¼\nä¸€æ–¹ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒå‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã§ã‚‚ï¼ŒIDã®ç®¡ç†ã¯IDã®ç™ºè¡Œå…ƒã«ã‚ˆã£ã¦è¡Œã‚ã‚Œï¼Œã‚‚ã—ç™ºè¡Œå…ƒãŒIDã®å‰Šé™¤ã‚’ã—ã¦ã—ã¾ãˆã°ãã®IDã¯å­˜åœ¨ã—ãªããªã£ã¦ã—ã¾ã†ã‚ã‘ã§ï¼Œå®Œå…¨ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒï¼ˆç®¡ç†ã¾ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ‰‹ã§è¡Œã†ï¼‰ã¨ã„ã†ã‚ã‘ã§ã¯ãªã„ã‚ˆã†ã§ã™ï¼\nSelf-Sovereign Identity - è‡ªå·±ä¸»æ¨©å‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ ã€Œç‰©ç†ä¸–ç•Œã«ãŠã‘ã‚‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã®æŒã¤æºå¸¯æ€§ã¨æƒ…å ±ã«å¯¾ã™ã‚‹åˆ¶å¾¡æ€§ã‚’ãƒ‡ã‚¸ã‚¿ãƒ«ãªã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã«æŒã¡è¾¼ã‚‚ã†ã€ã¨ã„ã†ã®ãŒè‡ªå·±ä¸»æ¨©å‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã§ã™ï¼ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼ã«ç®¡ç†ã‚’è‡ªåˆ†ã®æ‰‹ã§è¡ŒãŠã†ã¨ã™ã‚‹ã®ãŒè‡ªå·±ä¸»æ¨©ã«æŒ‡ã™æ„å‘³ã§ã™ï¼\nSelf-Sovereign Identityã®ä»•çµ„ã¿  ä¿¡é ¼ã§ãã‚‹ç¬¬ä¸‰è€…ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èº«åˆ†ã‚’è¨¼æ˜ã™ã‚‹è¨¼æ˜æ›¸ã‚’ç™ºè¡Œã—ï¼Œãã®è¨¼æ˜æ›¸ã«é›»å­ç½²åã‚’æ–½ã™ï¼ã“ã®éš›ã«ä¿¡é ¼ã§ãã‚‹ç¬¬ä¸‰è€…ã«å¯¾ã™ã‚‹è­˜åˆ¥å­ã¨ç½²åæƒ…å ±ã‚’æƒ…å ±ã‚’è€æ”¹ç«„æ€§ã®ã‚ã‚‹å…¬å…±ã‚¢ã‚¯ã‚»ã‚¹ãŒå¯èƒ½ãªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã™ã‚‹ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ä¿¡é ¼ã§ãã‚‹ç¬¬ä¸‰è€…ã«ã‚ˆã£ã¦é›»å­ç½²åã®æ–½ã•ã‚ŒãŸè¨¼æ˜æ›¸ã«å¯¾ã—ã¦è‡ªåˆ†ã®é›»å­ç½²åã‚’æ–½ã—ã¦ï¼Œæ‰‹å…ƒã«ä¿ç®¡ã™ã‚‹ï¼ã“ã®éš›ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å¯¾ã™ã‚‹è­˜åˆ¥å­ã¨ç½²åæƒ…å ±ã‚’è€æ”¹ç«„æ€§ã®ã‚ã‚‹å…¬å…±ã‚¢ã‚¯ã‚»ã‚¹ãŒå¯èƒ½ãªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã™ã‚‹ èº«åˆ†è¨¼æ˜ã‚’è¦æ±‚ã™ã‚‹æ¤œè¨¼è€…ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰æç¤ºã•ã‚ŒãŸè¨¼æ˜æ›¸ï¼ˆã‚‚ã—ãã¯ãã®ä¸€éƒ¨ï¼‰ã«å¯¾ã—ã¦ï¼Œãã®è¨¼æ˜æ›¸ãŒæ­£å½“ã§ã‚ã‚‹ã“ã¨ã‚’å…¬å…±ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹æƒ…å ±ã‚’ã‚‚ã¨ã«åˆ¤æ–­ã™ã‚‹  ã“ã®ã€Œè€æ”¹ç«„æ€§ã®ã‚ã‚‹å…¬å…±ã‚¢ã‚¯ã‚»ã‚¹ãŒå¯èƒ½ãªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã€ãŒãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚’ç”¨ã„ã‚‹ã“ã¨ã§å®Ÿç¾ã§ãã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã¨ã„ã†ã“ã¨ã§ï¼ŒSelf-Sovereign Identityã®å®Ÿç¾å¯èƒ½æ€§ãŒè¦‹ãˆã¦ãã¦ã„ã‚‹ã®ã§ã™ï¼\nRef  https://medium.com/@AlexPreukschat/self-sovereign-identity-a-guide-to-privacy-for-your-digital-identity-5b9e95677778 https://www.windley.com/archives/2018/09/multi-source_and_self-sovereign_identity.shtml https://www.w3.org/TR/2019/WD-did-core-20191107/ https://www.jnsa.org/seminar/2018/0126/data/2-3.pdf https://www.icr.co.jp/newsletter/wtr346-20180126-ogawa.html https://www.dappsway.com/entry/what-is-ssi https://www.windley.com/archives/2017/10/fixing_the_five_problems_of_internet_identity.shtml https://www.ibm.com/blogs/blockchain/category/trusted-identity/self-sovereign-identity/ http://www.lifewithalacrity.com/2016/04/the-path-to-self-soverereign-identity.html  ","date":1572792488,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572792488,"objectID":"26eab1e50b15942fff1beb2275ae6825","permalink":"/ja/post/what-is-self-sovereign-identity/","publishdate":"2019-11-03T23:48:08+09:00","relpermalink":"/ja/post/what-is-self-sovereign-identity/","section":"post","summary":"Self-Sovereign Identityã«ã¤ã„ã¦ã®ãƒ¡ãƒ¢ã§ã™","tags":["Self Sovereign Identity","Distributed Identity","Blockchain","Identity"],"title":"Self-Sovereign Identity - è‡ªå·±ä¸»æ¨©å‹ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ¼","type":"post"},{"authors":[],"categories":[],"content":"ä¸¦è¡Œå‡¦ç†ï¼Ÿä¸¦åˆ—å‡¦ç†ï¼Ÿ ä¸¦è¡Œå‡¦ç†ã¨ã‹ä¸¦åˆ—å‡¦ç†ã£ã¦ä¸€ä½“ãªã‚“ãªã®ã§ã—ã‚‡ã†ï¼\né»æ˜æœŸã®è¨ˆç®—æ©Ÿã§ã¯ï¼Œä¸¦è¡Œå‡¦ç†ã ã®ä¸¦åˆ—å‡¦ç†ã ã®ãªã‚“ã¦ã“ã¨ã¯ï¼Œä¸€åˆ‡è€ƒãˆã¦ã„ã¾ã›ã‚“ã§ã—ãŸï¼å…¥åŠ›ã•ã‚ŒãŸå‘½ä»¤ã‚’1ã¤ãšã¤ï¼ŒçœŸé¢ç›®ã«å®Ÿè¡Œã—ã¦ã„ãã“ã¨ã§è¨ˆç®—ã‚’å®Ÿè¡Œã—ã¦ã„ãŸã®ã§ã™ï¼é»æ˜æœŸã®è¨ˆç®—æ©Ÿã¯ï¼Œäººé–“ãŒç´™ã¨é‰›ç­†ã§ã¡ã‚“ãŸã‚‰è¨ˆç®—ã‚’ã™ã‚‹ã‚ˆã‚Šã‚‚ï¼Œä½•å€ã‚‚é«˜é€Ÿã«ã‹ã¤æ­£ç¢ºã«è¨ˆç®—ã‚’ã™ã‚‹ã“ã¨ãŒã§ããŸã®ã§ï¼Œã¨ã¦ã‚‚äººæ°—ã«ãªã‚Šã¾ã—ãŸï¼ãŸã ï¼Œãã®å½“æ™‚ã®è¨ˆç®—æ©Ÿã¯ç‰©ç†çš„ã«ã‚µã‚¤ã‚ºã‚‚ãƒ‡ã‚«ãã¦é«˜ä¾¡ãªã‚‚ã®ã§ã—ãŸï¼ãªã®ã§ï¼Œè¨ˆç®—æ©Ÿã‚’å°å…¥ãƒ»è¨­ç½®ã§ãã‚‹ã®ã¯å¤§å­¦ãªã©ã®ãŠé‡‘ã¨éƒ¨å±‹ãŒä½™ã£ã¦ã„ã‚‹çµ„ç¹”ãã‚‰ã„ã—ã‹ãªã‹ã£ãŸã‚ã‘ã§ã™ï¼\nå¤§å­¦ã«è¨ˆç®—æ©ŸãŒè¨­ç½®ã•ã‚Œã‚‹ã¨ï¼Œå¤§å­¦ã®ç ”ç©¶è€…ãŸã¡ã¯å–œã³ã¾ã—ãŸï¼ã“ã‚Œã§é¢å€’ãªæ‰‹è¨ˆç®—ã‹ã‚‰è§£æ”¾ã•ã‚Œã‚‹ã‚ã‘ã§ã™ã‹ã‚‰ãã‚Šã‚ƒãã†ã§ã—ã‚‡ã†ï¼ã¿ã‚“ãªã§ã“ãã£ã¦è¨ˆç®—æ©Ÿã‚’ä½¿ã„ãŸããªã‚Šã¾ã™ï¼ã§ã‚‚ã€Œè¨ˆç®—æ©Ÿã‚’åˆ©ç”¨ã—ãŸã„ç ”ç©¶è€…ã®äººæ•°ã€ãŒã€Œè¨­ç½®ã—ã¦ã‚ã‚‹è¨ˆç®—æ©Ÿã®å°æ•°ã€ã¨æ¯”è¼ƒã—ã¦åœ§å€’çš„ã«å¤šã„ã®ã§ï¼Œè¨ˆç®—æ©Ÿã®ä½¿ç”¨ã‚’å·¡ã£ã¦äº‰å¥ªæˆ¦ãŒèµ·ã“ã‚Šã¾ã™ï¼ã ã£ã¦ï¼Œå½“æ™‚ã®è¨ˆç®—æ©Ÿã¯ã€Œå…¥åŠ›ã•ã‚ŒãŸå‘½ä»¤ã‚’1ã¤ãšã¤ï¼ŒçœŸé¢ç›®ã«å®Ÿè¡Œã—ã¦ã„ãã€ã‚¿ã‚¤ãƒ—ã®è¨ˆç®—æ©Ÿãªã®ã§ï¼Œä»–ã®èª°ã‹ãŒè¨ˆç®—æ©Ÿã«è¨ˆç®—ã‚’ã•ã›ã¦ã„ã‚‹é–“ã¯ï¼Œä»–ã®ç ”ç©¶è€…ã¯ãã®è¨ˆç®—æ©Ÿã‚’ä½¿ã†ã“ã¨ãŒã§ããªã„ã‹ã‚‰ã§ã™ï¼ãã‚“ãªã®ä¸ä¾¿ã™ãã¾ã™ï¼ã›ã£ã‹ãä¾¿åˆ©ã§ã—ã‹ã‚‚ã‚ã¡ã‚ƒã‚“ã“é«˜ä¾¡ãªè¨ˆç®—æ©ŸãŒè¨­ç½®ã—ã¦ã‚ã‚‹ã®ã«ï¼Œã—ã‹ã‚‚ä½¿ã„ãŸã„äººã¯ãŸãã•ã‚“ã„ã‚‹ã®ã«ä½¿ã‚ã›ã¦ã‚ã’ã‚‰ã‚Œãªã„ãªã‚“ã¦ï¼Œã‚‚ã†ä¸æº€ã‚¿ãƒ©ã‚¿ãƒ©ã§ã™ï¼ãã“ã§ç ”ç©¶è€…ãŸã¡ã¯è€ƒãˆã¾ã—ãŸï¼\nã€Œã©ã†ã‚„ã£ã¦1å°ã®è¨ˆç®—æ©Ÿã‚’è¤‡æ•°äººã§å…±æœ‰ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã ã‚ã†ã‹ï¼Ÿã€\nã€Œ1å°ã®è¨ˆç®—æ©Ÿã§è¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã«ã¯ã©ã‚“ãªä»•çµ„ã¿ãŒå¿…è¦ãªã‚“ã ã‚ã†ã‹ï¼Ÿã€\nã“ã“ã‹ã‚‰operating systemã¨ã‹processã¨ã‹ã„ã‚ã‚“ãªæ¦‚å¿µãŒç¢ºç«‹ã•ã‚Œã¦ã„ãã‚ã‘ã§ã™ï¼\nã€Œä¸¦è¡Œã€ã¨ã„ã†ã®ã¯ï¼Œè‹±èªã§ã¯concurrentã«ç›¸å½“ã—ï¼Œã€Œ1å°ã®ãƒã‚·ãƒ³ã§è¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ã‚’åŒæ™‚ã«å®Ÿè¡Œã—ã¦ã„ã‚‹ï¼ˆã‚ˆã†ã«è¦‹ãˆã‚‹ï¼‰æ§˜ã€ã‚’æ„å‘³ã—ã¾ã™ï¼concurrentãªå‡¦ç†ã¯ã€Œé™ã‚‰ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã‚’æœ‰åŠ¹æ´»ç”¨ã™ã‚‹ã“ã¨ã€ã‚’ç›®çš„ã¨ã—ã¦ã„ã¦ï¼Œç¾åœ¨ã®è¨ˆç®—æ©Ÿã§ã¯ã€ŒåŒæ™‚ã«å‡¦ç†ã—ã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ã›ã‚‹ãŸã‚ã«ï¼Œè¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ã‚’æ™‚é–“çš„ã«ç´°åˆ‡ã‚Œã«ã—ã¦å…¨éƒ¨ã®ã‚¿ã‚¹ã‚¯ã‚’ã¡ã‚‡ã£ã¨ãšã¤é€²ã‚ã‚‹ã€ã“ã¨ã§concurrentãªå‡¦ç†ã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ï¼\nä¸€æ–¹ã§ï¼Œä¼¼ãŸã‚ˆã†ãªæ¦‚å¿µã¨ã—ã¦ã€Œä¸¦åˆ—ã€ã¨ã„ã†ã‚‚ã®ã‚‚ã‚ã‚Šã¾ã™ï¼è‹±èªã§ã¯parallelã«ç›¸å½“ã—ï¼Œã€Œè¤‡æ•°å°ã®ãƒã‚·ãƒ³ã§1ã¤ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹æ§˜ã€ã‚’æ„å‘³ã—ã¾ã™ï¼parallelãªå‡¦ç†ã¯ã€Œï¼ˆè¤‡æ•°ã®ãƒã‚·ãƒ³ã¨ã„ã†ï¼‰è±Šå¯Œãªãƒªã‚½ãƒ¼ã‚¹ã‚’åˆ©ç”¨ã—ã¦1ã¤ã®ã‚¿ã‚¹ã‚¯ã‚’é«˜é€Ÿã«å®Ÿè¡Œã™ã‚‹ã“ã¨ã€ã‚’ç›®çš„ã¨ã—ã¦ã„ã¦ï¼Œconcurrentã¨ã¯ç›®çš„ãŒé•ã„ã¾ã™ï¼\nconcurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ  ã“ã“ã¾ã§è¨ˆç®—æ©Ÿã®é€²åŒ–ã®æ­´å²ã‚’æœ¬å½“ã«ã–ã£ãã‚Šè¦‹ã¦ã¿ã¾ã—ãŸãŒï¼Œã˜ã‚ƒã‚concurrentã¨ã„ã†æ¦‚å¿µãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã©ã†çµ¡ã‚“ã§ã„ãã®ã§ã—ã‚‡ã†ã‹ï¼\nãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã„ã†ã®ã¯å¤§ä½“ã€ŒCPUã§ã®æ¼”ç®—ã€ã€Œãƒ‡ãƒ¼ã‚¿ã®I/Oã€ã€Œãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ã€ã‚’éƒ¨å“ã¨ã—ã¦æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ï¼ãã‚Œãã‚Œã®éƒ¨å“ã«ã¯ç‰¹å¾´ãŒã‚ã£ã¦ï¼Œã€ŒCPUã§ã®æ¼”ç®—ã€ã¯ã¨ã¦ã‚‚é«˜é€Ÿã«å®Ÿè¡Œã§ãã‚‹ã‘ã‚Œã©ã‚‚ï¼Œã€Œãƒ‡ãƒ¼ã‚¿ã®I/Oã€ã¨ã€Œãƒãƒƒãƒˆãƒ¼ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ã€ã¯ï¼ˆã€ŒCPUã§ã®æ¼”ç®—ã€ã¨æ¯”è¼ƒã—ã¦ï¼‰æ¡é•ã„ã«ï¼Œæœ¬å½“ã«æ¡é•ã„ã«æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ï¼ã‚‚ã—è¨ˆç®—æ©ŸãŒã€Œå…¥åŠ›ã•ã‚ŒãŸå‘½ä»¤ã‚’1ã¤ãšã¤ï¼ŒçœŸé¢ç›®ã«å®Ÿè¡Œã—ã¦ã„ãã€æ–¹å¼ã§å‹•ã„ã¦ã„ãŸã¨ã™ã‚‹ã¨ï¼Œã€Œãƒ‡ãƒ¼ã‚¿ã®I/Oã€ã¨ã€Œãƒãƒƒãƒˆãƒ¼ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ã€ã«å–ã‚Šçµ„ã‚“ã§ã„ã‚‹é–“ï¼Œè¨ˆç®—æ©Ÿã¯ã†ã‚“ã¨ã‚‚ã™ã‚“ã¨ã‚‚è¨€ã‚ãšã«é»™ã‚Šè¾¼ã‚“ã§ã—ã¾ã†ã“ã¨ã«ãªã‚Šã¾ã™ï¼ã“ã‚Œã¯æ˜ã‚‰ã‹ã«ç„¡é§„ã§ã™ï¼CPUã¯ä½•ã‚‚è¨ˆç®—ã‚’é€²ã‚ãªã„ã§ãŸã å­˜åœ¨ã—ã¦ã„ã‚‹ã ã‘ã«ãªã‚‹ã‚ã‘ã§ã™ï¼\nconcurrentã¨ã„ã†æ¦‚å¿µã®èƒŒæ™¯ã«ã¯ã€Œã©ã†ã‚„ã£ã¦1å°ã®è¨ˆç®—æ©Ÿã‚’è¤‡æ•°äººã§å…±æœ‰ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã ã‚ã†ã‹ï¼Ÿã€ã¨ã„ã†å•é¡ŒãŒã‚ã£ãŸã‚ã‘ã§ã™ï¼ã“ã®å•é¡Œæ„è­˜ãŒä¸€æ­©é€²ã‚€ã¨ï¼Œã€Œ1å°ã®è¨ˆç®—æ©Ÿã§è¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã«ã¯ã©ã‚“ãªä»•çµ„ã¿ãŒå¿…è¦ãªã‚“ã ã‚ã†ã‹ï¼Ÿã€ã¨ãªã‚Šï¼Œã•ã‚‰ã«ä¸€æ­©é€²ã‚“ã§ã€Œï¼ˆè¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ã§æ§‹æˆã•ã‚Œã‚‹ï¼‰1ã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’1å°ã®CPUã§åŠ¹ç‡çš„ã«å‡¦ç†ã™ã‚‹ãŸã‚ã«ã¯ã©ã†ã„ã†ä»•çµ„ã¿ãŒå¿…è¦ãªã‚“ã ã‚ã†ï¼Ÿ\u0026hellip;ãã†ã ï¼CPUãŒæš‡ãªæ™‚é–“å¸¯ã«ã¯åˆ¥ã®ä»•äº‹ã‚’ã•ã›ã‚ˆã†ï¼ã€ã¨ãªã‚‹ã‚ã‘ã§ã™ï¼\nã€Œæ™‚é–“ãŒã‹ã‹ã£ã¦ã—ã¾ã†å‡¦ç†ã‚’ã‚„ã£ã¦ã„ã‚‹é–“ã«ï¼Œä»–ã«ã§ãã‚‹è¨ˆç®—ã‚’CPUã«ã‚„ã‚‰ã›ã‚ˆã†ã€ã¨ã„ã†ã®ãŒconcurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ããŸã„ç†ç”±ã§ã™ï¼ã ã£ã¦ãã†ã—ãŸæ–¹ãŒã‚„ã‚ŠãŸã„ã“ã¨æ—©ãçµ‚ã‚ã‚‹ã§ã—ã‚‡ã†ï¼ã—ã‹ã‚‚Personalãªè¨ˆç®—æ©ŸãŒä¸–ã®ä¸­ã«æ™®åŠã—ã¦ã€Œè¨ˆç®—æ©Ÿã¯ã‚ˆã‚Šé«˜é€Ÿã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å‹•ä½œã«å¿œç­”ã—ãªãã‚ƒã„ã‘ãªã„ï¼ˆã†ã‚“ã¨ã‚‚ã™ã‚“ã¨ã‚‚è¨€ã‚ãªã„è¨ˆç®—æ©Ÿã¯å«Œã‚ã‚Œã¦ã‚‹ï¼‰ã€ã—ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯å¤§æŠµã®å ´åˆéŸ³æ¥½è´ããªãŒã‚‰ãƒ¡ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯ã—ã¤ã¤Youtubeã§å‹•ç”»ã‚‚è¦‹ãŸã„ãƒ¯ã‚¬ãƒãƒãªå­˜åœ¨ã€ãªã®ã§ï¼ŒCPUã«æš‡ãªæ™‚é–“ãªã‚“ã¦ã‚‚ã®ã¯ãªã„ã‚ã‘ã§ã™ã‚ˆï¼\nã€Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯concurrentã«å®Ÿè¡Œã•ã‚Œã‚‹ã¹ãã€ã¨ãªã‚‹ã¨concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨˜è¿°ã—ã¦ï¼Œãã‚Œã‚’å®Ÿéš›ã«concurrentã«å®Ÿè¡Œã™ã‚‹æ©Ÿæ§‹ãŒå¿…è¦ã«ãªã‚Šã¾ã™ï¼\nã€Œå®Ÿéš›ã«concurrentã«å®Ÿè¡Œã™ã‚‹æ©Ÿæ§‹ã€ã«ã¤ã„ã¦ã¯Operating SystemãŒé ‘å¼µã£ã¦ï¼Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒconcurrentã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«å®Ÿè¡Œç’°å¢ƒã‚’æä¾›ã—ã¾ã™ï¼Operating Systemã¯çµæ§‹é ‘å¼µã‚‹ã®ã§ã™ãŒï¼Œã‚„ã£ã±ã‚Šé ‘å›ºãªãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã•ã‚“ã¨ã‚„ã‚Šã¨ã‚Šã—ãªã„ã¨ã„ã‘ãªã„ã®ã§ï¼Œç›¸å½“å¤§å¤‰ãã†ã§ã™ï¼æä¾›ã—ã¦ãã‚Œã‚‹å®Ÿè¡Œç’°å¢ƒã®åŠ¹ç‡ã«ã‚‚é™åº¦ãŒã‚ã‚Šãã†ã§ã™ï¼\nã€Œconcurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨˜è¿°ã€ã™ã‚‹ã¨ã“ã‚ã«ã¤ã„ã¦ã¯ï¼Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®å®ˆå‚™ç¯„å›²ãªã‚ã‘ã§ã™ãŒï¼Œã„ã‚ã‚“ãªè¨€èªãŒã„ã‚ã‚“ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’å–ã£ã¦ï¼Œconcurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚ˆã‚Šç°¡å˜ã«æ›¸ã‘ã‚‹ã‚ˆã†ã«ï¼Œãƒ—ãƒ­ã‚°ãƒ©ãƒ é–‹ç™ºè€…ã«éƒ¨å“primitiveã‚’æä¾›ã—ã¦ãã‚Œã¾ã™ï¼\nã§ã‚‚å¤å‚ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªãŸã¡ã¯ï¼Œãã®ãƒ‡ã‚¶ã‚¤ãƒ³ã®æ ¹å¹¹ã«ã€Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒconcurrentã«å®Ÿè¡Œã•ã‚Œã‚‹ã€ã¨ã‹æƒ³å®šã—ã¦ã„ãªã„ã‚ã‘ã§ï¼Œã„ã–ã‚„ã‚ã†ã¨ã™ã‚‹ã¨ä¸è‡ªç„¶ãªã¨ã“ã‚ã¨ã‹ãŒã‚„ã£ã±ã‚Šã§ã¦ãã¦ã—ã¾ã„ã¾ã™ï¼ãªã®ã§golangã¯ï¼Œè¨€èªã®ãƒ‡ã‚¶ã‚¤ãƒ³ã®æ®µéšã§concurrencyã‚’è€ƒæ…®ã—ãŸè¨€èªã¨ã—ã¦èª•ç”Ÿã—ã¾ã—ãŸï¼ãã†ã™ã‚Œã°ï¼Œconcurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚ˆã‚Šç›´æ„Ÿçš„ã«ã‚ã‹ã‚Šã‚„ã™ãæ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚‹ã‚ã‘ã§ã™ï¼\ngoroutineã¨channel golangã¯concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ããŸã‚ã®primitiveã¨ã—ã¦goroutineã¨channelã‚’æä¾›ã—ã¦ã„ã¾ã™ï¼ã¨ã„ã†ã®ã‚‚golangã§ã¯ï¼Œconcurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€ŒgoroutineãŸã¡ãŒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚„ã‚Šã¨ã‚Šã—ãªãŒã‚‰é€²è¡Œã™ã‚‹è¨ˆç®—ã€ã¨ã—ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã¦ã„ã‚‹ã®ã§ã™ï¼ã“ã“ã§æ³¨æ„ã—ã¦ãŠããŸã„ã®ãŒï¼Œconcurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¡¨ç¾ã™ã‚‹åˆ¥ã®ãƒ¢ãƒ‡ãƒ«ã‚‚è€ƒãˆã‚‰ã‚Œã‚‹ã¨ã„ã†ç‚¹ã§ã™ï¼ãƒ¢ãƒ‡ãƒ«åŒ–ã«ã¯ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹ã®ã§ã€ŒgoroutineãŸã¡ãŒmessage passingã€ã ã‘ãŒå”¯ä¸€ã®ãƒ¢ãƒ‡ãƒ«ã¨ã„ã†ã‚ã‘ã§ã¯ãªã„ã§ã™ï¼\ngoroutineã¨ã„ã†ã®ã¯ï¼Œæ¦‚å¿µçš„ã«ã¯OSã®æä¾›ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¨ã‹ã‚¹ãƒ¬ãƒƒãƒ‰ã¿ãŸã„ãªã‚‚ã®ã§ï¼Œå®Ÿè¡Œä¸­ã®å‡¦ç†ã‚’æŠ½è±¡åŒ–ã—ãŸã‚‚ã®ã§ã™ï¼ç›´æ„Ÿçš„ã«ã¯OSã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¨æ€ã£ã¦ã„ã¦ã‚‚ã„ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼å®Ÿæ…‹ã¯ã¡ã‚‡ã£ã¨é•ã†ã‚“ã§ã™ã‘ã©ã­ï¼ã“ã®ã€ŒæŠ½è±¡åŒ–ã•ã‚ŒãŸå‡¦ç†ã€åŒå£«ãŒmessage passingã«ã‚ˆã£ã¦æƒ…å ±ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã§concurrentãªå‡¦ç†ãŒå®Ÿç¾ã§ãã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ï¼\nchannelã¨ã„ã†ã®ã¯ï¼Œgoroutineé–“ã§ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼ã§ã™ï¼\ngolangã¯è¨€èªè¨­è¨ˆã®æ ¹åº•ã«ã‚ã‚‹æ€æƒ³ã¨ã—ã¦\n Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n ã‚’ï¼Œæ²ã’ã¦ã„ã¾ã™ï¼è¦ã™ã‚‹ã«ã€ŒgoroutineãŸã¡ã¯å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚’è¨­ã‘ã‚‹ã®ã§ã¯ãªãã¦message passingã§ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¨ã‚‹ã€ã‚ˆã†ã«è¨­è¨ˆã—ã‚ˆã†ã¨ã„ã†ã“ã¨ã§ã™ï¼\ngoroutineã¨channelã®è¨­è¨ˆã¨å®Ÿè£…ã‚’çœºã‚ã‚‹ goroutine goroutineã¯ã€Œå®Ÿè¡Œä¸­ã®å‡¦ç†ã‚’æŠ½è±¡åŒ–ã—ãŸã‚‚ã®ã€ã¨æ›¸ãã¾ã—ãŸãŒï¼Œã“ã‚Œã¯å…·ä½“çš„ã«ã¯ã€Œè¨ˆç®—ã«ç”¨ã„ã‚‹stackã¨å®Ÿè¡ŒçŠ¶æ…‹ã‚’ä¿æŒã—ã¦ã„ã‚‹æ§‹é€ ä½“ã€ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ï¼\ntype g struct { // Stack parameters. \t// stack describes the actual stack memory: [stack.lo, stack.hi). \t// stackguard0 is the stack pointer compared in the Go stack growth prologue. \t// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. \t// stackguard1 is the stack pointer compared in the C stack growth prologue. \t// It is stack.lo+StackGuard on g0 and gsignal stacks. \t// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). \tstack stack // offset known to runtime/cgo \tstackguard0 uintptr // offset known to liblink \tstackguard1 uintptr // offset known to liblink  // ,,, } ã€Œãã‚Œã£ã¦OSã®æä¾›ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¨ã‹ã‚¹ãƒ¬ãƒƒãƒ‰ã¨åŒã˜ã˜ã‚ƒãªã„ã®ï¼Ÿã€\nãã‚Œã¯ç¢ºã‹ã«ãã†ãªã‚“ã§ã™ãŒï¼Œgoroutineã¯OSã®æä¾›ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¨ã‹ã‚¹ãƒ¬ãƒƒãƒ‰ã¨åŒãƒ¬ãƒ™ãƒ«ã®å­˜åœ¨ã§ã¯ãªãã¦ï¼Œgoroutineã¯ï¼ŒOSã®æä¾›ã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦M:Nã§ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚Œã‚‹ã€Œgolangã®runtimeãŒæä¾›ã™ã‚‹ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ç©ºé–“ã§å®šç¾©ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã€ã¨ã—ã¦å­˜åœ¨ã—ã¦ã„ã¾ã™ï¼golangã®runtimeã¯goroutineã‚’ç®¡ç†ã—ã¦ã„ã¦ã€Œã„ã¤ï¼Œã©ã®goroutineã‚’å®Ÿè¡Œã™ã‚‹ã‹ã€ã‚’æ±ºå®šã™ã‚‹schedulerã¨ã—ã¦ã®å½¹å‰²ã‚‚æ‹…ã£ã¦ã„ã¾ã™ï¼ã¤ã¾ã‚Šgolangã®runtimeã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ç©ºé–“ã§å‹•ãã€ŒãƒŸãƒ‹OSã€ã®ã‚ˆã†ãªã‚‚ã®ãªè¨³ã§ã™ï¼ã¨ã¯è¨€ã„ã¤ã¤ã‚‚ï¼Œå®Ÿéš›ã«å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã«ã¯OSã®æä¾›ã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œãªã‘ã‚Œã°ã„ã‘ãªã„ã‚ã‘ã§ã™ã‹ã‚‰ï¼Œgoroutineã¯ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ï¼golangã®schedulerã¯goroutineã¨OSã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ï¼ŒM:Nã§ãƒãƒƒãƒ”ãƒ³ã‚°ã—ã¾ã™ï¼ã¤ã¾ã‚Šè¤‡æ•°ã®goroutineãŒè¤‡æ•°ã®OSã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã‚ã‘ã§ã™ï¼1ã¤ã®goroutineãŒè¤‡æ•°ã®OSã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã—ï¼Œ1ã¤ã®OSã‚¹ãƒ¬ãƒƒãƒ‰ã§ã¯è¤‡æ•°ã®goroutineã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ï¼\n   OS Process v.s. OS Thread v.s. Goroutine   ã¨ãªã‚‹ã¨ï¼Œé‡è¦ãªã®ã¯ã€Œgolangã®runtimeãŒã©ã®ã‚ˆã†ãªãƒ«ãƒ¼ãƒ«ã§goroutineã®å®Ÿè¡Œè¨ˆç”»ã‚’ç«‹ã¦ã‚‹ã®ã‹ã€ã§ã™ï¼\ngolangã®runtimeã«ã‚ˆã‚‹goroutineã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚° ç™»å ´ã™ã‚‹ã®ã¯Mï¼ŒGï¼ŒPã®ä¸‰äººï¼\n M  machineã®M OSã‚¹ãƒ¬ãƒƒãƒ‰ã«ç›¸å½“ã™ã‚‹   G  goroutineã®G   P  processorã®P ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼ˆæ¬¡ã©ã®Gã‚’å®Ÿè¡Œã™ã‚‹ã®ã‹ï¼‰ã‚’ç®¡ç†ã—ã¦ã„ã‚‹ å…·ä½“çš„ã«è¨€ãˆã°ï¼Œrunnableãªgoroutineã®ã‚­ãƒ¥ãƒ¼ã‚’ç®¡ç†ã—ã¦ã„ã‚‹ã®ãŒP       Gï¼ŒMï¼ŒP   ã¾ãšï¼Œç’°å¢ƒå¤‰æ•°GOMAXPROCSã®æ•°ã ã‘Mï¼ŒPãŒã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ï¼ä»¥ä¸‹ã§ã¯ï¼ŒGOMAXPROCS = 2ã¨ã—ã¾ã™ï¼\n  runnableãªGãŒPã«enqueueã•ã‚Œï¼ŒMã¯Pã‹ã‚‰runnableãªGã‚’1å€‹å–ã‚Šå‡ºã—ã¦å®Ÿè¡Œã—ã¾ã™ï¼\n  ã‚‚ã—ï¼Œqueueã«runnableãªGãŒ0å€‹ã«ãªã£ã¦ã—ã¾ã£ãŸã‚‰ï¼Œä»–ã®queueã‹ã‚‰åŠåˆ†ç›—ã¿ã¾ã™ï¼\n  ã€Œè‡ªåˆ†ã®queueãŒç©ºã«ãªã£ãŸã‚‰ä»–ã®Mã®æŒã¤Pã‹ã‚‰åŠåˆ†å¥ªã†ã€ã¨ã„ã†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯work stealingã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ï¼golangã®runtimeã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã¯ã“ã®work stealingã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«å¾“ã£ã¦goroutineã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ï¼ã“ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯CPUã‚’ãŸãã•ã‚“ä½¿ã†ã‚ˆã†ãªå‡¦ç†ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã«ã¯åŠ¹ç‡çš„ã§ã‚ã‚‹ä¸€æ–¹ã§I/Oå¾…ã¡ã‚’ä¼´ã†å‡¦ç†ï¼ˆsyscallã®å®Ÿè¡Œã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‡¦ç†ï¼‰ã¨ã¯ç›¸æ€§ãŒæ‚ªã„ã§ã™ï¼ãã®ãŸã‚ï¼Œã„ãã¤ã‹ã®å·¥å¤«ãŒã•ã‚Œã¦ã„ã¾ã™ï¼\nã¾ãšï¼Œgolangã®runtimeã«å­˜åœ¨ã—ã¦ã„ã‚‹ã‚‚ã®ã‚’æ•´ç†ã—ã¾ã™ï¼ä¸Šã§ç™»å ´ã—ãŸMï¼ŒGï¼ŒPã®ä»–ã«runtimeã«ã¯\n ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¥ãƒ¼  å„M-Pã«å¯¾å¿œã™ã‚‹queueã¨ã¯åˆ¥ã«å­˜åœ¨ã™ã‚‹ã‚­ãƒ¥ãƒ¼ é€šå¸¸GãŒrunnableã«ãªã‚‹ã¨Pã®æŒã¤ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚‹ãŒï¼Œã„ãã¤ã‹ã®çŠ¶æ³ã§ã¯ã“ã¡ã‚‰ã«å…¥ã‚Šã¾ã™   sysmon  GOMAXPROCSã®æ•°ã ã‘ã®Mã¨Pã®ä»–ã«ï¼Œsysmonã¨ã„ã†é–¢æ•°ã‚’å®Ÿè¡Œã—ç¶šã‘ã‚‹ç‰¹åˆ¥ãªMãŒå­˜åœ¨ã—ã¦ã„ã¾ã™ sysmonã®å®Ÿæ…‹ã¯ç„¡é™ãƒ«ãƒ¼ãƒ—ã§ï¼Œãã®ãƒ«ãƒ¼ãƒ—ã®ä¸­ã§netpollã®ãƒã‚§ãƒƒã‚¯ãªã©ã‚’è¡Œã£ã¦ã„ã¾ã™   P Idle List  æš‡ãªPã®ãƒªã‚¹ãƒˆ   M Idle List  æš‡ãªMã®ãƒªã‚¹ãƒˆ    syscallã‚’å®Ÿè¡Œã—ãŸå ´åˆ æ™‚é–“ã®ã‹ã‹ã‚‹syscallã‚’å®Ÿè¡Œã—ãŸå ´åˆï¼ŒsysmonãŒãã‚Œã‚’æ¤œçŸ¥ã—ï¼Œsyscallã‚’ç™ºè¡Œã—ãŸGã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹Mã‹ã‚‰Pã‚’åˆ‡ã‚Šé›¢ã—ï¼Œåˆ¥ã®Mã«ãã®Pã‚’ã‚¢ã‚¿ãƒƒãƒã—ã¦å‡¦ç†ã‚’ç¶™ç¶šã•ã›ã¾ã™ï¼ syscallçµ‚äº†å¾Œã¯ï¼Œã¾ãšP Idle Listã‚’ç¢ºèªã—ã¦æš‡ãã†ã«ã—ã¦ã„ã‚‹Pã‚’è‡ªèº«ï¼ˆMï¼‰ã«ã‚¢ã‚¿ãƒƒãƒã—ã¦å‡¦ç†ã‚’é€²ã‚ã¾ã™ï¼P Idle ListãŒã‹ã‚‰ã®å ´åˆã¯syscallã‚’ç™ºè¡Œã—ãŸGã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¥ãƒ¼ã«çªã£è¾¼ã¿ï¼ˆã“ã®Gã¯ã„ãšã‚ŒGCã•ã‚Œã‚‹ï¼‰ï¼Œè‡ªèº«ï¼ˆMï¼‰ã¯M Idle Listã«å…¥ã‚Šã¾ã™ï¼\n  ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‡¦ç†ã‚’ã—ãŸå ´åˆ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‡¦ç†ã®ç™ºç”Ÿæ™‚ã«ã¯netpollerã¨ã„ã†ä»•çµ„ã¿ã«ï¼Œãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‡¦ç†ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹goroutineãŒç™»éŒ²ã•ã‚Œï¼ŒsysmonãŒnetpollerã«ãƒãƒ¼ãƒªãƒ³ã‚°ã—ã¾ã™ï¼ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‡¦ç†ãŒçµ‚äº†ã—ãŸã‚‰netpollerã‹ã‚‰ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚Œã¦ï¼ŒMã§ç¶šãã‚’å®Ÿè¡Œã•ã‚Œã‚‹ã®ã‚’å¾…ã¤ã“ã¨ã«ãªã‚Šã¾ã™ï¼\ngolangã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒæä¾›ã™ã‚‹ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ã®APIã¯ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãªå‡¦ç†ã¨ãªã£ã¦ã„ã¾ã™ãŒï¼Œgoroutineã¯OSã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦M:Nã§ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚Œã‚‹ãŸã‚ï¼Œnetpollerã‚’ã«ã‚ˆã£ã¦ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ãªå‡¦ç†ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ï¼\n  channel channelã¯goroutineé–“ã§ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚­ãƒ¥ãƒ¼ã§ã™ï¼channelã«ã¯ã„ãã¤ã‹ã®é¢ç™½ã„ç‰¹å¾´ãŒã‚ã‚Šã¾ã™ï¼\n channelã¯goroutine-safe  è¤‡æ•°ã®goroutineãŒã‚ã‚‹channelã«åŒæ™‚ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã‚‚å•é¡ŒãŒç™ºç”Ÿã—ãªã„ã‚ˆã†ã«ãƒ­ãƒƒã‚¯æ©Ÿæ§‹ãŒçµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™   channelã¯goroutineé–“ã§FIFOãªãƒ‡ãƒ¼ã‚¿ã®å—ã‘æ¸¡ã—ãŒå¯èƒ½ã§ã™ channelã¯ãã®çŠ¶æ³æ¬¡ç¬¬ã§ã¯goroutineã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãŸã‚Šã‚¢ãƒ³ãƒ–ãƒ­ãƒƒã‚¯ã—ãŸã‚Šã§ãã¾ã™  ãƒãƒƒãƒ•ã‚¡0ã®channelã¯goroutineã‚’åŒæœŸã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ã¤ã¾ã‚Šã‚ã‚‹gorotuineãŒchannelã«æ›¸ãè¾¼ã‚€ã¨ï¼Œç›¸æ‰‹ã®goroutineãŒãã‚Œã‚’èª­ã¿è¾¼ã‚€ã¾ã§æ›¸ãè¾¼ã‚“ã goroutineã®å®Ÿè¡Œã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã—ï¼Œchannelã‹ã‚‰èª­ã¿è¾¼ã¿ãŸã„goroutineã®å®Ÿè¡Œã¯ï¼Œç›¸æ‰‹ã®goroutineãŒä½•ã‹ã‚’æ›¸ãè¾¼ã‚€ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ï¼    channelã¯hchanã¨ã„ã†åå‰ã®æ§‹é€ ä½“ã§å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ï¼\ntype hchan struct { qcount uint // total data in the queue \tdataqsiz uint // size of the circular queue \tbuf unsafe.Pointer // points to an array of dataqsiz elements \telemsize uint16 closed uint32 elemtype *_type // element type \tsendx uint // send index \trecvx uint // receive index \trecvq waitq // list of recv waiters \tsendq waitq // list of send waiters  // lock protects all fields in hchan, as well as several \t// fields in sudogs blocked on this channel. \t// \t// Do not change another G\u0026#39;s status while holding this lock \t// (in particular, do not ready a G), as this can deadlock \t// with stack shrinking. \tlock mutex } ã¾ãšï¼Œæ§‹é€ ä½“hchanã®ãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦lock mutexãŒè¦‹ãˆã‚‹ã®ã§ï¼Œchannelã¯goroutine-safeã§ã™ï¼è¤‡æ•°ã®goroutineãŒåŒæ™‚ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã‚‚å•é¡ŒãŒç™ºç”Ÿã—ãªã„ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ï¼goroutineãŒchannelã«å¯¾ã—ã¦èª­ã¿æ›¸ãã‚’ã—ãŸããªã£ãŸã‚‰ãƒ­ãƒƒã‚¯ã‚’å–ã£ã¦ã‹ã‚‰è¡Œã†ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ï¼\nä¸Šã«ç¤ºã—ãŸé€šã‚Šï¼Œchannelã®å®Ÿä½“ã¯ã€Œcircular queueï¼ˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼‰ã€ã§ã™ï¼çµ„ã¿è¾¼ã¿ã®make()ã§channelã‚’ä½œã‚‹ã¨ï¼Œå®Ÿä½“ã¯heapé ˜åŸŸã«ç¢ºä¿ã•ã‚Œï¼Œãã‚Œã¸ã®ãƒã‚¤ãƒ³ã‚¿ãŒè¿”ã•ã‚Œã¾ã™ï¼bufãŒãƒãƒƒãƒ•ã‚¡å…ˆé ­ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ï¼Œsendxãƒ»recvxãŒãã‚Œãã‚Œã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã¨ãŠå°»ã®ç•ªå·ã«ãªã£ã¦ã„ã¾ã™ï¼\n   æ§‹é€ ä½“hchan   ãªã®ã§ï¼Œchannelã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé€ã‚Šè¾¼ã¾ã‚ŒãŸã‚‰ï¼Œbuf[0]ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå…¥ã‚Šï¼ŒsendxãŒã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã¦1ã«ãªã‚Šã¾ã™ï¼ç¶šã‘ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒ2å€‹é€ã‚Šè¾¼ã¾ã‚Œã‚‹ã¨buf[1]ï¼Œbuf[2]ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ›¸ãè¾¼ã¾ã‚Œï¼ŒsendxãŒ0ã«æˆ»ã‚Šã¾ã™ï¼ã“ã“ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒ1å€‹èª­ã¾ã‚Œã‚‹ã¨buf[0]ã®å†…å®¹ãŒdequeueã¦recvxãŒ1ã«ãªã‚Šã¾ã™ï¼ç‰¹ã«é›£ã—ã„ã“ã¨ã¯ãªãï¼Œä¸€èˆ¬ã®circular queueã®å‹•ä½œã§ã™ã­ï¼\nchannelé–“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ã¯ã¨ã¦ã‚‚ç›´æ„Ÿçš„ã«å®Ÿç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼channelã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›¸ãè¾¼ã‚€æ™‚ã¯ï¼Œã¾ãšhchanã®ãƒ­ãƒƒã‚¯ã‚’å–ã£ã¦ï¼Œæ¬¡ã«bufã®ãŠå°»ã«é€ã‚ŠãŸã„ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼ã—ã¦ï¼Œã‚¢ãƒ³ãƒ­ãƒƒã‚¯ï¼channelã‹ã‚‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’èª­ã¿è¾¼ã‚€æ™‚ã¯ï¼ŒåŒæ§˜ã«ã¾ãšhchanã®ãƒ­ãƒƒã‚¯ã‚’å–ã£ã¦ï¼Œbufã®å…ˆé ­ã‚’ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼ã—ã¦ï¼Œã‚¢ãƒ³ãƒ­ãƒƒã‚¯ï¼ã¨ã¦ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªå‹•ä½œã§ã™ï¼\nå®Ÿã¯ã“ã®æŒ™å‹•ã“ããŒï¼Œgolangã®\n Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ç®‡æ‰€ã¨è¨€ãˆã¾ã™ï¼\ngoroutineé–“ã§å…±æœ‰ã—ã¦ã„ã‚‹ã®ã¯æ§‹é€ ä½“hchanã ã‘ã§ã™ï¼ã—ã‹ã‚‚hchanã¯ãƒ­ãƒƒã‚¯ã«ã‚ˆã£ã¦æ’ä»–å‡¦ç†ãŒæ–½ã•ã‚Œã‚‹ãŸã‚ï¼Œgoroutine-safeã§ã™ï¼hchanã®bufã«å€¤ã‚’æ›¸ãè¾¼ã‚€ï¼ˆã¤ã¾ã‚Šchannelã«å€¤ã‚’é€ã‚‹ï¼‰ãƒ»å€¤ã‚’èª­ã¿è¾¼ã‚€ï¼ˆã¤ã¾ã‚Šchannelã‹ã‚‰å€¤ã‚’å–ã‚Šå‡ºã™ï¼‰å‹•ä½œã¯å…¨ã¦ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼ã§è¡Œã‚ã‚Œã¾ã™ï¼goroutineé–“ã§ã‚„ã‚Šå–ã‚Šã™ã‚‹æƒ…å ±ã¯ï¼ˆãƒ¡ãƒ¢ãƒªã‚’å…±æœ‰ã™ã‚‹ã®ã§ã¯ãªãã¦ï¼‰ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼ã—ã¦æ¸¡ã—ã¾ã—ã‚‡ã†ã¨ã„ã†ã®ãŒï¼Œä¸Šã®æ¨™èªã®å®Ÿè£…ã¨è¨€ãˆã¾ã™ï¼\nchannelã¯goroutineã®æŒ™å‹•ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãŸã‚Šã‚¢ãƒ³ãƒ–ãƒ­ãƒƒã‚¯ã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ãƒãƒƒãƒ•ã‚¡ã«ç©ºããŒç„¡ã„channelï¼ˆãƒãƒƒãƒ•ã‚¡0ã®channelã‚„å®¹é‡ä¸€æ¯ãƒ‡ãƒ¼ã‚¿ãŒæ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹channelï¼‰ã«å¯¾ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šè¾¼ã‚‚ã†ã¨ã™ã‚‹ã¨ï¼Œgopark()ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ï¼ã“ã®é–¢æ•°ã¯ï¼Œgolangã®runtimeã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ã‚’å‘¼ã³å‡ºã—ã¦ï¼Œãƒãƒƒãƒ•ã‚¡ã«ç©ºããŒç„¡ã„channelã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šè¾¼ã‚‚ã†ã¨ã—ãŸgoroutineã®çŠ¶æ…‹ã‚’waitã«ã—ã¦åˆ¥ã®goroutineã®å®Ÿè¡Œã‚’å§‹ã‚ã¾ã™ï¼channelã«å¯¾ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šè¾¼ã‚€ãƒ­ã‚¸ãƒƒã‚¯ã®ä¸­ã«ï¼Œgoroutineã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ãŒçµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ï¼ã§ã¯ï¼Œã©ã†ã‚„ã£ã¦ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸgoroutineã®å®Ÿè¡Œã‚’å†é–‹ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼\nã“ã“ã§èˆˆå‘³æ·±ã„ã®ãŒï¼Œgopark()ã®å®Ÿè¡Œã®ç›´å‰ã«ã€Œã©ã®goroutineãŒã©ã‚“ãªå€¤ã‚’é€ã‚Šè¾¼ã‚‚ã†ã¨ã—ã¦ã„ãŸã®ã‹ã‚’channelã®ä¸­ã«è¨˜éŒ²ã—ã¦ãŠãã€ã¨ã„ã†ã¨ã“ã‚ã§ã™ï¼æ§‹é€ ä½“hchanã«ã¯sendqï¼Œrecvqã¨ã„ã†ãƒ¡ãƒ³ãƒãŒã‚ã‚Šï¼Œãã“ã«ã€Œã“ã®channelã«ã©ã®goroutineãŒã©ã‚“ãªãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šè¾¼ã‚‚ã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ï¼Œå–ã‚Šå‡ºã™ã®ã¯ã©ã®goroutineã§ã©ã“ã«èª­ã¿è¾¼ã‚‚ã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ã€ã¨ã„ã†æƒ…å ±ã‚’ä¿æŒã—ã¦ã„ã¾ã™ï¼ã€Œã“ã®channelã«ã©ã®goroutineãŒã©ã‚“ãªãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šè¾¼ã‚‚ã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ï¼Œå–ã‚Šå‡ºã™ã®ã¯ã©ã®goroutineã§ã©ã“ã«èª­ã¿è¾¼ã‚‚ã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ã€ã‚’ä¿æŒã™ã‚‹æ§‹é€ ä½“ã¯sudogã¨ã„ã†åå‰ã«ãªã£ã¦ã„ã¾ã™ï¼ãªãœã“ã®åå‰ãªã®ã‹ã¯ã“ã“ã®ãƒ¡ãƒ¼ãƒªã‚¹ã®ä¸€é€£ã®æµã‚Œã‚’èª­ã‚€ã¨ã‚ã‹ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã‚ˆï¼\n// sudog represents a g in a wait list, such as for sending/receiving // on a channel. // // sudog is necessary because the g â†” synchronization object relation // is many-to-many. A g can be on many wait lists, so there may be // many sudogs for one g; and many gs may be waiting on the same // synchronization object, so there may be many sudogs for one object. // // sudogs are allocated from a special pool. Use acquireSudog and // releaseSudog to allocate and free them. type sudog struct { // The following fields are protected by the hchan.lock of the \t// channel this sudog is blocking on. shrinkstack depends on \t// this for sudogs involved in channel ops.  g *g // isSelect indicates g is participating in a select, so \t// g.selectDone must be CAS\u0026#39;d to win the wake-up race. \tisSelect bool next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack)  // The following fields are never accessed concurrently. \t// For channels, waitlink is only accessed by g. \t// For semaphores, all fields (including the ones above) \t// are only accessed when holding a semaRoot lock.  acquiretime int64 releasetime int64 ticket uint32 parent *sudog // semaRoot binary tree \twaitlink *sudog // g.waiting list or semaRoot \twaittail *sudog // semaRoot \tc *hchan // channel } gopark()ã«ã‚ˆã£ã¦å—ã‘å–ã‚Šæ‰‹ã®goroutineã®å®Ÿè¡ŒãŒé–‹å§‹ã•ã‚Œã‚‹ã¨ï¼Œå—ã‘å–ã‚Šæ‰‹ã®goroutineãŒï¼Œchannelã®sendqã®ä¸­èº«ã‚’ç¢ºèªã—ã¦ï¼Œå®Ÿè¡Œã‚’ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã—ã¾ã£ãŸé€ã‚Šæ‰‹ã®goroutineãŒæœ€å¾Œã«channelã«é€ã‚Šè¾¼ã‚‚ã†ã¨ã—ãŸå€¤ã‚’ï¼ˆé€ã‚Šæ‰‹å´ã«ä»£ã‚ã£ã¦ï¼‰å—ã‘å–ã‚Šæ‰‹å´ãŒchannelã®bufã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ï¼ã“ã‚Œã¯ã‚ã‚‹ç¨®ã®æœ€é©åŒ–ã§ã™ï¼çœŸé¢ç›®ã«ï¼Œé€ã‚Šæ‰‹å´ã®å®Ÿè¡ŒãŒå†é–‹ã•ã‚Œã¦ã‹ã‚‰channelã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šè¾¼ã‚€ã“ã¨ã«ã™ã‚‹ã¨channelã«å¯¾ã™ã‚‹ãƒ­ãƒƒã‚¯ã‚’å–ã‚‹å¿…è¦ãŒã‚ã‚Šï¼Œæ’ä»–å‡¦ç†ã‚’ã™ã‚‹å›æ•°ãŒ1å›å¢—ãˆã¦ã—ã¾ã„ã¾ã™ï¼ã€Œèª°ãŒã©ã‚“ãªå€¤ã‚’é€ã‚ã†ã¨ã—ã¦ã„ãŸã®ã‹ã€ãŒè‡ªæ˜ã§ã‚ã‚‹ãªã‚‰ã°ï¼Œå…ˆã«ã‚„ã£ã¦ã—ã¾ãˆã¨ã„ã†è€ƒãˆã®ã‚ˆã†ã§ã™ï¼\nchannelã‹ã‚‰å€¤ã‚’1å€‹å—ã‘å–ã‚‹ã¨ï¼Œgoready()ãŒå®Ÿè¡Œã•ã‚Œã¦ï¼Œã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ãŒèµ·å‹•ã—ï¼Œãƒãƒƒãƒ•ã‚¡ã«ç©ºããŒç„¡ã„channelã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚ã†ã¨ã—ãŸgoroutineã®çŠ¶æ…‹ã‚’runnableã«ã‚»ãƒƒãƒˆã—ã¦å®Ÿè¡Œå¾…ã¡ã®ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Šã¾ã™ï¼\ngoroutineãŒç©ºã®channelã«å¯¾ã—ã¦èª­ã¿è¾¼ã¿ã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã¨ï¼Œãã®goroutineã®å‹•ä½œã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ï¼ã“ã®æŒ™å‹•ã¯channelã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã§ã‚ã‚‹recv()é–¢æ•°å†…ã«è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ï¼ã•ã‚‰ã«é¢ç™½ã„ã®ãŒï¼Œã€Œã©ã®goroutineãŒï¼Œã©ã“ã«å€¤ã‚’å—ã‘å–ã‚ã†ã¨ã—ã¦ã„ãŸã®ã‹ã€ã‚’recvqã«ä¿å­˜ã—ã¦ã„ã‚‹ã“ã¨ã§ã™ï¼ã“ã‚Œã«ã‚ˆã£ã¦ï¼Œchannelã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šè¾¼ã‚€goroutineãŒï¼Œå—ã‘å–ã‚Šå…ˆã®goroutineã®ã‚¹ã‚¿ãƒƒã‚¯é ˜åŸŸã‚’ç›´æ¥ã„ã˜ã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚Šåˆ‡ã£ã¦ã—ã¾ã†ã“ã¨ãŒå¯èƒ½ã¨ãªã‚Šã¾ã™ï¼goroutineã®å®Ÿä½“ã¯ï¼ˆé›‘ã«è¨€ãˆã°ï¼‰stackã‚’æŒã¤æ§‹é€ ä½“ã§ï¼ŒOSãƒ—ãƒ­ã‚»ã‚¹ã®ã‚¹ã‚¿ãƒƒã‚¯é ˜åŸŸã«ç½®ã‹ã‚Œã¦ã„ã¾ã™ï¼ã¤ã¾ã‚Šåˆ¥ã®goroutineã®æŒã¤stackã‚’ç›´æ¥ã„ã˜ã‚‹ã“ã¨ãŒï¼Œchannelã§ã®ãƒ‡ãƒ¼ã‚¿ã®ã‚„ã‚Šå–ã‚Šã®é™ã‚‰ã‚ŒãŸçŠ¶æ³ã«ãŠã„ã¦ã®ã¿è¨±ã•ã‚Œã¦ã„ã‚‹ã¨ã„ã†ã®ãŒèˆˆå‘³æ·±ã„ã§ã™ï¼\ngolangã®channelå‘¨ã‚Šã®å®Ÿè£…ã‚’è¦‹ã¦ï¼Œ\n ã€Œæ’ä»–å‡¦ç†ã‚’å«ã‚€ç°¡æ½”ãªå®Ÿè£…ã®æ–¹ãŒï¼Œæ’ä»–å‡¦ç†ãªã—ã®è¤‡é›‘ãªå®Ÿè£…ã‚ˆã‚Šãƒã‚·ï¼ã„ãã‚‰ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒè‰¯ãã¦ã‚‚ï¼Œãã‚ŒãŒè¤‡é›‘ãªã‚³ãƒ¼ãƒ‰ã§ã‚‚è‰¯ã„ã“ã¨ã®ç†ç”±ã«ã¯ãªã‚‰ãªã„ã€ ã€Œãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®è¦³ç‚¹ã‹ã‚‰ï¼Œgoroutineã¨ã„ã†ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¬ãƒ™ãƒ«ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ï¼ˆOSã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã•ã›ãªã„ï¼‰ï¼Œç•°ãªã‚‹goroutineã‚’è·¨ã„ã ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼ã‚’è¨±ã™ï¼ˆãã®åˆ†å®Ÿè£…ãŒã‚„ã‚„è¤‡é›‘ã«ãªã‚‹ãŒãã‚Œã¯è¨±å®¹ã™ã‚‹ï¼‰ã€  ã¨ã„ã†ç›¸åã™ã‚‹è€ƒãˆãŒæ„Ÿã˜ã‚‰ã‚Œã¾ã™ï¼ã¤ã¾ã‚Š\n simplicityã¨performaceã«ã¯æ˜ç¢ºãªtrade-offãŒå­˜åœ¨ã™ã‚‹\n ã¨ã„ã†ã“ã¨ã§ã™ã­ï¼\nãŠã‚ã‚Šã« ä»Šå›åˆã‚ã¦runtimeã‚’ã˜ã£ãã‚Šèª­ã¿ã¾ã—ãŸï¼ä»Šã¾ã§æ¦‚å¿µã¨ã—ã¦ç†è§£ã—ã¦ã„ãŸã‚‚ã®ã®å®Ÿä½“ã‚’ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦æ´ã‚ãŸã®ã§ï¼Œã¨ã¦ã‚‚æ¥½ã—ã‹ã£ãŸã§ã™ï¼ä»Šå›ã¯goroutineã¨channelå‘¨ã‚ŠãŒä¸­å¿ƒã ã£ãŸã®ã§ï¼Œæ¬¡ã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼å‘¨è¾ºã‚’ã‚‚ã£ã¨ã¤ã¶ã•ã«è¦‹ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ï¼\n","date":1572584876,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572584876,"objectID":"b23a273aaf77fc1dcb8ae6fefc8b2a15","permalink":"/ja/post/internal-of-golang-concurrency-primitives/","publishdate":"2019-11-01T14:07:56+09:00","relpermalink":"/ja/post/internal-of-golang-concurrency-primitives/","section":"post","summary":"goroutineã¨channelã®å®Ÿè£…ã«ã¤ã„ã¦çœºã‚ã¦ã¿ã¾ã—ãŸ","tags":["Golang","Goroutine","Channel","Concurrency","Parallelism"],"title":"Internal of Golang Concurrency Primitives","type":"post"},{"authors":[],"categories":[],"content":"golangã¨concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° ã€Œconcurrentãªå‡¦ç†ã‚’ã©ã®ã‚ˆã†ã«å®Ÿç¾ã™ã‚‹ã‹ã€ã¯ã–ã£ãã‚Šåˆ†ã‘ã¦2ã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒã‚ã‚‹ï¼\n1ã¤ã¯ã€Œshared-memory communicationã€ï¼ã¤ã¾ã‚Šå‡¦ç†ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹workeråŒå£«ã¯ï¼Œãƒ¡ãƒ¢ãƒªã‚’å…±æœ‰ã—ã¦ï¼Œãã®å…±æœ‰ã—ã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªã‚’ç”¨ã„ã¦ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å–ã‚‹ã¨ã„ã†ã‚‚ã®ï¼ã“ã®å ´åˆï¼Œãƒ‡ãƒ¼ã‚¿ç«¶åˆãŒç™ºç”Ÿã—ãªã„ã‚ˆã†ã«ãƒ­ãƒƒã‚¯ã‚’å–ã£ãŸã‚Šãªã©ã®æ’ä»–å‡¦ç†ã‚’ä¼´ã†ã“ã¨ã«ãªã£ã¦ï¼Œå¤§æŠµã®å ´åˆå®Ÿè£…ãŒé›£ã—ããªã‚‹ã¨ã•ã‚Œã¦ã„ã‚‹ï¼\nã‚‚ã†1ã¤ã¯ã€Œmessage-passing communicationã€ï¼ã¤ã¾ã‚Šå‡¦ç†ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹workeråŒå£«ã¯ï¼Œãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚„ã‚Šå–ã‚Šã—åˆã†ã“ã¨ã§ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å–ã‚‹ã¨ã„ã†ã‚‚ã®ï¼\nãã‚Œãã‚Œã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã„ã‚ã‚“ãªå®Ÿè£…ãŒä¸–ã®ä¸­ã«ã¯ã™ã§ã«å­˜åœ¨ã—ã¦ã„ã¦ï¼Œä¾‹ãˆã°Cã§concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã“ã†ã¨ã™ã‚‹ã¨shared-memory communicationãªå½¢ã§æ›¸ãã“ã¨ã«ãªã‚‹ï¼ä¸€æ–¹ã§Erlangã¯è¨€èªã¨ã—ã¦concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¦ï¼ŒActorãƒ¢ãƒ‡ãƒ«ã‚’å®Ÿè£…ã—ã¦ã‚‹ï¼\ngolangã¯ï¼Œè¨­è¨ˆã®æ™‚ç‚¹ã§concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯\n Do not communicate by sharing memory; instead, share memory by communicating\n ã¨ã„ã†æ€æƒ³ã§å®Ÿè£…ã™ã‚‹ã“ã¨ã¨ã—ã¦ã„ã‚‹ï¼golangã®concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®å®Ÿè£…ã¯ã€ŒCommunicating Sequential Processesã€ã¨ã€Œ$\\pi$-caluculusã€ã‚’å‚è€ƒã«ã—ã¦ã„ã‚‹ï¼\ngolangã¯ã€Œconcurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ç°¡æ½”ã«ã‚ã‹ã‚Šã‚„ã™ãè¨˜è¿°ã™ã‚‹ã“ã¨ã€ã‚’è¨€èªã®è¨­è¨ˆãƒ¬ãƒ™ãƒ«ã‹ã‚‰ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã§ï¼Œconcurrentãªå‡¦ç†ãŒã¨ã¦ã‚‚æ›¸ãã‚„ã™ããªã£ã¦ã„ã‚‹ï¼ã˜ã‚ƒã‚golangã§ã¯ã©ã†ã‚„ã£ã¦concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã®ã‹ã¨ã„ã†ã¨ï¼Œconcurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã—ã¦goroutineï¼Œchannelã‚’æä¾›ã—ã¦ã„ã‚‹ï¼\nã€Œgolangã¯concurrentãªå‡¦ç†ãŒæ›¸ãã‚„ã™ã„ã‚“ã ã‚ˆã­ã€ã¨ã„ã†è©±ã‚’ã™ã‚‹ã¨æ··ä¹±ã—ãŒã¡ãªã®ãŒï¼Œ ã€Œgolangã¯concurrentãªå‡¦ç†ã‚’æ›¸ããŸã‚ã®é“å…·ã‚’æä¾›ã—ã¦ãã‚Œã‚‹ãŒï¼Œãã®å®Ÿè¡ŒãŒparallelã§ã‚ã‚‹ã‹ã©ã†ã‹ã¯ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã«ä¾å­˜ã™ã‚‹ã€ ã¨ã„ã†ç‚¹ï¼concurrentãªå‡¦ç†ã¯ï¼Œparallelã«å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚‚ã—ã‚Œãªã„ï¼ˆã—å¤§æŠµparallelã«å®Ÿè¡Œã§ãã‚‹ãªã‚‰ãã†ã—ãŸã»ã†ãŒã„ã„ï¼‰ãŒï¼Œãã‚Œã¯ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãŒparallelãªå®Ÿè¡Œã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‹ï¼ˆä¾‹ãˆã°CPUãŒè¤‡æ•°ã‚³ã‚¢æ­è¼‰ã—ã¦ã„ã‚‹ã‹ï¼‰ã«ã‚ˆã£ã¦æ±ºã¾ã£ã¦ãã‚‹è©±ã§ã‚ã£ã¦ï¼Œã€Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒconcurrentã§ã‚ã‚‹ã“ã¨ã€ã¨ã€Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡ŒãŒparallelã§ã‚ã‚‹ã“ã¨ã€ã¯é–¢é€£ã¯ã—ã¦ã„ã‚‹ã‘ã‚Œã©ã‚‚ï¼Œå…¨ãåˆ¥ã®è©±ï¼Rob Pikeå…ˆç”Ÿã‚‚\n Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once. Not the same, but related. Concurrency is about structure, parallelism is about execution. Concurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.\n ã£ã¦ä»°ã£ã¦ã„ã‚‹ï¼\nHello, goroutine!  ã€Œgolangã§ã¯concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã‚„ã™ã„ã€ã¨ã„ã†ã“ã¨ã ã£ãŸã®ã§ï¼Œå®Ÿéš›ã«concurrentãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã„ã¦ã¿ã‚‹ã¨ä¸Šã®ä¾‹ã¿ãŸã„ã«ãªã‚‹ï¼concurrentã«å‡¦ç†ã‚’å®Ÿè¡Œã™ã‚‹workerã¯ï¼Œgolangã®ä¸–ç•Œã§ã¯gorutineã¨å‘¼ã°ã‚Œã¦ã„ã¦ï¼Œgoã¨ã„ã†é­”æ³•ã®è¨€è‘‰ã«ç¶šã‘ã¦workerã§å®Ÿè¡Œã—ã¦ã»ã—ã„é–¢æ•°ã‚’å‘¼ã³å‡ºã›ã°ï¼Œãã‚Œã§concurrentãªå‡¦ç†ã‚’æ›¸ãä¸‹ã—ãŸã“ã¨ã«ãªã‚‹ï¼ãªã‚“ã¦ç°¡å˜ãªã‚“ã ...ï¼\nä¸Šã®ä¾‹ã‚’å®Ÿè¡Œã™ã‚‹ã¨ï¼ŒHello! I'm mainã£ã¦å°å­—ã•ã‚Œã¦ï¼Œã‚‚ã—ã‹ã—ãŸã‚‰Hi! I'm goroutine!ã‚‚ä¸€ç·’ã«å°å­—ã•ã‚Œã‚‹ ã‹ã‚‚ã—ã‚Œãªã„ï¼ã€Œã‹ã‚‚ã—ã‚Œãªã„ã€ã£ã¦ã„ã†ã®ã¯ï¼Œgoroutineã¯ã€Œã‚ã‚‹goroutineã®è¦ªã¯è‡ªåˆ†ã®å­ä¾›ã®å‡¦ç†ãŒçµ‚ã‚ã‚‹ã®ã‚’å¾…ãŸãªã„ã€ã“ã¨ã«ãªã£ã¦ã„ã‚‹ï¼ã“ã®å ´åˆã ã¨mainãŒè¦ªã§go fmt.Println(\u0026quot;Hi! I'm goroutine!\u0026quot;)ãŒå­ä¾›ã®é–¢ä¿‚ã«ãªã£ã¦ã„ã¦ï¼Œmainã®fmt.Println(\u0026quot;Hello! I'm main\u0026quot;)ã®çµ‚äº†ã—ãŸã‚‰ï¼Œãã®æ™‚ç‚¹ã§å­ä¾›ã®å®Ÿè¡Œã‚‚çµ‚äº†ã•ã›ã‚‰ã‚Œã¦ã—ã¾ã†ï¼ã‚‚ã—ï¼Œå­ä¾›ã®goroutineãŒè‡ªå·±ç´¹ä»‹ã—çµ‚ã‚ã‚‹å‰ã«è¦ªãŒè‡ªå·±ç´¹ä»‹ã—ãã£ã¡ã‚ƒãˆã°å­ä¾›ã®è‡ªå·±ç´¹ä»‹ã¯å°å­—ã•ã‚Œãªã„ã—ï¼Œè¦ªã®è‡ªå·±ç´¹ä»‹ãŒçµ‚ã‚ã‚‹å‰ã«å­ä¾›ãŒè‡ªå·±ç´¹ä»‹ã—ãã£ã¡ã‚ƒãˆã°ï¼Œè¦ªå­ä¸¡æ–¹ã®è‡ªå·±ç´¹ä»‹ãŒèã‘ã‚‹ã“ã¨ã«ãªã‚‹ï¼\nã€Œãªã‚‹ã»ã©ï¼ã§ã‚‚è¦ªãŒå…ˆã«çµ‚ã‚ã£ã¡ã‚ƒã†ã¨å­ä¾›ã‚‚å¼·åˆ¶çµ‚äº†ã£ã¦ï¼Œãã‚Œã©ã†ã«ã‹ãªã‚‰ãªã„ã®ï¼Ÿã€ã£ã¦æ€ã£ãŸæ–¹ã¯è³¢ãã¦ï¼Œã©ã†ã«ã‹ã™ã‚‹ãŸã‚ã«goroutineé–“ã§ãŠã—ã‚ƒã¹ã‚Šã§ãã‚‹channelã¨ã„ã†ãƒ‡ãƒ¼ã‚¿æ§‹é€ ãŒå®Ÿè£…ã—ã¦ã‚ã‚‹ï¼\nNice to meet you, channel! channelã¯goroutineãŸã¡ãŒåŒæœŸã—ãªãŒã‚‰concurrentãªå‡¦ç†ã‚’å®Ÿè¡Œã—ã¦ã„ããŸã‚ã®message-passingã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’æä¾›ã—ã¦ãã‚Œã‚‹ï¼channelã¯ã€Œãã®channelã‚’é€šã˜ã¦ã‚„ã‚Šå–ã‚Šã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®å‹ãƒ»ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºãƒ»ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚„ã‚Šå–ã‚Šã®æ–¹å‘ã€ã§å®šç¾©ã•ã‚Œã¦ï¼Œçµ„ã¿è¾¼ã¿é–¢æ•°ã®make()ã§ç°¡å˜ã«ä½œã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\ngolangã§ã¯ã€Œchannelã¯first-class valueã€ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ï¼ã¤ã¾ã‚Šchannelã¯ï¼Œä»–ã®å€¤ï¼ˆä¾‹ãˆã°ãªã‚“ã‚‰ã‹ã®æ§‹é€ ä½“ã¨ã‹intå‹ã®å¤‰æ•°ã¨ã‹é–¢æ•°ã¨ã‹ï¼‰ã¨åŒã˜ãƒ¬ãƒ™ãƒ«ã§æ‰±ã‚ã‚Œã‚‹ï¼ã ã‹ã‚‰é–¢æ•°ãŒchannelã‚’è¿”ã™ãªã‚“ã¦ã“ã¨ã‚‚ã§ãã‚‹ã—ï¼Œé–¢æ•°ã®å¼•æ•°ã«channelã‚’ä¸ãˆã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã—ï¼Œchannelã®channelã‚‚å®šç¾©ã§ãã‚‹ï¼\nchannelã®å…¥å‡ºåŠ›ã®æ–¹å‘ã¯\u0026lt;-ã¨ã„ã†æ¼”ç®—å­ã§è¡¨ç¾ã™ã‚‹ã“ã¨ã«ãªã£ã¦ã„ã‚‹ï¼\u0026lt;- cã£ã¦æ›¸ã‘ã°channel cã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ã“ã¨ã«ãªã‚‹ã—ï¼Œc \u0026lt;- 1ã£ã¦æ›¸ã‘ã°channel cã«1ã‚’æ›¸ãè¾¼ã‚“ã ã“ã¨ã«ãªã‚‹ï¼\nã¨ã„ã†ã“ã¨ã§ï¼Œchannelã‚’ä½¿ã£ãŸç°¡å˜ã°ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã„ã¦ã¿ã‚‹ã¨ã“ã‚“ãªæ„Ÿã˜ã«ãªã‚‹ï¼\n channel done ã‚’ä½¿ã£ã¦ã€Œåƒ•ã¯è‡ªå·±ç´¹ä»‹çµ‚ã‚ã£ãŸã‚ˆãƒãƒã€ã£ã¦å­ä¾›ã®goroutineãŒè¦ªmainã«é€£çµ¡ã™ã‚‹ã“ã¨ã§ï¼Œå®Ÿè¡ŒãŒåŒæœŸã•ã‚Œã¦ä¸¡æ–¹ã®è‡ªå·±ç´¹ä»‹ãŒèã‘ã‚‹ã‚ˆã†ã«ãªã£ãŸï¼\nchannel doneã¯ã€Œboolå€¤ã‚’é€šã™ï¼Œãƒãƒƒãƒ•ã‚¡ãŒ0ã®ï¼Œèª­ã¿æ›¸ããŒã§ãã‚‹channelã€ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ï¼golangã§ã¯ã€Œãƒãƒƒãƒ•ã‚¡ãŒ0ã®channelã«å¯¾ã™ã‚‹èª­ã¿æ›¸ãã¯ï¼Œæƒ…å ±ã®é€å—ä¿¡ä¸¡è€…ãŒã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æº–å‚™ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã€ã“ã¨ã«ãªã£ã¦ã„ã‚‹ï¼ãªã®ã§ï¼Œã“ã®ä¾‹ã ã¨ï¼Œç¢ºå®Ÿã«å­ä¾›goroutineã®è‡ªå·±ç´¹ä»‹ã‚’èãã“ã¨ãŒã§ãã‚‹ã“ã¨ã«ãªã‚‹ï¼ã€Œãƒãƒƒãƒ•ã‚¡ãŒ0ã®channelã«å¯¾ã™ã‚‹èª­ã¿æ›¸ãã¯ï¼Œæƒ…å ±ã®é€å—ä¿¡ä¸¡è€…ãŒã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æº–å‚™ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã€ã¨ã„ã†æŒ™å‹•ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ãŒ0ã®channelã¯ã€Œsynchronousã€ã¨è¨€ãˆã‚‹ï¼\nä¸‹ã®ä¾‹ã‚’å®Ÿè¡Œã™ã‚‹ã¨ï¼Œchannel messageã«1ã‚’é€ã‚Šçµ‚ã‚ã£ã¦ã‹ã‚‰ï¼ŒmainãŒ1ç§’å¯ã¦ã—ã¾ã†ã®ã§ï¼Œå­ä¾›ã¯channel messageã«ç¶šã2ï¼Œ3ã‚’é€ã‚Œãªãã¦ï¼Œæ­¢ã‚ã‚‰ã‚Œã¦ã—ã¾ã†ï¼ã“ã®æŒ™å‹•ã¯synchronousã¨ã„ã†ã“ã¨ã«ãªã‚‹ï¼\n ä¸€æ–¹ã§ï¼Œãƒãƒƒãƒ•ã‚¡ã®ã‚ã‚‹channelã«å¯¾ã™ã‚‹èª­ã¿æ›¸ãã¯ã€Œãƒãƒƒãƒ•ã‚¡ãŒç©ºã§ãªã„ãªã‚‰èª­ã¿è¾¼ã¿ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãªã„ã€ã€Œãƒãƒƒãƒ•ã‚¡ãŒä¸€æ¯ã§ãªã„ãªã‚‰æ›¸ãè¾¼ã¿ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãªã„ã€ã¨ã„ã†æŒ™å‹•ã«ãªã£ã¦ã„ã‚‹ï¼ãªã®ã§ï¼Œãƒãƒƒãƒ•ã‚¡ã®ã‚ã‚‹channelã¯ã€Œasynchronousã€ã¨è¨€ãˆã‚‹ï¼\nä¸‹ã®ä¾‹ã‚’å®Ÿè¡Œã™ã‚‹ã¨ï¼Œchannel messageã¯ãƒãƒƒãƒ•ã‚¡ã‚’æŒã£ã¦ã„ã‚‹ã®ã§å­ä¾›ã¯1ï¼Œ2ï¼Œ3ï¼Œ4ã¨ï¼ˆmainãŒçœ ã‚Šã‹ã‚‰è¦šã‚ã‚‹å‰ã«ï¼‰ç«‹ã¦ç¶šã‘ã«é€ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ã“ã®æŒ™å‹•ã¯ã¾ã•ã—ãasynchronousã ï¼\nOh, poor deadlock... ã€Œgoroutineã‚‚channelã‚‚ã‚ã‹ã£ãŸã®ã§ã€ã¨ã„ã†ã“ã¨ã§ä¸‹ã¿ãŸã„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã¨deadlockã¨è¨€ã‚ã‚Œã¦golangã®runtimeã‹ã‚‰å±ã‚‰ã‚Œã‚‹ï¼\n ã“ã‚Œã¯ã¤ã¾ã‚Šã©ã†ã„ã†ã“ã¨ã‹ã¨ã„ã†ã¨ï¼Œgolangã®runtimeãŒã€ŒãŠå‰ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ å®Ÿè¡Œã—ãŸã‘ã©7è¡Œç›®ã§ãƒãƒƒãƒ•ã‚¡ã®ãªã„channelã«42ã£ã¦é€ã£ã¦ã‚‹ï¼ˆc \u0026lt;- 42ï¼‰ã‘ã©ï¼Œãã‚Œã—ãŸã‚‰å—ä¿¡è€…ãŒã„ãªã„ã—ï¼Œå—ä¿¡è€…ãŒã„ãªã„ã¨é€ä¿¡è€…ã‚‚å®Ÿè¡Œã‚’é€²ã‚ã‚‰ã‚Œãªã„ã®ã§ï¼Œã©ã†ã™ã‚‹ã“ã¨ã‚‚ã§ããªããªã£ã¡ã‚ƒã£ãŸãã€ã¨æ€’ã£ã¦ã„ã‚‹ã®ã ï¼\nã€Œãƒãƒƒãƒ•ã‚¡ã®ãªã„channelã¯goroutineé–“ã®æŒ™å‹•ã‚’synchronousã«ã™ã‚‹ã‚‚ã®ã€ãªã®ã§ã€Œå—ä¿¡è€…ã¨ãªã‚‹goroutineã®ã„ãªã„ï¼Œãƒãƒƒãƒ•ã‚¡0ã®channelã«å€¤ã‚’é€ã‚‹ã¨deadlockã™ã‚‹ã€ã®ã ï¼\nä»Šå›ã®å ´åˆã ã¨ï¼Œå—ä¿¡è€…ãŒå­˜åœ¨ã—ãªã„ã“ã¨ãŒå•é¡Œãªã®ã§ï¼Œå—ä¿¡è€…ã¨ãªã‚‹goroutineã‚’ä½œã‚Œã°ã†ã¾ãã„ãï¼\n Let's range channels and close them. channelã¯rangeæ§‹æ–‡ã‚’ä½¿ã£ã¦1ã¤ãšã¤å€¤ã‚’å–ã‚Šå‡ºã™ã¨ã„ã†ã“ã¨ã‚‚è¨˜è¿°ã§ãã‚‹ï¼ã§ã‚‚ï¼Œrangeã‚’ä½¿ã£ã¦channelã‹ã‚‰å€¤ã‚’æ¬¡ã€…å–ã‚Šå‡ºã™ã¨ãã¯channelã‚’æ˜ç¤ºçš„ã«close()ã—ãªã„ã¨ã„ã‘ãªã„ï¼\n ãƒãƒ£ãƒ³ãƒãƒ«ã¯çµ„ã¿è¾¼ã¿é–¢æ•°ã®close()ã§ã€Œé–‰ã˜ã‚‹ã€ã“ã¨ãŒã§ãã¦ï¼Œé–‰ã˜ã‚‰ã‚ŒãŸchannelã«å¯¾ã—ã¦æ›¸ãè¾¼ã¿ã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã¨golangã®runtimeã¯panicã—ã¦ï¼Œé–‰ã˜ã‚‰ã‚ŒãŸchannelã«å¯¾ã—ã¦èª­ã¿è¾¼ã¿ã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã¨ãã®channelã®æ‰±ã†å‹ã®ã‚¼ãƒ­å€¤ãŒå¾—ã‚‰ã‚Œã‚‹ã“ã¨ã«ãªã£ã¦ã„ã‚‹ï¼\nã€Œé–‰ã˜ã‚‰ã‚ŒãŸchannelã«å¯¾ã™ã‚‹èª­ã¿è¾¼ã¿ã€ã®ç‰¹å¾´ã¯ã€Œgoroutineã«å‡¦ç†ã®çµ‚äº†ã‚’é€šçŸ¥ã•ã›ã‚‹æ©Ÿæ§‹ã€ã¨ã—ã¦å¿œç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼å¤§æŠµï¼Œã“ã†ã„ã†å‡¦ç†çµ‚äº†é€šçŸ¥ã‚’è¡Œã†å ´åˆã¯ç©ºã®æ§‹é€ ä½“struct{}ã®channelã‚’ä½¿ã†ï¼ãªã‚“ã¦ã£ãŸã£ã¦ç©ºã®æ§‹é€ ä½“ã¯0byteã ã‹ã‚‰ã­ï¼\n ã‚ã¨ï¼Œé–‰ã˜ã‚‰ã‚ŒãŸchannelã«å¯¾ã™ã‚‹èª­ã¿è¾¼ã¿ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãªã„ã®ã§ï¼Œãã®ã¾ã¾å‡¦ç†ã¯é€²ã‚€ï¼\nMultiple channels and select. goroutineã¨channelã‚’ä½¿ã£ã¦å®Ÿéš›ã«ãªã‚“ã‚‰ã‹ã®æ„å‘³ã®ã‚ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã“ã†ã¨ã™ã‚‹ã¨ï¼ŒãŸãã•ã‚“ã®goroutineã¨ãŸãã•ã‚“ã®channelã‚’æ‰±ã†ã“ã¨ã«ãªã‚‹ã®ãŒæ™®é€šã§ã‚ã‚‹ï¼å¤§æŠµã®å ´åˆã€Œè¤‡æ•°ã®channelã‚’åŒæ™‚ã«å¾…ã¡å—ã‘ãŸã„ã€çŠ¶æ³ã«å‡ºãã‚ã™ï¼golangã§ã¯è¤‡æ•°ã®channelã‚’åŒæ™‚ã«å¾…ã¡å—ã‘ã‚‹selectæ§‹æ–‡ã‚’ç”¨æ„ã—ã¦ã„ã‚‹ï¼\n select { case ...: ...}ã¨ã„ã†æ§‹æ–‡ã§ï¼Œè¤‡æ•°ã®channelã‚’åŒæ™‚ã«å¾…ã¡å—ã‘ï¼Œå€¤ãŒæ›¸ãè¾¼ã¾ã‚ŒãŸchannelã ã‘ã«å¯¾å¿œã™ã‚‹ã¨ã„ã†ï¼Œã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã¿ãŸã„ãªå‡¦ç†ã‚‚ç°¡å˜ã«æ›¸ãã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ï¼\nchannelï¼ŒãŠå‰æœ€é«˜ã‹ã‚ˆï¼ channelã¯ãƒã‚¸ã§ä¾¿åˆ©ï¼ã§ã‚‚ä½¿ã„ã“ãªã™ã«ã¯channelã®æŒ™å‹•ã‚’ã‚ˆãç†è§£ã—ã¦ã„ãªã„ã¨ã„ã‘ãªã„ï¼\n","date":1572528748,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572528748,"objectID":"d1a9aaedba5cb2d487581db7040bf32b","permalink":"/ja/post/golang-channels-tutorial/","publishdate":"2019-10-31T22:32:28+09:00","relpermalink":"/ja/post/golang-channels-tutorial/","section":"post","summary":"Golangã®æ ¹ã£ã“ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹concurrencyã‚’å®Ÿç¾ã™ã‚‹é‡è¦ãªéƒ¨å“ã§ã‚ã‚‹channelã«ã¤ã„ã¦è§£èª¬ã—ã¾ã™ï¼","tags":["Goalg","Channel","Tutorial"],"title":"Golang channels tutorial","type":"post"},{"authors":[],"categories":[],"content":"æ—¥æœ¬èªã«ã™ã‚‹ã¨\u0026hellip; èª¿ã¹ã¦ã¿ã‚‹ã¨ï¼Œ**ã€ŒConcurrentã¯ä¸¦è¡Œã€ã€ŒParallelã¯ä¸¦åˆ—ã€**ã¨è¨³ã•ã‚Œã‚‹ã®ãŒä¸€èˆ¬çš„ã‚‰ã—ã„ã§ã™ãŒï¼Œæ—¥æœ¬èªã«ã—ãŸã¨ã“ã‚ã§é•ã„ãŒåˆ¤ç„¶ã¨ã—ãªã„ã®ã§ï¼Œè‡ªåˆ†ãªã‚Šã®è§£é‡ˆã‚’æ›¸ã„ã¦ã¯ã£ãã‚Šã•ã›ã¦ãŠãã¾ã™ï¼\nã£ã¨ï¼Œãã®å‰ã«åºƒè¾è‹‘ã«ã‚ˆã‚Œã°\u0026hellip;  ã€ä¸¦è¡Œã€‘ä¸¦ã³ã‚†ãã“ã¨ï¼ã¾ãŸï¼Œä¸¦ã³è¡Œãªã‚ã‚Œã‚‹ã“ã¨ï¼ã€Œä¸¡æ¡ˆã‚’ä¸¦è¡Œã—ã¦å¯©è­°ã™ã‚‹ã€\n  ã€ä¸¦åˆ—ã€‘ä¸¦ã³é€£ãªã‚‹ã“ã¨ï¼ç›´åˆ—ã®å¯¾ç¾©èª\n ãƒ€ãƒ¡ã ã£ãŸï¼\nã˜ã‚ƒã‚ï¼Œè‹±è‹±è¾å…¸ï¼ˆOxford Dictionaryï¼‰ã§å¼•ãã¨\u0026hellip;  concurrent\nExisting, happening, or done at the same time. â€˜there are three concurrent art fairs around the cityâ€™\n  parallel\n[Computing] Involving the simultaneous performance of operations. â€˜highly parallel multiprocessor systemsâ€™\n ã“ã‚Œã§ã‚‚ãƒ€ãƒ¡ã ã£ãŸï¼\nåƒ•ã®ç†è§£ Concurrent ä¸¦è¡Œã¨ã¯ã€Œè¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ãŒï¼Œè«–ç†çš„ã«ï¼ŒåŒæ™‚ã«å‡¦ç†ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆã‚‹ã“ã¨ã€\nå…·ä½“çš„ã«ã¯ï¼ŒCPUãŒ1ã‚³ã‚¢ã®æ™‚ä»£ã«ï¼Œã€Œä¸€ã¤ã®ãƒ‘ã‚½ã‚³ãƒ³ã§ãƒ–ãƒ©ã‚¦ã‚¸ãƒ³ã‚°ã—ãªãŒã‚‰ãƒ¡ãƒ¼ãƒ«ãŒèª­ã‚ã‚‹ç†ç”±ã€ã‚’èª¬æ˜ã™ã‚‹ã®ãŒã€ŒCPUãŒã‚¿ã‚¹ã‚¯ã‚’Concurrentã«å‡¦ç†ã—ã¦ã„ã‚‹ã‹ã‚‰ã€ã§ï¼Œã“ã‚ŒãŒåƒ•ã®ã€Œä¸¦è¡Œã€ã®ç†è§£ï¼\nç´°åˆ‡ã‚Œã«ãŸãã•ã‚“ã®ä»•äº‹ã‚’ã¡ã‚‡ã£ã¨ãšã¤é€²ã‚ã¦ï¼Œå…¨ä½“ã¨ã—ã¦è¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ãŒåŒæ™‚ã«å‡¦ç†ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆã‚‹ã£ã¦ã ã‘ã§ï¼Œå®Ÿéš›ã«è¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ãŒåŒæ™‚ã«å‡¦ç†ã•ã‚Œã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ï¼\n**ã€Œä¸€äººã§ã„ã‚ã‚“ãªä»•äº‹ã‚’åŒæ™‚ã«é€²ã‚ã¦ã„ã‚‹æ§˜ã€**ãŒä¸¦è¡Œï¼\nParallel ä¸¦åˆ—ã¨ã¯ã€Œè¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ãŒï¼Œç‰©ç†çš„ã«ï¼ŒåŒæ™‚ã«å‡¦ç†ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã€\nå…·ä½“çš„ã«ã¯ãƒãƒ«ãƒã‚³ã‚¢ã®ãƒ—ãƒ­ã‚»ãƒƒã‚µãŒï¼Œæ­è¼‰ã—ã¦ã„ã‚‹è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ãƒƒã‚µã‚’ã¡ã‚ƒã‚“ã¨ä½¿ã„åˆ‡ã£ã¦æ¼”ç®—ã‚’ã—ã¦ã„ã‚‹æ§˜ã¯ï¼Œä¸¦åˆ—ã¨ã„ã†è¨€è‘‰ã§å½¢å®¹ã§ãã‚‹ï¼\n**ã€Œè¤‡æ•°äººãŒåŒæ™‚ã«ï¼Œãã‚Œãã‚Œã®ä»•äº‹ã‚’é€²ã‚ã¦ã„ã‚‹æ§˜ã€**ãŒä¸¦åˆ—ï¼\nã¡ãªã¿ã«ï¼Œã€Œä¸¦åˆ—ã§ã‚ã‚Œã°å¸¸ã«ä¸¦è¡Œã§ã‚ã‚‹ã€ã¨ã„ã†ä¸»å¼µã‚‚ã‚ã‚‹ã‚‰ã—ã„ï¼ã€Œè¤‡æ•°äººãŒåŒæ™‚ã«ï¼Œãã‚Œãã‚Œã®ä»•äº‹ã‚’é€²ã‚ã¦ã„ã‚‹æ§˜ã€ã¯å´ã‹ã‚‰è¦‹ã‚‹ã¨ã€Œã„ã‚ã‚“ãªä»•äº‹ã‚’åŒæ™‚ã«é€²ã‚ã¦ã„ã‚‹ã€ã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‰ï¼Œç¢ºã‹ã«ãã†ã‹ã‚‚ã—ã‚Œãªã„ï¼\nRob Pikeå…ˆç”Ÿã«ã‚ˆã‚Œã°\u0026hellip;  Concurrency is about dealing with lots of things at once.\n  Parallelism is about doing lots of things at once.\n  Not the same, but related.\n  Concurrency is about structure, parallelism is about execution.\n  Concurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.\n ãªã‚‹ã»ã©\nçµå±€ãªã‚“ã ã£ã¦ã°ã‚ˆ\u0026hellip;   Concurrency is a way of structuring your program to make it easy to understand and scalable\n  and Parallelism is simply the execution of multiple goroutine in parallel\n  ref  Concurrency is not Parallelism  ","date":1572506814,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572506814,"objectID":"c7e7cdbec1dbcce85a754deadfc1e74c","permalink":"/ja/post/concurrent-vs-parallel/","publishdate":"2019-10-31T16:26:54+09:00","relpermalink":"/ja/post/concurrent-vs-parallel/","section":"post","summary":"ä¼¼ã¦ã‚‹ã‚ˆã†ã§é•ã†ã®ã§ã¡ã‚ƒã‚“ã¨åŒºåˆ¥ã—ãŸã„","tags":["Concurrent","Parallel","Terminology"],"title":"Concurrent v.s. Parallel","type":"post"},{"authors":[],"categories":[],"content":"0. ã“ã‚Œã¯ä½• åƒ•ãŒæœ€è¿‘ç ”ç©¶ã—ã¦ã„ã‚‹ã€Œä¸¦è¡Œã‚°ãƒ©ãƒ•å‡¦ç†ç³»ã€ã«é–¢é€£ã—ã¦ï¼Œåƒ•è‡ªèº«ã®ãƒ†ãƒ¼ãƒã«ãŠã„ã¦éå¸¸ã«å‚è€ƒã«ãªã£ãŸè«–æ–‡ã§ã‚ã‚‹Parallelizing Sequential Graph Computations1ã«ã¤ã„ã¦ï¼Œãã®è©³ç´°ã‚’ã¾ã¨ã‚ã¾ã—ãŸï¼ãªãŠï¼Œä»¥ä¸‹ã®è³‡æ–™ã®å†…å®¹ã¯å¤§å­¦ã®ã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ ã®ä¸€ç’°ã¨ã—ã¦è¡Œã‚ã‚ŒãŸç™ºè¡¨ä¼šã§ç”¨ã„ãŸãƒãƒ³ãƒ‰ã‚¢ã‚¦ãƒˆã§ã™ï¼\n1. èƒŒæ™¯ ä¸€å°ã®ãƒ¡ãƒ¢ãƒªã«è¼‰ã‚Šåˆ‡ã‚‰ãªã„ã»ã©å·¨å¤§ãªã‚°ãƒ©ãƒ•ã«å¯¾ã™ã‚‹è¨ˆç®—éœ€è¦ã®é«˜ã¾ã‚Šã‚’å—ã‘ï¼Œã‚°ãƒ©ãƒ•è¨ˆç®—ã‚’ä¸¦åˆ—å®Ÿè¡Œã™ã‚‹Pregel2ã‚„GraphLab3ã‚’ã¯ã˜ã‚ã¨ã™ã‚‹å‡¦ç†ç³»ãŒè€ƒæ¡ˆã•ã‚ŒãŸï¼ã“ã‚Œã‚‰ã¯ã€Œå„é ‚ç‚¹ã‚’ä¸€å°ã®è¨ˆç®—æ©Ÿã¨è¦‹ãªã—ï¼Œé ‚ç‚¹ã”ã¨ã«å‡¦ç†ã‚’å®Ÿè¡Œã—ï¼Œé ‚ç‚¹é–“ã§ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¨ã‚ŠãªãŒã‚‰çŠ¶æ…‹ã‚’æ›´æ–°ã—ï¼Œãã®åæŸã‚’ä»¥ã£ã¦å…¨ä½“ã®è§£ã¨ã™ã‚‹ã€ã‚ˆã†ãªThink Like A Vertex(TLAV)ã¨ã„ã†è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ï¼\nã—ã‹ã—ï¼Œæ—¢å­˜ã®ã‚°ãƒ©ãƒ•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ä¸¦åˆ—å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã‚’å‰æã¨ã—ã¦ã„ãªã„ãŸã‚ï¼Œã“ã‚Œã‚‰ã®å‡¦ç†ç³»ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ã¯å®Ÿè¡Œã—ãŸã„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’TLAVã«æ›¸ãä¸‹ã™å¿…è¦ãŒã‚ã‚‹ãŒï¼Œã“ã‚Œã¯å®¹æ˜“ãªä½œæ¥­ã§ã¯ãªã„ï¼ã‚°ãƒ©ãƒ•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯TLAVã®ç™»å ´ä»¥å‰ã‹ã‚‰ç ”ç©¶ã•ã‚Œã¦ã„ã¦ï¼Œå•é¡Œã‚’è§£æ±ºã™ã‚‹æœ€é©ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒæ—¢ã«å­˜åœ¨ã—ã¦ã„ã‚‹ã«ã‚‚é–¢ã‚ã‚‰ãšï¼ŒTLAVãªå‡¦ç†ç³»ã§ã¯ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å¤‰æ›ãŒä¼´ã†ãŸã‚ï¼Œæ•·å±…ãŒååˆ†ã«ä¸‹ãŒã£ãŸã¨ã¯è¨€ãˆãªã„ï¼\nãã“ã§ï¼Œæ—¢å­˜ã®ã‚°ãƒ©ãƒ•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ãã®ã¾ã¾ç”¨ã„ãªãŒã‚‰ã‚‚ï¼Œä¸¦åˆ—å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ãªå‡¦ç†ç³» $GRAPE$ ã‚’ææ¡ˆã™ã‚‹ï¼ $GRAPE$ ã§ã¯ï¼Œè¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã¨ã—ã¦ï¼Œæ—¢å­˜ã®åˆ†æ•£ã‚°ãƒ©ãƒ•å‡¦ç†ç³»ãŒæ¡ç”¨ã™ã‚‹TLAVã§ã¯ãªãï¼ŒPartial evaluation \u0026amp; Incremental Computationãƒ¢ãƒ‡ãƒ«(ä»¥ä¸‹$GRAPE$ãƒ¢ãƒ‡ãƒ«)ã‚’æ¡ç”¨ã—ï¼Œæ—¢å­˜ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãªãä¸¦åˆ—åŒ–ã•ã›ã‚‹ï¼åŒæ™‚ã«ï¼Œ$GRAPE$ãƒ¢ãƒ‡ãƒ«ã¯TLAVã¨æ¯”è¼ƒã—ã¦ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ã‚¹ãƒˆã‚’å°‘ãªãæŠ‘ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã“ã¨ã‹ã‚‰ã‚ˆã‚ŠåŠ¹ç‡çš„ãªè¨ˆç®—ã®å®Ÿè¡ŒãŒå¯èƒ½ã¨ãªã‚‹ï¼\n2. é–¢é€£ç ”ç©¶ åˆ†æ•£ã‚°ãƒ©ãƒ•å‡¦ç†ã®è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã®å¤‰é·ã¨$GRAPE$ãƒ¢ãƒ‡ãƒ«ã®ä½ç½®ä»˜ã‘ã‚’è¿°ã¹ã‚‹ï¼åˆ†æ•£ã‚°ãƒ©ãƒ•å‡¦ç†ã‚’å®Ÿç¾ã™ã‚‹è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã¨ã—ã¦ä»¥ä¸‹ã®äºŒã¤ãŒã‚ˆãç”¨ã„ã‚‰ã‚Œã‚‹ï¼\nThink Like A Vertex æœ€åˆã«ææ¡ˆã•ã‚ŒãŸè¨ˆç®—ãƒ¢ãƒ‡ãƒ«ï¼Pregelã‚„Giraph4ï¼ŒGraphLab5ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ï¼é ‚ç‚¹ã”ã¨ã«å‡¦ç†ã‚’å®Ÿè¡Œã—ï¼Œé ‚ç‚¹é–“ã§ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã¨ã‚ŠãªãŒã‚‰çŠ¶æ…‹ã‚’æ›´æ–°ï¼å…¨é ‚ç‚¹ã®çŠ¶æ…‹ã®åæŸã‚’ä»¥ã£ã¦å…¨ä½“ã®è§£ã¨ã™ã‚‹ï¼\nThink Like A Graph (or Block Centric) TLAVã‚’é«˜é€ŸåŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ç ”ç©¶ã®ä¸­ã§ææ¡ˆã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ï¼$n$å€‹ã®é ‚ç‚¹ã‚’ã¾ã¨ã‚ã¦æ‰±ã†ã“ã¨ã§ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ã‚¹ãƒˆã‚’æŠ‘ãˆï¼Œå®Ÿè¡ŒåŠ¹ç‡ã®å‘ä¸Šã‚’å›³ã‚‹ï¼Blogel6ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ï¼\nTLAVã¨Block Centricãƒ¢ãƒ‡ãƒ«ãŠã‚ˆã³$GRAPE$ãƒ¢ãƒ‡ãƒ«ã‚’ï¼Œå‡¦ç†å˜ä½ã®ç²’åº¦ï¼Œã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ã‚¹ãƒˆã®å¤§å°ï¼Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ã—ã‚„ã™ã•ã¨ã„ã†ä¸‰ã¤ã®è¦³ç‚¹ã‹ã‚‰æ•´ç†ã™ã‚‹ã¨ä¸‹è¡¨ã®ã‚ˆã†ã«ãªã‚‹ï¼\n   è¡¨1. åˆ†æ•£ã‚°ãƒ©ãƒ•è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã®æ¯”è¼ƒ   3. Partial evaluation \u0026amp; Incremental computation $GRAPE$ã§ã¯ï¼ŒPartial evaluation \u0026amp; Incremental computationã¨ã„ã†è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã‚’æ¡ç”¨ã—ã¦ã„ã‚‹ï¼ã“ã‚Œã¯ï¼Œæœ€åˆã«éƒ¨åˆ†ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦å®Ÿè¡Œã—ãŸã„å‡¦ç†ã‚’è¡Œã£ã¦éƒ¨åˆ†è§£ã‚’æ±‚ã‚ï¼Œãã®éƒ¨åˆ†è§£ã®æ›´æ–°ã‚’ç¹°ã‚Šè¿”ã—ã¦ã„ãã“ã¨ã§å…¨ä½“ã®è§£ã‚’æ±‚ã‚ã‚‹ã¨ã„ã†ãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ï¼\nPartial evaluation ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ æœ€é©åŒ–ã®æ–‡è„ˆã§ç™»å ´ã—ï¼ŒXMLæ–‡ç« ä¸­ã®è¦ç´ ã‚’æŒ‡å®šã™ã‚‹XPathã‚’åˆ†æ•£ç’°å¢ƒä¸‹ã§è©•ä¾¡ã™ã‚‹ç ”ç©¶ãªã©ã§ã‚‚å–ã‚Šä¸Šã’ã‚‰ã‚Œã¦ã„ã‚‹7ï¼\nIncremental computation å·¨å¤§ãªå‹•çš„ã‚°ãƒ©ãƒ•$G$ã«å¯¾ã™ã‚‹ã‚¯ã‚¨ãƒª$Q$ã®å¿œç­”é€Ÿåº¦ã‚’å‘ä¸Šã•ã›ã‚‹æŠ€è¡“ï¼ã‚°ãƒ©ãƒ•ã®å¤‰åŒ–$\\Delta G$ã‹ã‚‰$Q(G \\oplus \\Delta G) = Q(G) \\oplus \\Delta O$ã‚’æº€ãŸã™ã‚ˆã†ãªã‚¯ã‚¨ãƒªå‡ºåŠ›ã®å·®åˆ†$\\Delta O$ã‚’æ±‚ã‚ã‚‹ã“ã¨ã§ï¼Œã‚°ãƒ©ãƒ•å…¨ä½“ã‚’ç”¨ã„ã¦å†è¨ˆç®—ã™ã‚‹ã“ã¨ãªãï¼Œå¤‰åŒ–å¾Œã®ã‚°ãƒ©ãƒ•ã«å¯¾ã™ã‚‹ã‚¯ã‚¨ãƒªçµæœã‚’æ±‚ã‚ã‚‹8ï¼\nä¾‹ãˆã°ï¼Œå›³1ã®ã‚ˆã†ãª5ãƒãƒ¼ãƒ‰ã‹ã‚‰ãªã‚‹ã‚°ãƒ©ãƒ•$G$ã‚’ä¸‰ã¤ã®éƒ¨åˆ†ã‚°ãƒ©ãƒ•$F_1$ï¼Œ$F_2$ï¼Œ$F_3$ã«åˆ†å‰²ã™ã‚‹ï¼éƒ¨åˆ†ã‚°ãƒ©ãƒ•ã¯ï¼Œãã‚Œã‚’æ§‹æˆã™ã‚‹ãƒãƒ¼ãƒ‰ã¨ãã®ãƒãƒ¼ãƒ‰ã‚’å§‹ç‚¹ã¨ã™ã‚‹ã‚¨ãƒƒã‚¸ã®çµ‚ç‚¹ã‚‚å«ã‚ã‚‹ã‚‚ã®ã¨ã—ã¦ä¸ãˆã‚‹ï¼ä¾‹ãˆã°ï¼Œéƒ¨åˆ†ã‚°ãƒ©ãƒ•$F_1$ã¯å›³2ã¨ãªã‚‹ï¼ã“ã“ã§ï¼Œã‚°ãƒ©ãƒ•$G$ã«å¯¾ã—ã¦ãƒãƒ¼ãƒ‰$1$ã‚’å§‹ç‚¹ã¨ã™ã‚‹å˜ä¸€å§‹ç‚¹æœ€çŸ­çµŒè·¯å•é¡Œ(SSSP)ã‚’è€ƒãˆã‚‹ï¼$GRAPE$ã§ã¯ã¾ãšï¼Œéƒ¨åˆ†ã‚°ãƒ©ãƒ•$F_1$ã«å¯¾ã—ã¦ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã‚’ç”¨ã„ã¦è¨ˆç®—ã™ã‚‹ï¼ã“ã®çµæœã¯$G$å…¨ä½“ã«å¯¾ã™ã‚‹SSSPã®è§£ã§ã¯ãªã„ãŒï¼Œã“ã®çµæœã¯å…¨ä½“ã®è§£ã®ãŸãŸãå°ã¨ãªã£ã¦ã„ã‚‹ï¼ã“ã®ã€Œéƒ¨åˆ†ã‚°ãƒ©ãƒ•$F_1$ã«å¯¾ã™ã‚‹ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã®é©ç”¨ã€ãŒPartial evaluationã§ã‚ã‚‹ï¼\n    å›³1. å…¨ä½“ã‚°ãƒ©ãƒ•      å›³2. éƒ¨åˆ†ã‚°ãƒ©ãƒ• $F_1$   $F_1$ã«ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã§è¡¨2ã‚’å¾—ã‚‹ï¼ã“ã“ã§ï¼Œãƒãƒ¼ãƒ‰$4$ãŠã‚ˆã³$5$ã®ã‚³ã‚¹ãƒˆãŒè¨ˆç®—ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«æ³¨ç›®ã™ã‚‹ï¼ã“ã‚Œã¯ï¼Œ$F_1$ã®partial evaluationã®çµæœã‹ã‚‰ï¼Œ$F_3$ã®çŠ¶æ…‹ãŒå¤‰åŒ–ã—ãŸ(è¡¨3ã«ãŠã‘ã‚‹ãƒãƒ¼ãƒ‰$4$ãŠã‚ˆã³$5$ã®åˆæœŸçŠ¶æ…‹ã‹ã‚‰ã®å¤‰åŒ–)ã¨ã„ã†ã“ã¨ã§ã‚ã‚Šï¼Œã“ã®å¤‰åŒ–ã‚’å…ƒã«$F_3$ã«å¯¾ã—ã¦ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã§å…¨ä½“è§£ã«åæŸã—ã¦ã„ãï¼ã“ã‚ŒãŒï¼Œ$GRAPE$ã®Incremental computationã§ã‚ã‚‹ï¼\n    è¡¨2. éƒ¨åˆ†ã‚°ãƒ©ãƒ•$F_1$ã«å¯¾ã™ã‚‹Partial evaluation      è¡¨3. éƒ¨åˆ†ã‚°ãƒ©ãƒ•$F_3$ã«å¯¾ã™ã‚‹Incremental computation   4. $GRAPE$ Partial evaluation \u0026amp; Incremental computationã‚’å›³3ã®ã‚ˆã†ã«çµ„ã¿ä¸Šã’ã‚‹ã“ã¨ã§å‡¦ç†ç³»$GRAPE$ã‚’å®Ÿç¾ã™ã‚‹ï¼\n   å›³3. $GRAPE$   $GRAPE$ã®åˆ©ç”¨è€…ã¯å®Ÿè¡Œã—ãŸã„å‡¦ç†ã‚’ï¼Œ$\\sf PEval$(Partial evaluationç›¸å½“)ï¼Œ$\\sf IncEval$(Incremental computation)ç›¸å½“ï¼Œéƒ¨åˆ†è§£ã‚’ã¾ã¨ã‚ã‚‹$\\sf Assemble$ã¨ã„ã†ä¸‰ã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦$GRAPE$ã«ä¸ãˆã‚‹ï¼$GRAPE$ã¯ä¸€ã¤ã®$\\tt coordinator$ã¨è¤‡æ•°ã®$\\tt worker$ã§æ§‹æˆã•ã‚Œï¼Œ$\\tt coordinator$ã¯éƒ¨åˆ†ã‚°ãƒ©ãƒ•é–“ã®æ¥ç¶šé–¢ä¿‚ã‚„ã©ã®$\\tt worker$ãŒã©ã®éƒ¨åˆ†ã‚°ãƒ©ãƒ•ã‚’æ‹…å½“ã™ã‚‹ã‹ã‚’ç®¡ç†ã—ã¦ã„ã‚‹ï¼$\\tt worker$ã¯å„è‡ªãŒæ‹…å½“ã™ã‚‹éƒ¨åˆ†ã‚°ãƒ©ãƒ•ã«$\\sf PEval$ã‚„$\\sf IncEval$ã‚’é©ç”¨ã™ã‚‹ï¼\n$GRAPE$ã§ã®æ¼”ç®—ã¯ä¸‰ã¤ã®ãƒ•ã‚§ãƒ¼ã‚ºã‹ã‚‰æˆã‚‹ï¼ã¾ãš$\\tt coordinator$ãŒã‚¯ã‚¨ãƒªã®å®Ÿè¡Œã‚’å—ã‘ä»˜ã‘ï¼Œ$\\tt worker$ãŒå„è‡ªãŒæ‹…å½“ã—ã¦ã„ã‚‹éƒ¨åˆ†ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦$\\sf PEval$ã‚’å®Ÿè¡Œã™ã‚‹ï¼æ¬¡ã«, å„$\\tt worker$ãŒéƒ¨åˆ†ã‚°ãƒ©ãƒ•ã®çŠ¶æ…‹å¤‰åŒ–ã‚’$\\tt coordinator$ã«é€šçŸ¥ã™ã‚‹ï¼$\\tt coordinator$ã¯éƒ¨åˆ†ã‚°ãƒ©ãƒ•åŒå£«ã®æ¥ç¶šé–¢ä¿‚ã‚’è€ƒæ…®ã—ï¼Œå¯¾å¿œã™ã‚‹$\\tt worker$ã«å¤‰åŒ–ã‚’ä¼é”ã™ã‚‹ï¼çŸ¥ã‚‰ã›ã‚’å—ã‘ãŸ$\\tt worker$ã¯ï¼ŒçŠ¶æ…‹å¤‰åŒ–ã«åŸºã¥ã$\\sf IncEval$ã‚’å®Ÿè¡Œã—è‡ªåˆ†ã®æ‹…å½“ã—ã¦ã„ã‚‹éƒ¨åˆ†ã‚°ãƒ©ãƒ•ã®çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹ï¼$\\sf IncEval$ã¯æ›´æ–°ãŒç™ºç”Ÿã—ãªããªã‚‹ã¾ã§ç¹°ã‚Šè¿”ã•ã‚Œã‚‹ï¼$\\sf IncEval$ãŒåæŸã™ã‚‹ã¨ï¼Œ$\\tt coordinator$ã¯å„$\\tt worker$ã‹ã‚‰éƒ¨åˆ†è§£ã‚’å›åã—ï¼Œæœ€çµ‚çš„ãªå‡ºåŠ›ã‚’å¾—ã‚‹ï¼\n5. $GRAPE$ã®ã‚¢ãƒ‰ãƒãƒ³ãƒ†ãƒ¼ã‚¸ $GRAPE$ã¯å‡¦ç†åŠ¹ç‡ã¨$GRAPE$ãƒ¢ãƒ‡ãƒ«ã®è¡¨ç¾åŠ›ã«ãŠã„ã¦ï¼Œæ—¢å­˜ã®å‡¦ç†ç³»ã«å¯¾ã—ã¦ã‚¢ãƒ‰ãƒãƒ³ãƒ†ãƒ¼ã‚¸ãŒã‚ã‚‹ï¼$GRAPE$ã§ã¯éƒ¨åˆ†ã‚°ãƒ©ãƒ•é–“ã®çŠ¶æ…‹å¤‰åŒ–ã‚’ã‚„ã‚Šå–ã‚Šã™ã‚‹ã‚³ã‚¹ãƒˆã®ã¿ã§æ¸ˆã‚€ãŸã‚ï¼ŒTLAVã¨æ¯”è¼ƒã—ã¦å¤§å¹…ã«ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ã‚¹ãƒˆãŒæŠ‘ãˆã‚‰ã‚Œã‚‹ï¼ã“ã‚Œã«ã‚ˆã£ã¦ï¼ŒTLAVã‚ˆã‚Šã‚‚åŠ¹ç‡çš„ãªå‡¦ç†ãŒå®Ÿè¡Œã§ãã‚‹ï¼ã•ã‚‰ã«$GRAPE$ã§å®Ÿè¡Œã•ã‚Œã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯æ—¢å­˜ã®ã‚‚ã®ã¨å¤‰ã‚ã‚‰ãªã„ãŸã‚ï¼Œæ—¢å­˜ã®ã‚°ãƒ©ãƒ•æœ€é©åŒ–æŠ€æ³•ã‚’é©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãï¼Œã•ã‚‰ãªã‚‹é«˜é€ŸåŒ–ã‚‚è¦‹è¾¼ã‚€ã“ã¨ãŒã§ãã‚‹ï¼åŠ ãˆã¦ï¼Œ$\\sf MapReduce$ãªã©ä»–ã®åˆ†æ•£è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã‚’$GRAPE$ä¸Šã«è¡¨ç¾ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã‚ã‚‹ï¼ä¾‹ãˆã°$\\sf IncEval$ã§ã‚„ã‚Šå–ã‚Šã™ã‚‹æƒ…å ±ã‚’\u0026lt;key: value\u0026gt;ã¨ã—ã¦$\\sf PEval$ã¨å¶æ•°å›ç›®ã®$\\sf IncEval$ã‚’$\\sf Map$ã«ï¼Œå¥‡æ•°å›ç›®ã®$\\sf IncEval$ã‚’$\\sf Reduce$ã¨ã™ã‚Œã°$\\sf MapReduce$ã‚’è¡¨ç¾ã§ãã‚‹ï¼\n6. è©•ä¾¡ $GRAPE$ãƒ¢ãƒ‡ãƒ«ãŒTLAVã‚ˆã‚Šã‚‚\n å‡¦ç†æ™‚é–“ ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ã‚¹ãƒˆ ã‚°ãƒ©ãƒ•ã®è¦æ¨¡ã«å¯¾ã™ã‚‹ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£  ã®ä¸‰ç‚¹ã«ãŠã„ã¦ï¼ŒTLAVã¨ã®æ€§èƒ½ã‚’æ¯”è¼ƒã—$GRAPE$ãƒ¢ãƒ‡ãƒ«ã®å„ªä½æ€§ã‚’æ¤œè¨¼ã—ãŸï¼ãƒ—ãƒ­ã‚»ãƒƒã‚µã®æ•°ã‚’64ã‹ã‚‰192ã¾ã§å¤‰åŒ–ã•ã›ãªãŒã‚‰ï¼ŒliveJournal9ãªã©è¤‡æ•°ã®å®Ÿä¸–ç•Œã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦å˜ä¸€å§‹ç‚¹æœ€å°çµŒè·¯å•é¡Œã‚’Giraphï¼ŒGraphLabï¼ŒBlogelï¼Œ$GRAPE$ã§å®Ÿè¡Œã—ãŸçµæœã‚’å›³4ã«ç¤ºã™ï¼$GRAPE$ã¯Giraphï¼ŒGraphLabï¼ŒBlogeã¨æ¯”ã¹ã¦484ï¼Œ36ï¼Œ15å€é«˜é€Ÿã«å‡¦ç†ã‚’å®Ÿè¡Œã—ï¼Œ$\\tt worker$é–“ã§ã‚„ã‚Šå–ã‚Šã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿é‡ã‚’0.07%ï¼Œ0.12%ï¼Œ0.7%ã«æŠ‘ãˆã‚‰ã‚Œã¦ã„ã‚‹ï¼\nã‚°ãƒ©ãƒ•ã®è¦æ¨¡ã«å¯¾ã™ã‚‹ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã‚’ï¼Œå…¥åŠ›ã‚°ãƒ©ãƒ•ã‚’5Mãƒãƒ¼ãƒ‰50Mã‚¨ãƒƒã‚¸ã‹ã‚‰25Mãƒãƒ¼ãƒ‰250Mã‚¨ãƒƒã‚¸ã¾ã§å¤‰åŒ–ã•ã›ãªãŒã‚‰å®Ÿè¡Œæ™‚é–“ã¨ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ã‚¹ãƒˆã‚’è¨ˆæ¸¬ã—ãŸï¼ãã®çµæœã‚’å›³5ã®å·¦äºŒå›³ã«ç¤ºã™ï¼ã‚°ãƒ©ãƒ•è¦æ¨¡ã«å¯¾ã—ã¦ååˆ†ã«ã‚¹ã‚±ãƒ¼ãƒ«ã—ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ï¼\nå›³5ã®å³ç«¯å›³ã‹ã‚‰ï¼Œ${GRAPE}$ã§ã¯ï¼Œä¸¦åˆ—å®Ÿè¡Œã«ä¼´ã†ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’è€ƒæ…®ã—ã¦ã‚‚ãªãŠï¼Œæ—¢å­˜ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«å¯¾ã™ã‚‹é«˜é€ŸåŒ–æŠ€æ³•ã®åŠ¹æœãŒå¾—ã‚‰ã‚Œã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ï¼\n    è¡¨4. å‡¦ç†ç³»ã”ã¨ã®å®Ÿè¡Œæ™‚é–“ã¨ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ã‚¹ãƒˆ      è¡¨5. ${GRAPE}$ã®ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ãƒ¼ã¨ã‚°ãƒ©ãƒ•ãƒ¬ãƒ™ãƒ«æœ€é©åŒ–ã®åŠ¹æœ   7. çµè«– Partial evaluation \u0026amp; Incremental computationã¨ã„ã†è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã¯ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦ã‚‚æœ‰åŠ¹ã§ã‚ã‚Šï¼Œã“ã®è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ æ—¢å­˜ã®ã‚°ãƒ©ãƒ•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ã»ã¼å¤‰æ›´ã™ã‚‹ã“ã¨ãªãä¸¦åˆ—åŒ–ã‚’å®Ÿç¾ã§ãï¼Œåˆ†æ•£ã‚°ãƒ©ãƒ•å‡¦ç†ç³»ã‚’åˆ©ç”¨ã™ã‚‹æ•·å±…ã‚’ä¸‹ã’ã‚‰ã‚Œã‚‹ï¼ãã“ã§Partial evaluation \u0026amp; Incremental computationã‚’å®Ÿè£…ã™ã‚‹å‡¦ç†ç³»$GRAPE$ã‚’ææ¡ˆã™ã‚‹ï¼Partial evaluationã«ç›¸å½“ã™ã‚‹$\\sf PEval$ã¨Incremental computationã«ç›¸å½“ã™ã‚‹$\\sf IncEval$ï¼Œéƒ¨åˆ†è§£ã‚’é›†ã‚ã‚‹$\\sf Assemble$ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§æ—¢å­˜ã®ã‚°ãƒ©ãƒ•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ä¸¦åˆ—åŒ–ã‚’å®Ÿç¾ã™ã‚‹ï¼\n    Wenfei Fan, Wenyuan Yu, Jingbo Xu, Jingren Zhou, Xiaojian Luo, Qiang Yin, Ping Lu, Yang Cao, and Ruiqi Xu. 2018. Parallelizing Sequential Graph Computations. ACM Trans. Database Syst. 43, 4, Article 18 (December 2018), 39 pages. DOI: https://doi.org/10.1145/3282488 ^ Grzegorz Malewicz, Matthew H. Austern, Aart J.C Bik, JamesC. Dehnert, Ilan Horn, Naty Leiser, and Grzegorz Czajkowski.2010. Pregel: a system for large-scale graph processing. In Pro-ceedings of the 2010 ACM SIGMOD International Conferenceon Management of data (SIGMOD â€™10). ACM, New York, NY,USA, 135-146. ^ Yucheng Low, Danny Bickson, Joseph Gonzalez, CarlosGuestrin, Aapo Kyrola, and Joseph M. Hellerstein. 2012. Dis-tributed GraphLab: a framework for machine learning and datamining in the cloud. Proc. VLDB Endow. 5, 8 (April 2012),716-727. ^ Giraph. http://giraph.apache.org/ ^ Yucheng Low, Danny Bickson, Joseph Gonzalez, CarlosGuestrin, Aapo Kyrola, and Joseph M. Hellerstein. 2012. Dis-tributed GraphLab: a framework for machine learning and datamining in the cloud. Proc. VLDB Endow. 5, 8 (April 2012),716-727. ^ Da Yan, James Cheng, Yi Lu, and Wilfred Ng. 2014. Blogel:a block-centric framework for distributed computation on real-world graphs. Proc. VLDB Endow. 7, 14 (October 2014), 1981-1992. ^ Peter Buneman, Gao Cong, Wenfei Fan, and Anastasios Ke-mentsietsidis. 2006. Using partial evaluation in distributedquery evaluation. In Proceedings of the 32nd international con-ference on Very large data bases (VLDB â€™06), UmeshwarDayal, Khu-Yong Whang, David Lomet, Gustavo Alonso, GuyLohman, Martin Kersten, Sang K. Cha, and Young-Kuk Kim(Eds.). VLDB Endowment 211-222 ^ Wenfei Fan, Chunming Hu, and Chao Tian. 2017. Incremen-tal Graph Computations: Doable and Undoable. In Proceedingsof the 2017 ACM International Conference on Management ofData (SIGMOD â€™17). ACM, New York, NY, USA, 155-169. ^ Snap. http://snap.stanford.edu/data/index.html ^   ","date":1572360869,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572360869,"objectID":"968af61da1967f4fa2f595bb94735e9d","permalink":"/ja/post/parallelizing-sequential-graph-computations/","publishdate":"2019-10-29T23:54:29+09:00","relpermalink":"/ja/post/parallelizing-sequential-graph-computations/","section":"post","summary":"åƒ•ãŒæœ€è¿‘ç ”ç©¶ã—ã¦ã„ã‚‹ã€Œä¸¦è¡Œã‚°ãƒ©ãƒ•å‡¦ç†ç³»ã€ã«é–¢é€£ã—ã¦ï¼Œåƒ•è‡ªèº«ã®ãƒ†ãƒ¼ãƒã«ãŠã„ã¦éå¸¸ã«å‚è€ƒã«ãªã£ãŸè«–æ–‡ã§ã‚ã‚‹Parallelizing Sequential Graph Computationsã«ã¤ã„ã¦ï¼Œãã®è©³ç´°ã‚’ã¾ã¨ã‚ã¾ã—ãŸï¼","tags":["Parallel Graph Computation","Graph","Parallel Computation","GRAPE","Distributed Graph Processing"],"title":"Parallelizing Sequential Graph Computations","type":"post"},{"authors":[],"categories":[],"content":"ã‚ã‚‹äººã«ã‚ˆã‚Œã°\u0026hellip;  Simulation = For analysis and study\n  Emulation = For usage as a substitute\n  A simulator is an environment which models but an emulator is one that replicates the usage as on the original device or system.\n  Simulator mimics the activity of something that it is simulating. It \u0026ldquo;appears\u0026rdquo; (a lot can go with this \u0026ldquo;appears\u0026rdquo;, depending on the context) to be the same as the thing being simulated. For example the flight simulator \u0026ldquo;appears\u0026rdquo; to be a real flight to the user, although it does not transport you from one place to another.\n  Emulator, on the other hand, actually \u0026ldquo;does\u0026rdquo; what the thing being emulated does, and in doing so it too \u0026ldquo;appears to be doing the same thing\u0026rdquo;. An emulator may use different set of protocols for mimicking the thing being emulated, but the result/outcome is always the same as the original object. For example, EMU8086 emulates the 8086 microprocessor on your computer, which obviously is not running on 8086 (= different protocols), but the output it gives is what a real 8086 would give.\n ã¾ãŸåˆ¥ã®äººã«ã‚ˆã‚Œã°\u0026hellip;   Simulator is broader than Emulator    Simulator tends to imitate/model more global processes/things in general with ability to narrow the imitation down (e.g. capacitor simulator with presets representing some known models)    Emulator tends to imitate certain hardware devices with certain specification, known characteristics and properties (e.g. SNES emulator, Intel 8087 or Roland TB-303)   èªæºã‚’è¾¿ã‚‹ã¨\u0026hellip;   emulate is \u0026ldquo;to be equal\u0026rdquo; (looks like more aggressive and straightforward - rivalry) simulate is \u0026ldquo;to be similar\u0026rdquo; (looks like more sly and tricky - imitation)   æ—¥æœ¬èªã ã¨\u0026hellip;  Emulation: ï¼ˆä»£æ›¿å¯èƒ½ãªãƒ¬ãƒ™ãƒ«ã§ã®ï¼‰æ¨¡å€£ Simulation: æ¨¡æ“¬  ã‹ãªï¼ŸğŸ¤”\nReference  Simulator or Emulator? What is the difference?  ","date":1572359078,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572359078,"objectID":"705d566c5c9beb942ffe89b0794f72f7","permalink":"/ja/post/simulator-vs-emulator/","publishdate":"2019-10-29T23:24:38+09:00","relpermalink":"/ja/post/simulator-vs-emulator/","section":"post","summary":"ä¼¼ã¦éãªã‚‹ã‚‚ã®","tags":["Simulator","Emulator","Terminology"],"title":"Emulator v.s. Simulator","type":"post"},{"authors":[],"categories":[],"content":"GitHubä¸Šã§ã®merge GitHubä¸Šã§è¡Œãˆã‚‹mergeã«ã¯3ç¨®é¡ã‚ã‚Šã¾ã™ï¼\n Create a merge commit Squash and merge Rebase and merge  ã“ã‚Œã‚‰ã¯ï¼Œã€Œmerge commitã®æœ‰ç„¡ã€ã€Œmerge commitã®authorãŒèª°ã«ãªã‚‹ã®ã‹ã€ãªã©ã®ç‚¹ã§å¾®å¦™ã«ç•°ãªã‚Šã¾ã™ï¼\n   Command merge commitã®æœ‰ç„¡ merge commitã®author mergeå…ƒã®branchã®commit log     Create a merge commit æœ‰ mergeå…ˆ æ®‹ã‚‹   Squash and merge æœ‰ mergeå…ƒ æ®‹ã‚‰ãªã„   Rebase and merge ç„¡  æ®‹ã‚‹    Create a merge commit ã€ŒCreate a merge commitã€ã§ã¯ï¼Œgit merge --no-ffã§mergeã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ï¼ã¤ã¾ã‚Šï¼Œmergeå…ˆã«æ–°ãŸãªcommitãŒä½œæˆã•ã‚Œï¼Œãã®commitãŒmergeå…ƒã®commitã‚’å–ã‚Šè¾¼ã¿ã¾ã™ï¼ã“ã®ã¨ãä½œæˆã•ã‚Œã‚‹merge commitã®authorã¯mergeå…ˆã®authorã¨ã—ã¦è¨˜éŒ²ã•ã‚Œã¾ã™ï¼\nã“ã®æ–¹æ³•ã¯\n ã€Œä½•ã‚’mergeã—ãŸã®ã‹ã€ãŒmerge commitã¨ã„ã†å½¢ã§è¨˜éŒ²ã¨ã—ã¦æ®‹ã‚‹ mergeå…ƒã®branchãŒãã®ã¾ã¾æ®‹ã‚‹ã®ã§å¤‰æ›´ç®‡æ‰€ã‚’è¿½ã„ã‚„ã™ã„ mergeå¾Œã«ï¼Œmergeå…ƒã®branchã‚’å‰Šé™¤ã—ãŸã¨ã—ã¦ã‚‚ï¼Œã“ã®branchã®commit logãŒmergeå…ˆã«æ®‹ã‚‹  ã¨ã„ã†ç‰¹å¾´ãŒã‚ã‚Šã¾ã™ï¼ã‚ã‹ã‚Šã‚„ã™ã„ä¸€æ–¹ã§ï¼Œã€Œmerge commitã®authorãŒmergeå…ƒã§ã¯ãªã„ã€ã®ãŒï¼ˆå€‹äººçš„ã«ï¼‰ã€Œãã®äººã®é ‘å¼µã‚Šã‚’è®ƒãˆãŸã„ã®ã«ãªãã€ã¨ã‹æ€ã£ã¡ã‚ƒã£ãŸã‚Šã—ã¦ã¡ã‚‡ã£ã¨ç”³ã—è¨³ãªã„æ°—ãŒã™ã‚‹ã¨ã‹ã—ãªã„ã¨ã‹ï¼\n   Create a merge commit   Squash and merge ã€ŒSquash and mergeã€ã§ã¯ï¼Œgit merge --squashã§mergeã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ï¼ã¤ã¾ã‚Šï¼Œmergeå…ƒã®commitã‚’ä¸€ã¤ã®commitã«ã¾ã¨ã‚ãŸä¸Šã§ï¼Œmergeå…ˆã«merge commitã¨ã—ã¦å…ˆé ­ã«è¿½åŠ ã•ã‚Œã¾ã™ï¼ã“ã®ã¨ãã®merge commitã®authorã¯mergeå…ƒã®authorã¨ãªã‚Šã¾ã™ï¼\nã“ã®æ–¹æ³•ã¯\n ã€Œä½•ã‚’mergeã—ãŸã®ã‹ã€ãŒmerge commitã¨ã„ã†å½¢ã§è¨˜éŒ²ã¨ã—ã¦æ®‹ã‚‹ è¤‡æ•°ã®commitã‚’ã¾ã¨ã‚ã¦ä¸€ã¤ã«ã§ãã‚‹ã®ã§mergeå…ˆã®commit logãŒã‚ã‹ã‚Šã‚„ã™ã„  ã¨ã„ã†ç‰¹å¾´ãŒã‚ã‚Šã¾ã™ï¼ä¸€æ–¹ã§ï¼Œä¸€åº¦commitã‚’ã¾ã¨ã‚ã¦ã—ã¾ã†ã¨ï¼Œã€Œã©ã®å¤‰æ›´ãŒèª°ã«ã‚ˆã£ã¦ã©ã®commitã§è¡Œã‚ã‚ŒãŸã®ã‹ã€ã¨ã„ã†æƒ…å ±ãŒå¤±ã‚ã‚Œã¦ã—ã¾ã†ã“ã¨ã«ãªã‚Šã¾ã™ï¼ä»–ã®äººã®è¤‡æ•°ã®commitã‚’ä¸€ã¤ã®commitã«æŠ¼ã—è¾¼ã‚€ã“ã¨ã«ãªã‚‹ã®ã§ï¼Œå€‹äººçš„ã«ã¯è‹¥å¹²æ€–ã•ãŒã‚ã‚Šã¾ã™ï¼\n   Squash and merge   Rebase and merge ã€ŒRebase and mergeã€ã§ã¯ï¼Œã¾ãšmergeå…ƒã®ãƒ–ãƒ©ãƒ³ãƒã«ã‚ã‚‹commitåˆ—ã«å¯¾ã—ã¦git rebaseã—ã¦ï¼Œcommitåˆ—ãŒä¸€åˆ—ã«ãªã£ãŸã¨ã“ã‚ã§fast-forwardã®å½¢ã§mergeãŒå®Ÿè¡Œã•ã‚Œã¾ã™ï¼\nã“ã®æ–¹æ³•ã¯\n mergeã—ãŸçµæœï¼Œmergeå…ˆã®commit logãŒä¸€ç›´ç·šã§è¦‹ã‚„ã™ã„ merge commitãŒä½œæˆã•ã‚Œãªã„  ã¨ã„ã†ç‰¹å¾´ãŒã‚ã‚Šã¾ã™ï¼\n   Rebase and merge   Reference  About merge methods on GitHub  ","date":1572346258,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572346258,"objectID":"23d6b53e02b5322745a0e712092cb5bf","permalink":"/ja/post/three-kinds-of-merge-on-github/","publishdate":"2019-10-29T19:50:58+09:00","relpermalink":"/ja/post/three-kinds-of-merge-on-github/","section":"post","summary":"GitHubä¸Šã§å®Ÿè¡Œã§ãã‚‹3ç¨®é¡ã®mergeã«ã¤ã„ã¦ã€Œã©ã®ã‚ˆã†ãªã‚‚ã®ãªã®ã‹ï¼Ÿã€ã‚’ã¾ã¨ã‚ã¾ã—ãŸï¼","tags":["GitHub","Git","Tips"],"title":"GitHubä¸Šã§ã®merge","type":"post"},{"authors":[],"categories":[],"content":"Federated Social Webã¨ã¯ï¼Ÿ Federated Social Webã¨ã¯ï¼Œèª¤è§£ã‚’æã‚Œãšç«¯çš„ã«è¨€ãˆã°ã€Œåˆ†æ•£Twitterã€ã§ã‚ã‚‹ï¼\nã€Œåˆ†æ•£Twitterã€ã¨ã¯ä½•ã‹ã‚’èª¬æ˜ã™ã‚‹ã«ã¯ï¼ŒTwitterã¨å¯¾æ¯”ã™ã‚‹ã®ãŒã‚ã‹ã‚Šã‚„ã™ã„ï¼Twitterã¯Twitterç¤¾ãŒæä¾›ã—ã¦ã„ã‚‹ãƒã‚¤ã‚¯ãƒ­ãƒ–ãƒ­ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã§ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯Twitterç¤¾ãŒç®¡ç†ã™ã‚‹ã‚µãƒ¼ãƒãƒ¼ä¸Šã«å±•é–‹ã•ã‚Œã¦ã„ã‚‹Twitterã¨ã„ã†ã‚·ã‚¹ãƒ†ãƒ å†…ã«ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ï¼Œãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚„å‹•ç”»åƒã‚’æŠ•ç¨¿ï¼ˆãƒ„ã‚¤ãƒ¼ãƒˆï¼‰ã—ãŸã‚Šæ‹¡æ•£ï¼ˆãƒªãƒ„ã‚¤ãƒ¼ãƒˆï¼‰ã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã”ã¨ã«ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã¨ã„ã†ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ãŒæä¾›ã•ã‚Œï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’é€šã˜ã¦ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’é–²è¦§ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼Twitterã¯ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ã€ŒFollowã™ã‚‹ã€ã¨ã„ã†æ©Ÿèƒ½ã‚‚å®Ÿè£…ã—ã¦ã„ã‚‹ï¼ã“ã‚Œã¯ã€Œä»–ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¨¿ã‚’è‡ªåˆ†ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã«è¡¨ç¤ºã™ã‚‹æ©Ÿèƒ½ã€ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯å¥½ã¿ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æŠ•ç¨¿ã—ã¦ãã‚Œã‚‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã™ã‚‹ã“ã¨ã§ï¼Œã‚ˆã‚Šç°¡å˜ã«å¥½ã¿ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç™ºè¦‹ãƒ»æ¶ˆè²»ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ï¼\nTwitterã®æŠ±ãˆã‚‹å•é¡Œç‚¹ã¯ã€ŒTwitterã¨ã„ã†ã‚µãƒ¼ãƒ“ã‚¹ãŒä¸­å¤®é›†æ¨©çš„ã§ã‚ã‚‹ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ï¼ã€ŒTwitterã¨ã„ã†ã‚µãƒ¼ãƒ“ã‚¹ãŒä¸­å¤®é›†æ¨©çš„ã§ã‚ã‚‹ã€ã¨ã¯\n ã€ŒTwitterã¨ã„ã†ã‚·ã‚¹ãƒ†ãƒ ã¯Twitterç¤¾ã®ç®¡ç†ã™ã‚‹ãƒã‚·ãƒ³ä¸Šã§ã®ã¿å±•é–‹ã•ã‚Œã¦ã„ã‚‹ãŸã‚ï¼Œãã®ãƒã‚·ãƒ³ãŒè½ã¡ã‚‹ã¨Twitterã¨ã„ã†ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ãŒè½ã¡ã¦ã—ã¾ã†ï¼ˆå˜ä¸€éšœå®³ç‚¹ï¼‰ã€ ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒTwitterã«æŠ•ç¨¿ã—ãŸä»»æ„ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚„ãƒ‡ãƒ¼ã‚¿ã¯åŸºæœ¬çš„ã«Twitterç¤¾ã®ç®¡ç†ã™ã‚‹ãƒã‚·ãƒ³ã«ã—ã‹æ®‹ã‚‰ãªã„ã€ ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æŠ•ç¨¿å†…å®¹ã«ã¤ã„ã¦Twitterç¤¾ã®æ±ºã‚ã‚‹ãƒ«ãƒ¼ãƒ«ã«å¾“ã‚ãªã‘ã‚Œã°ãªã‚‰ãªã„ï¼ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ä¾¡å€¤åˆ¤æ–­ã«ã¤ã„ã¦ã®è‡ªç”±ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰å‰¥å¥ªã•ã‚Œã‚‹ï¼å°‘ãªãã¨ã‚‚Twitterç¤¾ãŒã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«å¯¾ã—ã¦æ¤œé–²ã‚’è¡Œãˆã°ãã‚Œã‚’å›é¿ã™ã‚‹æ‰‹æ®µã¯å­˜åœ¨ã—ãªã„ï¼‰ã€ ã€ŒTwitterã¨ã„ã†ã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›ã™ã‚‹Twitterç¤¾ã®æ±ºã‚ã‚‹ãƒ«ãƒ¼ãƒ«ã«ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¨å“¡ãŒå¾“ã‚ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€ ã€ŒTwitterã¨ã„ã†ã‚µãƒ¼ãƒ“ã‚¹ã®ã—ã‚ˆã†ãŒTwitterç¤¾ã®ä¸€å­˜ã§æ±ºã¾ã‚‹ãŸã‚ï¼ŒTwitterã¨ã„ã†ã‚·ã‚¹ãƒ†ãƒ ã«ä¹—ã£ã‹ã‚ã†ã¨ã™ã‚‹å¤–éƒ¨ã®é–‹ç™ºè€…ã¯åœ°ä½çš„ã«Twitterç¤¾ã®ä¸‹ã«ã¤ãã“ã¨ã«ãªã‚‹ã€ ã€ŒTwitterã®å®Ÿè£…ã¯å…¬é–‹ã•ã‚Œãªã„ï¼ˆã®ã§ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãªã‚“ã‚‰ã‹ã®ä¸å…·åˆã«ç›´é¢ã—ã¦ã‚‚ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼è‡ªèº«ã§ä¿®æ­£ã™ã‚‹ã“ã¨ãŒæ ¹æœ¬çš„ã«ä¸å¯èƒ½ï¼‰ã€  ã¨ã„ã†ã“ã¨ï¼\nã€ŒTwitterã¨ã„ã†ã‚·ã‚¹ãƒ†ãƒ ã®ç®¡ç†è€…ãŒTwitterç¤¾ã—ã‹ã„ãªã„ã€ã¨ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯Twitterç¤¾ã®æ±ºã‚ãŸãƒ«ãƒ¼ãƒ«ã®ä¸­ã§ã—ãŸæ´»å‹•ã§ããªã„ã€ã¨ã„ã†ã“ã¨ã«ãªã‚‹ï¼ã“ã‚Œã¯æ®Šã€Œã‚³ãƒ³ãƒ†ãƒ³ãƒ„å…±æœ‰ã€ã¨ã„ã†æ–‡è„ˆã«ãŠã„ã¦å¤§ããªå•é¡Œã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ï¼ã¨ã„ã†ã®ã‚‚ï¼Œã€Œã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«å¯¾ã™ã‚‹ä¾¡å€¤åˆ¤æ–­ã‚„ãã‚Œã‚’ç™ºè¡¨ã™ã‚‹ã“ã¨ã¯ï¼ŒåŸºæœ¬çš„ã«äººé–“ã«ä¸ãˆã‚‰ã‚ŒãŸè‡ªç”±ã§ã‚ã‚‹ã€ã‹ã‚‰ã ï¼ã„ã‚ã‚†ã‚‹ã€Œè¡¨ç¾ã®è‡ªç”±ã€ã£ã¦ã‚„ã¤ã ï¼ç´°ã‹ãªã“ã¨ã‚’è¨€ãˆã°ï¼Œæ³•å¾‹ãŒä¿è¨¼ã™ã‚‹ã€Œè¡¨ç¾ã®è‡ªç”±ã€ã®ç¯„å›²ã¯ã€Œå…¬å…±ã®ç¦ç¥‰ã‚’ä¾µå®³ã—ãŸã‚Šä»–è€…ã®è‡ªç”±ã‚’ä¾µå®³ã—ãªã„ã€ã‚ˆã†ãªè¡¨ç¾ã®è‡ªç”±ã§ã‚ã‚‹ã‚ˆã†ã ãŒï¼ã“ã“ã§å¤§äº‹ãªã®ã¯ï¼Œè¡¨ç¾ã®è‡ªç”±ã‚’åˆ¶ç´„ã™ã‚‹ã®ã¯ã€Œå…¬å…±ã®ç¦ç¥‰ã‚„ä»–ç¤¾ã®è‡ªç”±ã‚’ä¾µå®³ã™ã‚‹ã‹ã—ãªã„ã‹ã€ã¨ã„ã†ç¤¾ä¼šçš„ãªåˆæ„ã§ã‚ã£ã¦ï¼ŒTwitterã¨ã„ã£ãŸä¸€ç§ä¼æ¥­ã®æ±ºã‚ãŸãƒ«ãƒ¼ãƒ«ã§ã¯ãªã„ã¨ã„ã†ã“ã¨ã ï¼ç¾çŠ¶ã®SNSã¯ãã®ç‚¹ã§å•é¡Œã‚’æŠ±ãˆã¦ã„ã‚‹ï¼ˆã¨è‡ªç”±ã‚’æ±‚ã‚ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ä¸»å¼µã—ã¦ã„ã‚‹ï¼‰ï¼ç„¡è«–ï¼ŒTwitterç¤¾ã®æ±ºã‚ãŸãƒ«ãƒ¼ãƒ«ã®ç¯„å›²å†…ã§æ¥½ã—ã‚€ã®ã§ååˆ†ã¨ã„ã†ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚‚ã„ã‚‹ã ã‚ã†ã—ï¼Œãªã‚“ãªã‚‰ãã£ã¡ã®æ–¹ãŒå¤šæ•°æ´¾ãªæ°—ã‚‚ã™ã‚‹ãŒï¼\nãã‚“ãªå•é¡Œæ„è­˜ã‹ã‚‰Federated Social Webã¨ã„ã†æ¦‚å¿µãŒç™»å ´ã—ã¦ã„ã‚‹ï¼Federated Social WebãŒå®Ÿç¾ã—ãŸã„ã®ã¯ã€Œä¸­å¤®é›†æ¨©ã§ã¯ãªã„å½¢ã§ç¤¾ä¼šçš„ãªäººé–“ã®åœ¨ã‚Šã‚ˆã†ã‚’ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã®ä¸–ç•Œã«å®Ÿè£…ã™ã‚‹ã“ã¨ã€ã§ã‚ã‚‹ï¼Federated Social Webã§ã¯ï¼Œå…ˆã«æŒ™ã’ãŸç›®çš„ã‚’ã€ŒCleint-Serverãƒ¢ãƒ‡ãƒ«ã¨Server-Serverãƒ¢ãƒ‡ãƒ«ã®çµ„ã¿åˆã‚ã›ã€ã§å®Ÿç¾ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ï¼\n   Fededated Social Web   Federated Social Webã§ã¯ã€Œæ—¢å­˜ã®Twitterã®ã‚ˆã†ãªä»•çµ„ã¿ã‚’æä¾›ã™ã‚‹serverãŒä¸ç‰¹å®šå¤šæ•°ã®ç®¡ç†è€…ï¼ˆã“ã‚Œã¯çµ„ç¹”ã§ã‚‚å€‹äººã§ã‚‚ã„ã„ï¼‰ã«ã‚ˆã£ã¦æä¾›ã•ã‚Œï¼Œå½¼ã‚‰ãŒæä¾›ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä¹—ã£ã‹ã‚‹ã€ã¨ã„ã†ãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ï¼\nã€ŒFederatedã€ã‚’è‹±è‹±è¾å…¸ã§å¼•ãã¨\n (of a country or organization) set up as a single centralized unit within which each state or division keeps some internal autonomy.\n ã¨ã‚ã‚‹ï¼ã¤ã¾ã‚Šï¼ŒSocial Networkingã«å¿…è¦ãªæ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹serverãŒï¼Œï¼ˆå˜ä¸€ã®ç®¡ç†è€…ã«ã‚ˆã£ã¦å®šã‚ã‚‰ã‚ŒãŸãƒ«ãƒ¼ãƒ«ã«ã‚ˆã£ã¦å‹•ãã®ã§ã¯ãªãã¦ï¼‰è¤‡æ•°ã®ç®¡ç†è€…ãŒè‡ªç”±ã«å®šã‚ãŸãƒ«ãƒ¼ãƒ«ã«åŸºã¥ã„ã¦çµ±æ²»ãƒ»ç®¡ç†ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã ï¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®ç´å¾—ã™ã‚‹ãƒ«ãƒ¼ãƒ«ã§é‹ç”¨ã•ã‚Œã¦ã„ã‚‹serverã«ã¶ã‚‰ä¸‹ãŒã‚Œã°ï¼Œãã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¨ã£ã¦ååˆ†ãªè‡ªç”±ã‚’äº«å—ã§ãã‚‹ã—ï¼Œã„ã‚„ã«ãªã‚Œã°ç•°ãªã‚‹ãƒ«ãƒ¼ãƒ«ã§å‹•ã„ã¦ã„ã‚‹ä»–ã®serverã«ç§»ã‚‹ã“ã¨ã ã£ã¦å¯èƒ½ã ï¼ã•ã‚‰ã«è¨€ãˆã°ã€Œã‚ªãƒ¬ã‚ªãƒ¬ãƒ«ãƒ¼ãƒ«ã€ã§é‹ç”¨ã•ã‚Œã‚‹ã‚ªãƒ¬ã‚ªãƒ¬SNSã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã ã£ã¦è¨±ã•ã‚Œã¦ã„ã‚‹ï¼\nActivityPubã¨ã¯ ActivityPubã¯Federated Social Webã‚’å®Ÿç¾ã™ã‚‹éš›ã®é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã ï¼ActivityPubã¯ã€Œã‚ã‚‹serverã¨ãã‚Œã«ã¶ã‚‰ä¸‹ãŒã£ã¦ã„ã‚‹clienté–“ã®é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€ã¨ã€Œé€£åˆã‚’çµ„ã‚€serveré–“ã®é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€ã®2ã¤ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’å†…åŒ…ã—ã¦ã„ã‚‹ï¼\nã€Œã‚ã‚‹serverã¨ãã‚Œã«ã¶ã‚‰ä¸‹ãŒã£ã¦ã„ã‚‹clienté–“ã®é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€ã¯ï¼Œé€šå¸¸ã®SNSã«ãŠã„ã¦å¿…è¦ãªæŠ•ç¨¿ã ã¨ã‹ä»–ã®äººã®è¡Œå‹•ã®ãŠçŸ¥ã‚‰ã›ã¨ã‹ã‚’å—ã‘å–ã‚‹ãŸã‚ã«å¿…è¦ãªé€šä¿¡ã‚’è¦å®šã—ã¦ã„ã‚‹ã‚‚ã®ï¼\nã€Œé€£åˆã‚’çµ„ã‚€serveré–“ã®é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€ã¯ï¼Œä¸ç‰¹å®šå¤šæ•°ã®ç®¡ç†è€…ãŒé‹å–¶ã™ã‚‹serveré–“ã§æƒ…å ±ã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã®é€šä¿¡ã‚’è¦å®šã™ã‚‹ã‚‚ã®ï¼ã“ã‚ŒãŒã‚ã‚‹ã“ã¨ã§ï¼Œã€ŒFederatedã€ãªSocial WebãŒåˆã‚ã¦å®Ÿç¾ã§ãã‚‹ï¼\nActivityPubã§ã¯ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã€Œä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®ãŠçŸ¥ã‚‰ã›ã‚’å—ã‘å–ã‚‹inboxã¨è‡ªåˆ†ã®ã‚·ã‚¹ãƒ†ãƒ ä¸Šã§ã®è¡Œå‹•ã‚’ä»–ã®äººã«é€šçŸ¥ã™ã‚‹outboxã‚’æŒã¤Actorã€ã¨ã—ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã‚‹ï¼inbox/outboxã®å®Ÿä½“ã¯webã®ä¸–ç•Œã§è¨€ã†ã¨ã“ã‚ã®URLã«éããšï¼Œã•ã‚‰ã«è¨€ãˆã°clientãŒserverã«GET/POSTã™ã‚‹éš›ã®api endpointã§ã—ã‹ãªã„ï¼ã‚ctivityPubã§ã¯ã©ã‚“ãªå½¢å¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚„ã‚Šã¨ã‚Šã™ã‚‹ã‹ã‚‚è¦å®šã—ã¦ã„ã‚‹ï¼ã‚ˆã‚Šå…·ä½“çš„ã«è¨€ãˆã°ã€ŒSNSã‚’Webä¸Šã§å®Ÿç¾ã™ã‚‹éš›ã®JSONãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€ã‚’è¦å®šã™ã‚‹ActivityStreamsã®ä¸Šã«ActivityPubã¯è¦å®šã•ã‚Œã¦ã„ã‚‹ï¼\nè¦ã™ã‚‹ã«ï¼Œclient-serveré–“ã®é€šä¿¡ã¨client-clienté–“ã®é€šä¿¡ã®ãã‚Œãã‚Œã«ã¤ã„ã¦ï¼ŒActivityStreamsãŒå®šç¾©ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’ç”¨ã„ãŸSNSä¸Šã«ãŠã‘ã‚‹Actorã®è¡Œå‹•ã«å¯¾ã™ã‚‹CRUDã‚’å®šç¾©ã—ã¦ã„ã‚‹ã®ãŒActivityPubã§ã‚ã‚‹ï¼\nç–‘å• ä¸ç‰¹å®šå¤šæ•°ã®ç®¡ç†è€…ãŒãã‚Œãã‚Œã®ãƒ«ãƒ¼ãƒ«ã§SNSã‚’æä¾›ã™ã‚‹ã¨ãã«ï¼Œãã‚Œã‚‰SNSåŒå£«ãŒã‚„ã‚Šå–ã‚Šã‚’ã™ã‚‹ãŸã‚ã®çµ±ä¸€çš„ãªãƒ‡ãƒ¼ã‚¿å½¢å¼ãƒ»APIã‚’è¦å®šã—ã¦ã„ã‚‹ã®ãŒActivityPubã¨ã„ã†ã“ã¨ã«ãªã‚‹ãŒï¼Œå„SNSãŒç‹¬è‡ªæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¦ç‹¬è‡ªãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’è¿½åŠ ã—ãŸã¨ãã¯ã©ã®ã‚ˆã†ã«å¯¾å¿œã™ã‚‹ã®ã ã‚ã†ï¼\nActivityPubã¯æœ€ä½é™å®Ÿè£…ã•ã‚Œã‚‹ã¹ãAPIã¨ã—ã¦æ•´å‚™ã•ã‚Œã‚‹ã«ã—ã¦ã‚‚ï¼Œç‹¬è‡ªãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã¤ã„ã¦ã¯å…±æœ‰ã™ã‚‹æ–¹æ³•ã¨ã‹ã¯è¦å®šã—ã¦ã„ãªã„ï¼ActivityPubã«ã¯ã€ŒJSON-LDã‚’ç”¨ã„ã¦ActivityStreamsã¯æ‹¡å¼µå¯èƒ½ã§ã‚ã‚‹ã€ã¨ã—ã¦ã„ã‚‹ï¼ã‚„ã‚Šå–ã‚Šã•ã‚Œã‚‹JSONãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«æœªçŸ¥ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå­˜åœ¨ã—ã¦ã„ãŸã‚‰ï¼Œç„¡è¦–ã™ã‚‹ã‹é©å½“ã«è§£é‡ˆã™ã‚‹ã‹ã—ã‹ãªã„ã®ã§ï¼Œã©ã†ã™ã‚‹ã®ã ã‚ã†ï¼ãŸã ï¼ŒSNSã¨ã„ã†ã‚ã‚‹ç¨‹åº¦è¦æ±‚ã•ã‚Œã‚‹APIãŒã‚µãƒ¼ãƒ“ã‚¹ã‹ã‚‰äºˆæ¸¬ãŒã¤ãã—ãã‚Œä»¥ä¸Šã®ç‹¬è‡ªæ€§ãŒãªã•ãã†ã¨ã„ã†æ„Ÿè¦šã‹ã‚‰ã™ã‚Œã°ActivityStreamsã§ååˆ†ãªã®ã‹ã‚‚ã—ã‚Œãªã„ï¼ã“ã®ç‚¹ã¯ActivityStreamsã‚’èª­ã‚“ã§ã¿ãªã„ã¨ã‚ã‹ã‚‰ãªã„ã¨æ€ã†ã®ã§æ°—ãŒå‘ã„ãŸã‚‰ã‚„ã‚ã†ã‹ãªï¼\nMastodon Mastodonã¯ActivityPubã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‚¦ã‚§ãƒ–ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®1ã¤ï¼ã¡ã‚‡ã£ã¨å‰ã«ã¡ã‚‡ã£ã¨æµè¡Œã£ãŸï¼Mastodonã®é¢ç™½ã„ã¨ã“ã‚ã¯ï¼ŒSocial Webã«ãŠã‘ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªuser identityã‚’ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¿ãŸã„ãªå½¢å¼ã§è¡¨ç¾ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã“ã¨ï¼Webä¸Šã§ã®Identityã¯ã‚µãƒ¼ãƒ“ã‚¹ã¨å¼·å›ºã«çµã³ã¤ã„ã¦ã„ã¦ï¼Œç¾åœ¨ã§ã‚‚Googleï¼ŒFacebookï¼ŒGitHubèªè¨¼ã®ã‚µãƒ¼ãƒ“ã‚¹ãŒãŸãã•ã‚“ã‚ã‚‹ï¼ã€Œç§ã¯Aliceã§ã™ã€ã¨ï¼ŒãŸã ãã‚Œã ã‘ã§ä¸»å¼µã™ã‚‹ã“ã¨ãŒã§ãã‚‹URLãŒWebä¸Šã«ã¯å­˜åœ¨ã—ã¦ã„ãªãã¦ï¼Œã€ŒFacebookã®Aliceã•ã‚“ã€ã¨ã‹ã€ŒGoogleã®Aliceã•ã‚“ã€ã¨ã„ã†é¢¨ã«ã—ã‹è‡ªåˆ†ã®ã“ã¨ã‚’è¡¨ç¾ã§ãã¦ã„ãªã„çŠ¶æ…‹ã«ã‚ã‚‹ï¼Federated Social Webã®å®Ÿè£…ä¾‹ã§ã‚ã‚‹Mastodonã§ã¯ï¼Œ\u0026lt;user_id\u0026gt;@\u0026lt;federation_id\u0026gt;ã¿ãŸã„ãªå½¢ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªIdentityã‚’ä¸ãˆã‚‹ã“ã¨ã«ã—ã¦ã„ã¦ï¼Œã“ã‚Œã¯è³¢ã„ãªã¨æ€ã†ï¼\n","date":1572252565,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572252565,"objectID":"483ffe32be9d68876584fd344ad24aaa","permalink":"/ja/post/what-is-activitypub/","publishdate":"2019-10-28T17:49:25+09:00","relpermalink":"/ja/post/what-is-activitypub/","section":"post","summary":"ActivityPubãŒç›®æŒ‡ã™Federated Social Webã«ã¤ã„ã¦è€ƒãˆã¦ã¿ã¾ã—ãŸ","tags":["ActivityPub","Federated Social Web","Distributed Social Network","Mastodon","Decentralization"],"title":"Federated Social Webã¨ActivityPub","type":"post"},{"authors":[],"categories":[],"content":"å…±é€šéµæš—å· æš—å·åŒ–ãƒ»å¾©å·ã§åŒä¸€ã®éµã‚’ç”¨ã„ã‚‹æš—å·åŒ–æ–¹å¼\nã‚·ãƒŠãƒªã‚ª  AliceãŒç§˜å¯†éµ$key$ã‚’ä½œæˆã—ï¼ŒBobã«å®‰å…¨ã«å…±æœ‰ AliceãŒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸$m$ã‚’$key$ã§æš—å·åŒ–$c = Enc(m, key)$ã—ï¼ŒBobã«é€ä¿¡ BobãŒå—ã‘å–ã£ãŸæš—å·æ–‡$c$ã‚’$key$ã§å¾©å·$m = Dec(c, key)$ã—ã¦å¹³æ–‡$m$ã‚’å¾—ã‚‹  å…±é€šéµæš—å·ã®æº€ãŸã™ã¹ãæ€§è³ª  æ­£å½“æ€§  $m = Dec(Enc(m, key), key)$ãŒæˆç«‹ã™ã‚‹ã“ã¨   ç§˜åŒ¿æ€§  æš—å·æ–‡$c$ã‹ã‚‰å¹³æ–‡$m$ã«é–¢é€£ã™ã‚‹æƒ…å ±ãŒå¾—ã‚‰ã‚Œãªã„ã“ã¨    å…±é€šéµæš—å·ã«å¯¾ã™ã‚‹æ”»æ’ƒãƒ¢ãƒ‡ãƒ« æš—å·æ–‡å˜ç‹¬æ”»æ’ƒï¼šCiphertext Only Attack æ”»æ’ƒè€…ãŒã€Œè§£èª­å¯¾è±¡ã®æš—å·æ–‡$c^*$ã€ã¨ã€Œç›—è´ã—ãŸæš—å·æ–‡$c_1$ï¼Œ$c_2$ï¼Œ$c_3$\u0026hellip;$c_k$ã€ã‚’æ‰‹å…ƒã«æŒã£ã¦ã„ã‚‹çŠ¶æ³ã§ã®æ”»æ’ƒï¼é€šä¿¡è·¯ã®ç›—è´ã¨ã„ã†æ”»æ’ƒã«ç›¸å½“ï¼\næ—¢çŸ¥å¹³æ–‡æ”»æ’ƒï¼šKnown Plaintext Attack æ”»æ’ƒè€…ãŒã€Œè§£èª­å¯¾è±¡ã®æš—å·æ–‡$c^*$ã€ã¨ã€Œï¼ˆåŒä¸€ã®éµã§æš—å·åŒ–ã•ã‚ŒãŸï¼‰ãƒ©ãƒ³ãƒ€ãƒ ãªå¹³æ–‡ã¨æš—å·æ–‡ã®å¯¾$(m_1, c_1)$ï¼Œ$(m_2, c_2)$ï¼Œ$(m_3, c_3)$\u0026hellip;$(m_k, c_k)$ã€ã‚’æ‰‹å…ƒã«æŒã£ã¦ã„ã‚‹çŠ¶æ³ã§ã®æ”»æ’ƒï¼éå»ã®å¹³æ–‡ãŒç‰¹å®šæ¸ˆã¿ã§ã‚ã‚‹ã‚ˆã†ãªçŠ¶æ³ã§ã®æ”»æ’ƒã«ç›¸å½“ï¼\né¸æŠå¹³æ–‡æ”»æ’ƒï¼šChosen Plaintext Attack æ”»æ’ƒè€…ãŒã€Œè§£èª­å¯¾è±¡ã®æš—å·æ–‡$c^*$ã€ã‚’æŒã¡ï¼Œã€Œæ”»æ’ƒè€…ãŒé¸ã‚“ã ä»»æ„ã®å¹³æ–‡ã«å¯¾å¿œã™ã‚‹æš—å·æ–‡ã‚’è‡ªç”±ã«å…¥æ‰‹ã§ãã‚‹ã€ã‚ˆã†ãªçŠ¶æ³ã§ã®æ”»æ’ƒï¼\né¸æŠæš—å·æ–‡æ”»æ’ƒï¼šChosen Ciphertext Attack æ”»æ’ƒè€…ãŒã€Œè§£èª­å¯¾è±¡ã®æš—å·æ–‡$c^$ã€ã‚’æŒã¡ï¼Œã€Œæ”»æ’ƒå¯¾è±¡ã®æš—å·æ–‡$c^$ã‚’å…¥æ‰‹ã™ã‚‹å‰ã®æ™‚ç‚¹ã§ï¼Œæ”»æ’ƒè€…ãŒè‡ªåˆ†ã®é¸ã‚“ã æš—å·æ–‡ã«å¯¾å¿œã™ã‚‹å¹³æ–‡ã‚’å…¥æ‰‹ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€ã‚ˆã†ãªçŠ¶æ³ã§ã®æ”»æ’ƒï¼\né©å¿œçš„é¸æŠæš—å·æ–‡æ”»æ’ƒï¼šAdaptive Chosen Ciphertext Attack æ”»æ’ƒè€…ãŒã€Œè§£èª­å¯¾è±¡ã®æš—å·æ–‡$c^*$ã€ã‚’æŒã¡ï¼Œã€Œæ”»æ’ƒè€…ãŒé¸ã‚“ã ä»»æ„ã®æš—å·æ–‡ã«å¯¾å¿œã™ã‚‹å¹³æ–‡ã‚’è‡ªç”±ã«å…¥æ‰‹ã§ãã‚‹ã€ã‚ˆã†ãªçŠ¶æ³ã§ã®æ”»æ’ƒï¼\néµå…¨æ•°æ¢ç´¢æ”»æ’ƒã«å¯¾ã™ã‚‹å…±é€šéµæš—å·ã®å®‰å…¨æ€§ ç§˜å¯†éµãŒ$k$bitã§ã‚ã‚‹ã‚ˆã†ãªå…±é€šéµæš—å·ã§ã¯ï¼Œ$2^k$å€‹ã®éµã‚’å…¨éƒ¨è©¦ã›ã°å¿…ãšç§˜å¯†éµã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼å…±é€šéµæš—å·ã§ã¯ã€Œéµå…¨æ•°æ¢ç´¢æ”»æ’ƒã‚ˆã‚Šã‚‚åŠ¹ç‡çš„ã«ç§˜å¯†éµã‚’æ±‚ã‚ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒå­˜åœ¨ã—ãªã„ã“ã¨ã€ãŒå®‰å…¨æ€§ã«å¯¾ã™ã‚‹æ¡ä»¶ã§ã‚ã‚‹ï¼\nã•ã¾ã–ã¾ãªå…±é€šéµæš—å·  ã‚¹ãƒˆãƒªãƒ¼ãƒ æš—å·  å¹³æ–‡ã‚’å°ã•ã„å˜ä½ã§é †æ¬¡å‡¦ç†ã—ã¦ã„ãæ–¹å¼ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè¡Œã™ã‚‹å›æ•°ãŒ1å›   ãƒ–ãƒ­ãƒƒã‚¯æš—å·  å¹³æ–‡ã‚’ä¸€å®šã®å¤§ãã•ã®å˜ä½ã§å‡¦ç†ã—ã¦ã„ãæ–¹å¼ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè¡Œã™ã‚‹å›æ•°ãŒãƒ–ãƒ­ãƒƒã‚¯ã®å€‹æ•°åˆ†    ãƒãƒ¼ãƒŠãƒ æš—å·  ğŸ‘  æƒ…å ±ç†è«–çš„å®‰å…¨æ€§ã‚’æŒã¤  ãŸã¨ãˆï¼Œéµå…¨æ•°æ¢ç´¢ã‚’å®Ÿè¡Œã§ãã‚‹ç„¡é™ã®è¨ˆç®—èƒ½åŠ›ã‚’æŒã£ã¦ã„ã‚‹æ”»æ’ƒè€…ã§ã‚ã£ã¦ã‚‚è§£èª­ã§ããªã„ï¼ˆã©ã‚ŒãŒæœ¬å½“ã®å¹³æ–‡ãªã®ã‹ãŒã‚ã‹ã‚‰ãªã„ï¼‰   å‡¦ç†ãŒã€Œå¹³æ–‡ã¨éµã§xorã€ã¨å˜ç´”ãªã®ã§éå¸¸ã«é«˜é€Ÿ   ğŸ‘  å°‘ãªãã¨ã‚‚å¹³æ–‡ã¨åŒã˜é•·ã•ã®ç§˜å¯†éµãŒå¿…è¦ã«ãªã‚‹ã—ï¼ŒåŸºæœ¬çš„ã«éµã¯ä½¿ã„æ¨ã¦ãªã®ã§ã„ãã‚‰éµã‚’ç”¨æ„ã—ã¦ã‚‚è¶³ã‚Šãªã„ã—ï¼Œãã‚‚ãã‚‚ã“ã®ç§˜å¯†éµã‚’å®‰å…¨ã«å…±æœ‰ã§ãã‚‹ãªã‚‰æš—å·åŒ–ã™ã‚‹å¿…è¦ãŒãªã„ éµã®ç”Ÿæˆã«ã€ŒçœŸæ€§ä¹±æ•°ã€ã‚’ç”¨æ„ã—ãªã‘ã‚Œã°ãªã‚‰ãšï¼Œé•·ã„éµã‚’ä½œã‚‹ã«ã¯æ‰‹é–“ãŒã‹ã‹ã‚‹    ã‚¹ãƒˆãƒªãƒ¼ãƒ æš—å·  ğŸ‘  ãƒãƒ¼ãƒŠãƒ æš—å·ã¨æ¯”ã¹ã¦ï¼ˆå®‰å…¨æ€§ã‚’ã‚„ã‚„çŠ ç‰²ã«ã—ãªãŒã‚‰ã‚‚ï¼‰åŠ¹ç‡æ€§ã‚’å‘ä¸Š   ğŸ‘  æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã®å®‰å…¨æ€§ãŒã‚¹ãƒˆãƒªãƒ¼ãƒ æš—å·ã®å®‰å…¨æ€§ã«ç›´çµã™ã‚‹  éå»ã®ç³»åˆ—ã‚’è¦‹ã¦æœªæ¥ã®ç³»åˆ—ãŒäºˆæ¸¬ã§ãã¦ã—ã¾ãˆã°è§£èª­ã•ã‚Œã¦ã—ã¾ã† æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ã®åˆæœŸåŒ–ã«ç”¨ã„ã‚‹ç§˜å¯†éµã‚’ç‰¹å®šã•ã‚Œã¦ã—ã¾ã†ã¨è§£èª­ã•ã‚Œã¦ã—ã¾ã†      ","date":1572250776,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572250776,"objectID":"933f01d72df16835e756a93a571c6943","permalink":"/ja/post/symmetric-key-encription-scheme/","publishdate":"2019-10-28T17:19:36+09:00","relpermalink":"/ja/post/symmetric-key-encription-scheme/","section":"post","summary":"æš—å·æŠ€è¡“å­¦ç¿’ãƒ¡ãƒ¢ #2","tags":["Cryptography","Memo","Symmetric Key Encryption"],"title":"å…±é€šéµæš—å·","type":"post"},{"authors":[],"categories":[],"content":"æš—å·ã®åŸºç¤æŠ€è¡“ æš—å·æŠ€è¡“ã®ä¸­ã§ã‚‚åŸºç¤ã¨ãªã‚‹ã‚‚ã®ï¼\n æš—å· éµé…é€ ãƒãƒƒã‚·ãƒ¥é–¢æ•° ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸èªè¨¼ã‚³ãƒ¼ãƒ‰ ãƒ‡ã‚¸ã‚¿ãƒ«ç½²å æ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨  æš—å· æš—å·ã¨ã¯ï¼Œã€Œæ­£å½“ãªé€ä¿¡è€…ã¨å—ä¿¡è€…ä»¥å¤–ã«å†…å®¹ã‚’ç§˜åŒ¿ã™ã‚‹æŠ€è¡“ã€ã®ã“ã¨ï¼é€ä¿¡è€…ã¯å¹³æ–‡ã«å¯¾ã—ã¦ï¼Œãªã‚“ã‚‰ã‹ã®æ“ä½œã‚’æ–½ã™ã“ã¨ã§ï¼Œæš—å·æ–‡ã‚’ç”Ÿæˆã™ã‚‹ï¼ã“ã®éç¨‹ã‚’æš—å·åŒ–ã¨ã„ã†ï¼ä¸€æ–¹ã§ï¼Œå—ä¿¡è€…ã¯æš—å·æ–‡ã«å¯¾ã—ã¦ãªã‚“ã‚‰ã‹ã®æ“ä½œã‚’æ–½ã™ã“ã¨ã§å¹³æ–‡ã‚’å¾—ã‚‹ï¼ã“ã®éç¨‹ã‚’å¾©å·ã¨ã„ã†ï¼\néµé…é€ éµé…é€ã¨ã¯ï¼Œæš—å·åŒ–ã‚„å¾©å·ã«ç”¨ã„ã‚‹éµã‚’å®‰å…¨ã«é…é€ãƒ»å…±æœ‰ã™ã‚‹ãŸã‚ã®æŠ€è¡“ã‚„æ–¹å¼ã®ã“ã¨ï¼éµã¯ã€Œç¬¬ä¸‰è€…ã«çŸ¥ã‚‰ã‚Œãªã„ã‚ˆã†ã«ã€é…é€ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼\nãƒãƒƒã‚·ãƒ¥é–¢æ•° ãƒãƒƒã‚·ãƒ¥é–¢æ•°ã¨ã¯ï¼Œä»»æ„é•·ã®ãƒ“ãƒƒãƒˆåˆ—ã‚’å…¥åŠ›ã¨ã—ã¦å›ºå®šé•·ã®ãƒ“ãƒƒãƒˆåˆ—ã‚’å‡ºåŠ›ã™ã‚‹é–¢æ•°ã®ã“ã¨ï¼åŒä¸€ã®å…¥åŠ›ã«å¯¾ã—ã¦åŒä¸€ã®å‡ºåŠ›ã‚’ã™ã‚‹ä¸€æ–¹ã§ï¼Œç•°ãªã‚‹å…¥åŠ›ã«å¯¾ã—ã¦ç•°ãªã‚‹å‡ºåŠ›ã¨ãªã‚Šï¼Œç•°ãªã‚‹å…¥åŠ›ã«å¯¾ã—ã¦åŒä¸€ã®å‡ºåŠ›ã«ãªã‚‰ãªã„ã¨ã„ã†æ€§è³ªãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ï¼\nãƒ¡ãƒƒã‚»ãƒ¼ã‚¸èªè¨¼ã‚³ãƒ¼ãƒ‰ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸èªè¨¼ã‚³ãƒ¼ãƒ‰ã¨ã¯ï¼Œã€Œä¼é€è·¯ä¸Šã‚’é€šã£ã¦ããŸãƒ‡ãƒ¼ã‚¿ãŒæ”¹ã–ã‚“ã•ã‚Œã¦ã„ãªã„ã“ã¨ã€ã€Œãƒ‡ãƒ¼ã‚¿ãŒæœŸå¾…ã—ãŸé€šä¿¡ç›¸æ‰‹ã‹ã‚‰é€ä¿¡ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã€ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã®æŠ€è¡“ã®ã“ã¨ï¼\nãƒ‡ã‚¸ã‚¿ãƒ«ç½²å ãƒ‡ã‚¸ã‚¿ãƒ«ç½²åã¨ã¯ï¼Œå¥‘ç´„æ›¸ã«ãŠã‘ã‚‹ç‰©ç†çš„ãªã‚µã‚¤ãƒ³ã®ãƒ‡ã‚¸ã‚¿ãƒ«ç‰ˆã§ï¼Œãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã¨ãƒ‡ãƒ¼ã‚¿èªè¨¼ã‚’åŒæ™‚ã«å®Ÿç¾ã™ã‚‹æŠ€è¡“ã®ã“ã¨ï¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ”¹ã–ã‚“ã‚’é˜²ãï¼Œãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å¯¾ã™ã‚‹ç½²åã¯ç½²åã—ãŸæœ¬äººã§ã—ã‹ç”Ÿæˆã§ããªã„ã“ã¨ã‹ã‚‰ï¼Œå¾Œã‹ã‚‰ç½²åè€…ãŒç½²åã—ãŸå¥‘ç´„ã«ã¤ã„ã¦å¦èªã™ã‚‹ã“ã¨ã‚’é˜²æ­¢ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ï¼\næ“¬ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ çœŸã®ä¹±æ•°ã§ã¯ãªã„ã«ã—ã¦ã‚‚ï¼Œæš—å·è«–çš„ã«å®‰å…¨ã¨ã¿ãªã›ã‚‹ä¹±æ•°åˆ—ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®æŠ€è¡“ã®ã“ã¨ï¼\n","date":1572234048,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572234048,"objectID":"171b152bec97767e38aadfdd4c806b24","permalink":"/ja/post/basic-cryptographic-technologies/","publishdate":"2019-10-28T12:40:48+09:00","relpermalink":"/ja/post/basic-cryptographic-technologies/","section":"post","summary":"æš—å·æŠ€è¡“å­¦ç¿’ãƒ¡ãƒ¢ #1","tags":["Cryptography","Memo"],"title":"æš—å·ã®åŸºç¤æŠ€è¡“","type":"post"},{"authors":[],"categories":[],"content":"æƒ…å ±ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®æ§‹æˆè¦ç´  ã€Œæƒ…å ±ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã€ã®è¨€è‘‰ã®æŒ‡ã—ç¤ºã™æ„å‘³ç¯„å›²ã¯OECDã®æƒ…å ±ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚„ISO/IEC TR133351ã¨ã—ã¦å›½éš›çš„ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ï¼\nISO/IEC TR13335ã«ã¦æƒ…å ±ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ã¯ä¸‹è¨˜6è¦ç´ ã®ã“ã¨ã‚’æŒ‡ã™ã¨ã•ã‚Œã¦ã„ã‚‹ï¼\n æ©Ÿå¯†æ€§ Confidentiality å®Œå…¨æ€§ Integrity å¯ç”¨æ€§ Availability è²¬ä»»è¿½è·¡æ€§ Accountability çœŸæ­£æ€§ Authenticity ä¿¡é ¼æ€§ Reliability  æ©Ÿå¯†æ€§ Confidentiality  æ„å‘³  æ„å›³ã—ãŸç›¸æ‰‹ä»¥å¤–ã«æƒ…å ±ãŒæ¼ã‚Œãªã„ã“ã¨   ãƒªã‚¹ã‚¯  ç›—è´ã‚„å†…éƒ¨ã‹ã‚‰ã®æƒ…å ±æ¼æ´©   å¯¾ç­–  æš—å·æŠ€è¡“    å®Œå…¨æ€§ Integrity  æ„å‘³  æƒ…å ±ãŒæ­£ç¢ºã§ã‚ã‚‹ã“ã¨   ãƒªã‚¹ã‚¯  æƒ…å ±ã®æ”¹ã–ã‚“ï¼Œãƒã‚¤ã‚ºã«ã‚ˆã‚‹ãƒ“ãƒƒãƒˆåè»¢ãƒ»ãƒ“ãƒƒãƒˆã®æ¬ è½   å¯¾ç­–  èª¤ã‚Šè¨‚æ­£ç¬¦å·ï¼Œãƒãƒƒã‚·ãƒ¥é–¢æ•°ï¼Œãƒ¡ãƒƒã‚»ãƒ¼ã‚¸èªè¨¼ã‚³ãƒ¼ãƒ‰ï¼Œãƒ‡ã‚¸ã‚¿ãƒ«ç½²å    å¯ç”¨æ€§ Availability  æ„å‘³  ã‚ã‚‹æƒ…å ±ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒè¨±ã•ã‚Œã¦ã„ã‚‹ä¸»ä½“ãŒï¼Œä»»æ„ã®æ™‚ç‚¹ã§æƒ…å ±ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã“ã¨   ãƒªã‚¹ã‚¯  ã‚·ã‚¹ãƒ†ãƒ ã¸ã®éè² è·ï¼Œç½å®³ï¼Œæ„å›³ã—ãªã„ãƒ­ãƒƒã‚¯   å¯¾ç­–  ã‚·ã‚¹ãƒ†ãƒ ã®å¤šé‡åŒ–ï¼Œã‚¯ãƒ©ã‚¦ãƒ‰åŒ–ï¼Œè² è·åˆ†æ•£    è²¬ä»»è¿½è·¡æ€§ Accountability  æ„å‘³  ãƒ¦ãƒ¼ã‚¶ã‚„ã‚·ã‚¹ãƒ†ãƒ ã®æŒ¯ã‚‹èˆã„ã«ã¤ã„ã¦èª¬æ˜ãŒå¯èƒ½ã§ã‚ã‚‹ã“ã¨   ãƒªã‚¹ã‚¯  ãƒ­ã‚°ã®æ”¹ã–ã‚“ï¼Œå¦èª   å¯¾ç­–  ãƒ­ã‚®ãƒ³ã‚°ï¼Œãƒ‡ã‚¸ã‚¿ãƒ«ç½²åï¼ˆå¦èªé˜²æ­¢ï¼‰    çœŸæ­£æ€§ Authenticity  æ„å‘³  è¦³æ¸¬ã•ã‚Œã‚‹ãƒ¦ãƒ¼ã‚¶ã‚„ã‚·ã‚¹ãƒ†ãƒ ã®æŒ¯ã‚‹èˆã„ãŒï¼Œãã®ä¸»ä½“ã«ã‚ˆã‚‹ã‚‚ã®ã§ã‚ã‚‹ã“ã¨ï¼ˆãªã‚Šã™ã¾ã—ã§ã¯ãªã„ï¼‰   ãƒªã‚¹ã‚¯  ãªã‚Šã™ã¾ã—   å¯¾ç­–  èªè¨¼ï¼Œãƒ‡ã‚¸ã‚¿ãƒ«ç½²åï¼ˆãªã‚Šã™ã¾ã—é˜²æ­¢ï¼‰    ä¿¡é ¼æ€§ Reliability  æ„å‘³  ã‚·ã‚¹ãƒ†ãƒ ãŒä¸€è²«ã—ã¦å‹•ä½œã™ã‚‹ã“ã¨   ãƒªã‚¹ã‚¯  ç›—è´ã‚„å†…éƒ¨ã‹ã‚‰ã®æƒ…å ±æ¼æ´©   å¯¾ç­–  ã‚·ã‚¹ãƒ†ãƒ ã®å¤šé‡åŒ–ï¼Œè² è·ã®ç›£è¦–      æ­£ç¢ºã«ã¯ä¼æ¥­ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã‚’æŸ»å®šã™ã‚‹éš›ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’å®šã‚ãŸã‚‚ã®ã«ãªã£ã¦ã„ã‚‹ï¼é€šç§°GMITSï¼ˆGuidelines for the Management for IT Securityï¼‰ \u0026#x21a9;\u0026#xfe0e;\n   ","date":1572231267,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572231267,"objectID":"856dc76386ac6865a6fbad2e2fc6b522","permalink":"/ja/post/six-elements-of-infomation-security/","publishdate":"2019-10-28T11:54:27+09:00","relpermalink":"/ja/post/six-elements-of-infomation-security/","section":"post","summary":"æš—å·æŠ€è¡“å­¦ç¿’ãƒ¡ãƒ¢ #0","tags":["Security","Memo"],"title":"æƒ…å ±ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®æ§‹æˆè¦ç´ ","type":"post"},{"authors":[],"categories":[],"content":"ã‚ã‚ŠãŒã¡ãªä¼šè©± ã€ŒWeb Application Frameworkã¨è¨€ã£ãŸã‚‰ï¼Œã‚„ã£ã±ã‚ŠRuby on Railsã ã‚ˆã­ï¼ã€\nã€ŒWebã®ãƒ•ãƒ­ãƒ³ãƒˆé–‹ç™ºã§ã¯jQueryã£ã¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ã£ã¦ã ãª\u0026hellip;ã€\nã€Œæœ€è¿‘ã ã¨ï¼ŒFacebookãŒJavascriptã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¨ã—ã¦Reactã‚’ç™ºè¡¨ã—ã¦ã‚‹ã‚ˆã­ã€\nã€ŒReactã‚ˆã‚ŠAngular JSã®æ–¹ãŒã„ã„ã‚ˆã€\nWebç³»ã®æŠ€è¡“ã®è©±ã§ã¯ï¼ŒãŸãã•ã‚“ã®Frameworkã ã®Libraryã ã®ãŒææ¡ˆã•ã‚Œã¦ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã¨æ€ã„ã¾ã™ï¼åƒ•ãªã‚“ã‹ã‚‚åˆã‚ã¦èãã‚‚ã®ãŒã‚ã‚Œã°ï¼Œã™ãã«ã‚°ã‚°ã£ã¦ãã®æ­£ä½“ã‚’çŸ¥ã‚ã†ã¨ã™ã‚‹ã®ã§ã™ãŒï¼Œã©ã‚Œã‚‚ã“ã‚Œã‚‚ã€Œã“ã‚Œã¯ä¾¿åˆ©ãªWeb Frameworkã§ã™ã€ãã‚‰ã„ã—ã‹æ•™ãˆã¦ãã‚Œã¾ã›ã‚“ï¼Frameworkã®æ­£ä½“ã£ã¦ä¸€ä½“ä½•ãªã®ã§ã—ã‚‡ã†ã‹ï¼æ°—ã«ãªã£ãŸã®ã§èª¿ã¹ã¦ã¿ã¾ã—ãŸï¼\nLibrary v.s. Framework Library Libraryã¯ï¼Œã‚³ãƒ¼ãƒ‰ã®å†åˆ©ç”¨ã‚’ç›®çš„ã¨ã—ãŸã€Œä¾¿åˆ©ãªé–¢æ•°ã‚„ã‚¯ãƒ©ã‚¹ã®ï¼ˆãŸã ã®ï¼‰ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã€ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ï¼Libraryã«å«ã¾ã‚Œã‚‹é–¢æ•°ã‚„ã‚¯ãƒ©ã‚¹ã¯ï¼Œã‚ã‚‹ç‰¹å®šã®å‡¦ç†ã‚’é”æˆã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å«ã‚“ã§ã„ã¦ï¼Œé–‹ç™ºè€…ãŒãã‚Œã‚‰ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§é–‹ç™ºã‚’é€²ã‚ã¦ã„ãã“ã¨ã«ãªã‚Šã¾ã™ï¼ä¾‹ãˆã°ã‚°ãƒ©ãƒ•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãªã‚‰ï¼ŒDijkstraæ³•ã¨ã‹Bellman-Fordæ³•ã‚’å®Ÿè£…ã—ãŸé–¢æ•°ãŒå«ã¾ã‚Œã¦ã„ã¦ï¼Œé–‹ç™ºè€…ãŒãã®é–¢æ•°ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹ç™ºã—ã¾ã™ï¼ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹ç™ºè€…ãŒæ›¸ã„ã¦ã„ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é–¢æ•°ãŒåˆ©ç”¨ã•ã‚Œã‚‹ã®ã§ï¼Œã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆ¶å¾¡ã¯é–‹ç™ºè€…å´ã«ã‚ã‚Šã¾ã™ï¼\nLibraryã‚’ç”¨ã„ã‚‹ã“ã¨ã§ï¼Œä»–ã®äººã®ä»•äº‹ã®æ©æµã«ä¸ã‚ŠãªãŒã‚‰é–‹ç™ºã‚’é€²ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ã“ã‚Œã¯ã¨ã¦ã‚‚å¬‰ã—ã„ã“ã¨ã§ã™ï¼é–‹ç™ºã®é€Ÿåº¦ãŒä¸ŠãŒã‚Šã¾ã™ï¼\nè¦ã™ã‚‹ã«ã€ŒLibraryã®ã‚³ãƒ¼ãƒ‰ã‚’é–‹ç™ºè€…ãŒåˆ©ç”¨ã™ã‚‹ã€ã®ãŒLibraryã§ã™ï¼\nFramework Frameworkã¯ï¼Œ (åˆæœŸåŒ–ã‹ã‚‰å®Ÿéš›ã®å‡¦ç†ï¼Œçµ‚äº†ã¨ã„ã£ãŸ) ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆ¶å¾¡ã¯ å…¨ã¦Frameworkå´ã«ã‚ã‚Šã¾ã™ ï¼ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹ç™ºè€…ã¯ï¼ŒFrameworkãŒè¦æ±‚ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’éƒ¨å“ã¨ã—ã¦Frameworkã«æä¾›ã™ã‚‹ã“ã¨ã«ãªã‚‹ã‚ã‘ã§ã™ï¼Frameworkã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®éª¨æ ¼ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã¨ã‚‚ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼å¤–æ ã ã‘å®šç¾©ã—ã¦ã„ã‚‹ã®ã§ã™ï¼ã“ã®Frameworkã®æŒã¤æ€§è³ªã¯ï¼Œã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å·¥å­¦çš„ã«ã¯ã€Œåˆ¶å¾¡ã®åè»¢ IoC (Inversion of Control)ã€ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ï¼\nFrameworkã‚’ç”¨ã„ã‚‹ã“ã¨ã§ï¼Œã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºè€…ã¯è¨­è¨ˆã«ã¤ã„ã¦ã‚ã‚Œã‚„ã“ã‚Œã‚„æ‚©ã‚€å¿…è¦ãŒãªããªã‚Šã¾ã™ï¼Frameworkã®è¦æ±‚ã«å¾“ã£ã¦ã„ã‚Œã°ï¼Œãã‚Œãªã‚Šã®å“è³ªã®ã‚·ã‚¹ãƒ†ãƒ ãŒå‹æ‰‹ã«å‡ºæ¥ä¸ŠãŒã‚‹ã“ã¨ã«ãªã‚‹ã‹ã‚‰ã§ã™ï¼ã¾ãŸï¼ŒFrameworkã«å‰‡ã£ã¦ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹ç™ºã—ã¦ã„ãã¨ï¼Œã‚³ãƒ¼ãƒ‰ã«ä¸€è²«æ€§ãŒç”Ÿã¾ã‚Œã¾ã™ï¼ã“ã‚Œã¯ã‚³ãƒ¼ãƒ‰ã«å¯èª­æ€§ã‚’ä¸ãˆï¼Œãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ãŒã—ã‚„ã™ããªã‚Šã¾ã™ï¼\nä¸€æ–¹ã§ï¼ŒFrameworkã¯ã€Œåˆ¶ç´„ã®é›†åˆã€ã§ã‚‚ã‚ã‚Šã¾ã™ï¼ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å…¨ä½“ã¨ã—ã¦ã®åˆ¶å¾¡ãŒé–‹ç™ºè€…ã®è‡ªç”±ã«ã§ããªã„ã‚ã‘ã§ã™ã‹ã‚‰ï¼ŒFrameworkã‚’å°å…¥ã™ã‚‹ãªã‚‰ã°Frameworkã®èª²ã™ãƒ«ãƒ¼ãƒ«ã‚’ç†è§£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼ãƒ«ãƒ¼ãƒ«ã‚’ç†è§£ã™ã‚‹ã®ã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹ã‚‚ã®ã§ã™ã—ï¼ŒFrameworkã®ãƒ«ãƒ¼ãƒ«ã«çª®å±ˆã•ã‚’æ„Ÿã˜ã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼å°è¦æ¨¡ãªãã®å ´é™ã‚Šã®é–‹ç™ºç¾å ´ãªã©ã§ã¯ï¼Œã“ã®åˆ¶ç´„ãŒFrameworkã®ãƒ¡ãƒªãƒƒãƒˆã‚’ä¸Šå›ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ï¼ŒFrameworkã‚’å°å…¥ã—ãªã„ã“ã¨ã‚‚ã‚ã‚‹ã§ã—ã‚‡ã†ï¼\nè¦ã™ã‚‹ã«ã€ŒFrameworkãŒé–‹ç™ºè€…ã®ã‚³ãƒ¼ãƒ‰ã‚’åˆ©ç”¨ã™ã‚‹ã€ã®ãŒFrameworkã§ã™ï¼\n   Libraryã¨Frameworkã¨ã‚ãªãŸ   å‚è€ƒ  ã‚½ãƒ•ãƒˆã‚¦ã‚¨ã‚¢ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¨ã¯ãªã«ã‹ (æ—¥çµŒXTECH) ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é•ã„ (Qiita) The Difference Between a Framework and a Library (freeCodeCamp) What is the difference between a framework and a library? (stackoverflow)  ","date":1572011115,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572011115,"objectID":"e54cb1b7589f8c07b1423f581d1a62ba","permalink":"/ja/post/what-is-the-difference-between-library-and-framework/","publishdate":"2019-10-25T22:45:15+09:00","relpermalink":"/ja/post/what-is-the-difference-between-library-and-framework/","section":"post","summary":"ã¡ã‚ƒã‚“ã¨èª¬æ˜ã§ãã¾ã™ã‹ï¼Ÿ","tags":["Framework","Library"],"title":"Framworkã¨Libraryã®é•ã„","type":"post"},{"authors":[],"categories":[],"content":"flagãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ Golangã§ã¯ï¼Œæ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã—ã¦ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‚’æ‰±ã†flagãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒä»˜å±ã—ã¦ã„ã¾ã™ï¼ã€Œç—’ã„æ‰€ã«æ‰‹ãŒå±Šãã€ã¨ã¯ã“ã®ã“ã¨ã§ã™ã­ï¼\nãƒ•ãƒ©ã‚°ã®ç«‹ã£ã¦ã„ãªã„ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®å–å¾— Parse()ã®å¾Œã«Args()ã§[]stringã¨ã—ã¦å–å¾—ã§ãã¾ã™ï¼\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { flag.Parse() args := flag.Args() fmt.Println(args) } $ go run with-no-flag0.go a b c [a b c] $ go run with-no-flag0.go 1 2 3 [1 2 3] $n$ç•ªç›®ã®è¦ç´ ã®ã¿ã‚’å–ã‚Šå‡ºã—ãŸã„å ´åˆã¯Arg(n)ã§stringã¨ã—ã¦å–å¾—ã§ãã¾ã™ï¼$n$ç•ªç›®ã®è¦ç´ ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯\u0026quot;\u0026quot;ãŒè¿”ã£ã¦ãã‚‹ã‚ˆã†ã§ã™ï¼\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { flag.Parse() fmt.Println(flag.Arg(0), flag.Arg(1)) } $ go run with-no-flag1.go hoge fuga hoge fuga $ go run with-no-flag1.go 1 1 ãƒ•ãƒ©ã‚°ã®ç«‹ã£ã¦ã„ã‚‹ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®å–å¾— å‹å()ã‚‚ã—ãã¯å‹åVar()ã§ï¼Œãƒ•ãƒ©ã‚°ã‚’å®šç¾©ã—ãŸã®ã¡ï¼ŒParse()ã§ãã‚Œãã‚Œã®å¤‰æ•°ã‚’å–å¾—ã§ãã¾ã™ï¼\nãƒ•ãƒ©ã‚°ã®å®šç¾©ã¯ã€Œãƒ•ãƒ©ã‚°åã€ã€Œãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã€ã€Œãƒ˜ãƒ«ãƒ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€ã§è¡Œã„ã¾ã™ï¼\nå‹å()ã®å ´åˆã¯ï¼ŒæŒ‡å®šã—ãŸå‹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãŒè¿”ã£ã¦ãã¾ã™ï¼\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { var ( i = flag.Int(\u0026#34;int\u0026#34;, 0, \u0026#34;int flag\u0026#34;) s = flag.String(\u0026#34;str\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag\u0026#34;) b = flag.Bool(\u0026#34;bool\u0026#34;, false, \u0026#34;bool flag\u0026#34;) ) flag.Parse() fmt.Println(*i, *s, *b) } $ go run with-flag0.go -int 2 -str hello -bool true 2 hello true $ go run with-flag0.go 0 default false å‹åVar()ã®å ´åˆã¯ï¼Œå¼•æ•°ã§æ¸¡ã—ãŸå¤‰æ•°ã«ä»£å…¥ã•ã‚Œã¾ã™ï¼ã¾ãŸï¼Œé©åˆ‡ãªå€¤ã‚’æ¸¡ã•ãªã„ã¨æ€’ã‚‰ã‚Œã¾ã™ï¼ãƒ€ãƒ¡ãªç†ç”±ã‚‚æ•™ãˆã¦ãã‚Œã‚‹ã®ã§æ€’ã‚‰ã‚ŒãŒã„ãŒã‚ã‚Šã¾ã™ï¼å®šç¾©ã—ã¦ã„ãªã„ãƒ•ãƒ©ã‚°ã‚‚å—ã‘ä»˜ã‘ã¦ãã‚Œã¾ã›ã‚“ï¼\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { var ( d time.Duration f float64 ) flag.DurationVar(\u0026amp;d, \u0026#34;dur\u0026#34;, 1 * time.Second, \u0026#34;duration flag\u0026#34;) flag.Float64Var(\u0026amp;f, \u0026#34;float\u0026#34;, 0.1, \u0026#34;float flag\u0026#34;) flag.Parse() fmt.Println(d, f) } $ go run with-flag1.go -dur 1h -float 2.3 1h0m0s 2.3 $ go run with-flag1.go -float str invalid value \u0026#34;str\u0026#34; for flag -float: strconv.ParseFloat: parsing \u0026#34;str\u0026#34;: invalid syntax Usage of /var/folders/.../with-flag1: -dur duration duration flag (default 1s) -float float float flag (default 0.1) exit status 2 ãƒ•ãƒ©ã‚°ã®æ›¸ãæ–¹ ãƒ•ãƒ©ã‚°ã®æ›¸ãæ–¹ã¯æ¬¡ã®2é€šã‚ŠãŒå¯èƒ½ã§ã™ï¼\n -flag value -flag=value  ãŸã ã—ï¼ŒBoolå€¤ã‚’å–å¾—ã™ã‚‹å ´åˆã¯flag=valueã‚’ä½¿ã£ãŸæ–¹ãŒã„ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼ã¨ã„ã†ã®ã‚‚ï¼Œ ãƒ•ãƒ©ã‚°ã®å‹ãŒBoolå€¤ã‹ã¤å¼•æ•°ãŒç¶šã‹ãªã„å ´åˆï¼Œãƒ•ãƒ©ã‚°ãŒç«‹ã£ãŸã ã‘ã§trueã¨ãªã‚‹ã‹ã‚‰ã§ã™ï¼\nã¤ã¾ã‚Šï¼Œãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã¦Boolå€¤ã‚’å–å¾—ã—ãŸã„å ´åˆã¯-bool=true/-bool=falseã¨ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã„ã†ã“ã¨ã§ã™ï¼-bool falseã§ã¯trueã¨ãªã£ã¦ã—ã¾ã„ã¾ã™ï¼ã¾ãŸ-bool falseä»¥é™ã®å¼•æ•°ãŒå…¨ã¦ãƒ•ãƒ©ã‚°ç„¡ã—ã§æ¸¡ã•ã‚ŒãŸå¼•æ•°ã¨ã—ã¦è©•ä¾¡ã•ã‚Œã¦ã—ã¾ã„ã¾ã™ï¼æ³¨æ„ãŒå¿…è¦ã§ã™ã­ï¼\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { var ( i = flag.Int(\u0026#34;int\u0026#34;, 0, \u0026#34;int flag\u0026#34;) s = flag.String(\u0026#34;str\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag\u0026#34;) b = flag.Bool(\u0026#34;bool\u0026#34;, false, \u0026#34;bool flag\u0026#34;) ) flag.Parse() fmt.Println(*i, *s, *b) } $ go run with-flag0.go -bool false -int 123 -str abc # falseã‚’å«ã‚€ãã‚Œä»¥é™ãŒå…¨ã¦éãƒ•ãƒ©ã‚°ã§æ¸¡ã•ã‚ŒãŸã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ 0 default true $ go run with-flag0.go -bool=true -int 123 -str abc 123 abc true $ go run with-flag0.go -bool=false -int 123 -str abc 123 abc false ã¡ãªã¿ã«-hã§ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã—ã¦ãã‚Œã¾ã™ï¼è³¢ã„ã§ã™ã­ï¼\n$ go run with-flag0.go -h Usage of /var/folders/.../with-flag0: -bool bool flag -int int int flag -str string string flag (default \u0026#34;default\u0026#34;) exit status 2 ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®å€‹æ•°ã‚’æ•°ãˆã‚‹ NArg()ã§éãƒ•ãƒ©ã‚°ãªã‚‚ã®ã‚’ï¼ŒNFlag()ã§ãƒ•ãƒ©ã‚°ãªã‚‚ã®ã‚’ã‚«ã‚¦ãƒ³ãƒˆã§ãã¾ã™ï¼\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { flag.Int(\u0026#34;int\u0026#34;, 0, \u0026#34;int flag\u0026#34;) flag.String(\u0026#34;str\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag\u0026#34;) flag.Bool(\u0026#34;bool\u0026#34;, false, \u0026#34;bool flag\u0026#34;) flag.Parse() fmt.Println(\u0026#34;non flag:\u0026#34;, flag.NArg()) fmt.Println(\u0026#34;flag:\u0026#34;, flag.NFlag()) } $ go run flag-test.go -int 1 -str foo -bool=true a b non flag: 2 flag: 3 $ go run flag-test.go -int 1 -str foo -bool true a b non flag: 3 flag: 3 $ go run flag-test.go -bool true -int 1 -str foo a b non flag: 7 flag: 1 $ go run flag-test.go a b c -bool=true -str foo non flag: 6 flag: 0 $ go run flag-test.go -bool=true -str foo a b c non flag: 3 flag: 2 $ go run flag-test.go a b c non flag: 3 flag: 0 $ go run flag-test.go -bool=true -str foo non flag: 0 flag: 2 ","date":1571997871,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1571997871,"objectID":"0bf003175f088b27d9d436b60a11ab98","permalink":"/ja/post/handle-commandline-args-with-flag-package/","publishdate":"2019-10-25T19:04:31+09:00","relpermalink":"/ja/post/handle-commandline-args-with-flag-package/","section":"post","summary":"flagãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‚’è³¢ãæ‰±ãŠã†ï¼","tags":["Golang","Tips"],"title":"ğŸš©flagãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‚’æ‰±ã†","type":"post"},{"authors":[],"categories":[],"content":"ã¯ã˜ã‚ã« æœ€è¿‘ã¯ã‚‚ã£ã±ã‚‰å’è«–ã®å®Ÿè£…ã°ã‹ã‚Šã‚„ã£ã¦ã„ã¾ã™ï¼Œzakã§ã™ï¼\nãƒ—ãƒ­ã‚°ãƒ©ãƒ æ›¸ãã®ã£ã¦é›£ã—ã„ã§ã™ã‚ˆã­ï¼åƒ•ã«ã¨ã£ã¦ã¯ã¨ã¦ã‚‚é›£ã—ã„ã®ã§ï¼Œã‚ã‹ã‚‰ãªã„ã“ã¨ãŒã‚ã£ãŸã‚‰ãƒ‡ã‚­ã‚‹äººã®ãƒ–ãƒ­ã‚°ã‚’å‚è€ƒã«ã•ã›ã¦ã„ãŸã ã„ãŸã‚Šã—ã¦ã„ã¾ã™ï¼ ãã‚“ãªä¸­ã§ï¼Œè‡ªåˆ†ã‚‚ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã“ã¨ãŒå¢—ãˆã¦ãã¦ï¼Œãã“ã§å¾—ãŸçŸ¥è­˜ã‚’ãªã‚“ã‚‰ã‹ã®å½¢ã§ç™ºä¿¡ã§ããªã„ã‹ãªã¨æ€ã£ã¦ï¼Œã“ã®ãƒ–ãƒ­ã‚°ã‚’æ€ã„ã¤ãã§å§‹ã‚ã¾ã—ãŸï¼\næ¡ç”¨æŠ€è¡“ ã“ã®ãƒ–ãƒ­ã‚°ã¯ã‚µã‚¤ãƒˆã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦Hugoï¼Œãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã¨ã—ã¦GitHub Pagesã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ï¼\nHugoã¯Golangã§è¨˜è¿°ã•ã‚ŒãŸã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ã®é™çš„ã‚µã‚¤ãƒˆã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã™ï¼è¨­å®šã‚’tomlã§æ›¸ã„ã¦ï¼Œè¨˜äº‹ã‚’Markdownã§æ›¸ã„ã¦ï¼Œãã‚Œã‚’HugoãŒHTMLãã®ä»–ãƒ•ã‚¡ã‚¤ãƒ«ã«çˆ†é€Ÿã§ã—ãŸãŸã‚ã¦ãã‚Œã¾ã™ï¼çœŸé¢ç›®ã«ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã‚’ä½œã‚ã†ã¨ã™ã‚‹ã¨ï¼Œã€Œæ›¸ãã«ãã„HTMLã§æ–‡ç« ã‚’æ›¸ã„ã¦ï¼ŒCSSã§è¦‹æ „ãˆã‚’æ•´ãˆã¦ã€ã¨ã„ã†æ„Ÿã˜ã§ä½œã£ã¦ã„ãã“ã¨ã«ãªã‚Šã¾ã™ï¼HTMLã£ã¦ã‚ã‚“ã¾ã‚Šæ´—ç·´ã•ã‚Œã¦ã„ãªãã¦äººé–“ã«ã¨ã£ã¦ã¯èª­ã¿ãšã‚‰ã„ã§ã™ã‚ˆã­ï¼ä¸€æ–¹ã§Markdownã¯æ–‡æ³•ãŒç°¡å˜ãªã®ã§ï¼Œç®‡æ¡æ›¸ãã§ãƒ¡ãƒ¢ã£ã¦ã‚‹ãã‚‰ã„ã®æ„Ÿè¦šã§æ§‹é€ ã‚’æŒã£ãŸæ–‡ç« ãŒæ›¸ã‘ã¦ã—ã¾ã„ã¾ã™ï¼Hugoã‚’ä½¿ã†ã“ã¨ã§ï¼Œã‚µã‚¤ãƒˆä½œæˆè€…ã¯Markdownã¨ã„ã†ã‚ã‹ã‚Šã‚„ã™ã„æ–‡æ³•ã§è¨˜äº‹ã‚’æ›¸ãã“ã¨ãŒã§ãï¼Œæœ¬æ¥ã®ä»•äº‹ã«å°‚å¿µã§ãã‚‹ã‚ã‘ã§ã™ï¼\nHugoã®ã„ã„ã¨ã“ã‚ã¯ãã‚Œã ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼Hugoã¯ãã®ä¾¿åˆ©ã•ã‹ã‚‰ï¼Œå¤šãã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰æ„›ã•ã‚Œã¦ã„ã¦ï¼Œãã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚‰ãŒãã‚Œãã‚Œç¾ã—ã„ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ†ãƒ¼ãƒã‚’å…¬é–‹ã—ã¦ãã‚Œã¦ã„ã¾ã™ï¼ã©ã‚Œã‚‚ã‚»ãƒ³ã‚¹ãŒè‰¯ãï¼Œæ©Ÿèƒ½é¢ã§ã‚‚å……å®Ÿã—ã¦ã„ã¾ã™ï¼ã“ã®ãƒ†ãƒ¼ãƒã¯ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ã§å…¬é–‹ã•ã‚Œã¦ã„ã‚‹ã®ã§ï¼Œã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚‚ç°¡å˜ã§ã™ï¼ãã“ã‚‰ã¸ã‚“ã®ãƒ–ãƒ­ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆ©ç”¨ã™ã‚‹ã¨ï¼Œãƒ†ãƒ¼ãƒãŒã©ã‚Œã‚‚é™³è…ã§ä¸æº€ã§ã™ã‚ˆã­ï¼\nä»Šå›ã¯Markdownã§è¨˜äº‹ãŒåŸ·ç­†ã§ãã‚‹ã¨ã“ã‚ã¨Hugoã§ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã‚‹Academicã¨ã„ã†ãƒ†ãƒ¼ãƒãŒæ°—ã«å…¥ã£ãŸã®ã§ï¼ŒHugoã‚’ä½¿ã†ã“ã¨ã«ã—ã¾ã—ãŸï¼\nGitHub Pagesã¯ï¼ŒGitHubãŒæä¾›ã—ã¦ã„ã‚‹é™çš„ã‚µã‚¤ãƒˆã®ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã§ã™ï¼GitHubã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã•ãˆã‚ã‚Œã°ï¼Œèª°ã§ã‚‚é™çš„ãªã‚µã‚¤ãƒˆã‚’å…¬é–‹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ä½•ã‚ˆã‚Šç„¡æ–™ãªã®ã§ï¼Œã“ã‚Œã‚’ä½¿ã‚ãªã„æ‰‹ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ã‚µã‚¤ãƒˆã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’GitHubã§ç®¡ç†ã—ã¤ã¤å…¬é–‹ã‚‚ã§ãã¡ã‚ƒã†ãªã‚“ã¦ï¼ŒGitHubã¯å¤ªã£è…¹ã§ã™ã­ï¼\nGitHub Pagesã®ä»–ã«ã‚‚ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã¯ã‚ã‚Šã¾ã™ãŒï¼Œã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ç®¡ç†ã¨ä¸€ç·’ã«ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã§ãã‚‹ã¨ã“ã‚ãŒä¾¿åˆ©ã ã¨æ€ã£ãŸã®ã§æ¡ç”¨ã—ã¾ã—ãŸï¼\n æ°—ãŒå‘ã„ãŸã‚‰ï¼Œã‚‚ã†ã¡ã‚‡ã£ã¨è¿½è¨˜ã—ã¾ã™ ğŸ™‡â€â™‚ï¸\n ","date":1571991698,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1571991698,"objectID":"7c7a7a98c108a8c69ca3bde923f50c92","permalink":"/ja/post/about-this-site/","publishdate":"2019-10-25T17:21:38+09:00","relpermalink":"/ja/post/about-this-site/","section":"post","summary":"ã“ã®ãƒ–ãƒ­ã‚°ã®æŠ€è¡“çš„ãªã¨ã“ã‚ã‚’ã¾ã¨ã‚ã¦ã¿ã¾ã—ãŸï¼ã¾ã é€”ä¸­ã§ã™ :bow:","tags":["Hugo","GitHub","Golang"],"title":"Hugoã¨GitHub Pagesã§ãƒ–ãƒ­ã‚°ã‚’ä½œã£ã¦ã¿ãŸï¼","type":"post"},{"authors":[],"categories":[],"content":"ã”æŒ¨æ‹¶ ã¯ã˜ã‚ã¾ã—ã¦ï¼æŠ€è¡“ãƒ–ãƒ­ã‚°å§‹ã‚ã¦ã¿ã¾ã—ãŸï¼ã¼ã¡ã¼ã¡æŠ•ç¨¿ã—ã¾ã™ ğŸ‘\n","date":1571990829,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1571990829,"objectID":"2247257f33c5eaa1cd0616bf37b07249","permalink":"/ja/post/first-post/","publishdate":"2019-10-25T17:07:09+09:00","relpermalink":"/ja/post/first-post/","section":"post","summary":"ãƒ–ãƒ­ã‚°ã‚’å§‹ã‚ã¦ã¿ãŸã®ã§ãŠçŸ¥ã‚‰ã›ã§ã™ï¼","tags":[],"title":"ğŸš€æœ€åˆã®æŠ•ç¨¿","type":"post"}]