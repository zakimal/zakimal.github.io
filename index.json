[{"authors":["admin"],"categories":null,"content":"はじめまして！zak です．\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"ja","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"はじめまして！zak です．","tags":null,"title":"尾崎 耀一 (@zak)","type":"authors"},{"authors":[],"categories":[],"content":" ありがちな会話 「Web Application Frameworkと言ったら，やっぱりRuby on Railsだよね！」\n「Webのフロント開発ではjQueryってライブラリがあってだな\u0026hellip;」\n「最近だと，FacebookがJavascriptのフレームワークとしてReactを発表してるよね」\n「ReactよりAngular JSの方がいいよ」\nWeb系の技術の話では，たくさんのFrameworkだのLibraryだのが提案されて使用されていると思います．僕なんかも初めて聞くものがあれば，すぐにググってその正体を知ろうとするのですが，どれもこれも「これは便利なWeb Frameworkです」ぐらいしか教えてくれません．Frameworkの正体って一体何なのでしょうか．気になったので調べてみました．\nLibrary v.s. Framework Library Libraryは，コードの再利用を目的とした「便利な関数やクラスの（ただの）コレクション」のようなものです．Libraryに含まれる関数やクラスは，ある特定の処理を達成するロジックを含んでいて，開発者がそれらを利用することで開発を進めていくことになります．例えばグラフアルゴリズムのライブラリなら，Dijkstra法とかBellman-Ford法を実装した関数が含まれていて，開発者がその関数を利用することでアプリケーションを開発します．アプリケーションの開発者が書いているロジックにライブラリの関数が利用されるので，アプリケーションの制御は開発者側にあります．\nLibraryを用いることで，他の人の仕事の恩恵に与りながら開発を進めることができます．これはとても嬉しいことです．開発の速度が上がります．\n要するに「Libraryのコードを開発者が利用する」のがLibraryです．\nFramework Frameworkは， (初期化から実際の処理，終了といった) アプリケーションの制御は 全てFramework側にあります ．アプリケーションを開発者は，Frameworkが要求するロジックを部品としてFrameworkに提供することになるわけです．Frameworkはアプリケーションの骨格を定義しているともいるかもしれません．外枠だけ定義しているのです．このFrameworkの持つ性質は，ソフトウェア工学的には「制御の反転 IoC (Inversion of Control)」と呼ばれています．\nFrameworkを用いることで，アプリケーション開発者は設計についてあれやこれや悩む必要がなくなります．Frameworkの要求に従っていれば，それなりの品質のシステムが勝手に出来上がることになるからです．また，Frameworkに則ってアプリケーションを開発していくと，コードに一貫性が生まれます．これはコードに可読性を与え，メンテナンスがしやすくなります．\n一方で，Frameworkは「制約の集合」でもあります．アプリケーションの全体としての制御が開発者の自由にできないわけですから，Frameworkを導入するならばFrameworkの課すルールを理解する必要があります．ルールを理解するのには時間がかかるものですし，Frameworkのルールに窮屈さを感じることもあるかもしれません．小規模なその場限りの開発現場などでは，この制約がFrameworkのメリットを上回ることがあるので，Frameworkを導入しないこともあるでしょう．\n要するに「Frameworkが開発者のコードを利用する」のがFrameworkです．\n   LibraryとFrameworkとあなた   参考  ソフトウエアのフレームワークとはなにか (日経XTECH) フレームワークとライブラリの違い (Qiita) The Difference Between a Framework and a Library (freeCodeCamp) What is the difference between a framework and a library? (stackoverflow)  ","date":1572011115,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572011115,"objectID":"a71d33c562a66cea22d1982e942304e4","permalink":"/post/20191025-what-is-the-difference-between-library-and-framework/","publishdate":"2019-10-25T22:45:15+09:00","relpermalink":"/post/20191025-what-is-the-difference-between-library-and-framework/","section":"post","summary":"ちゃんと説明できますか？","tags":["Framework","Library"],"title":"FramworkとLibraryの違い","type":"post"},{"authors":[],"categories":[],"content":" flagパッケージ Golangでは，標準パッケージとしてコマンドライン引数を扱うflagパッケージが付属しています．「痒い所に手が届く」とはこのことですね．\nフラグの立っていないコマンドライン引数の取得 Parse()の後にArgs()で[]stringとして取得できます．\npakcage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { flag.Parse() args := flag.Args() fmt.Println(args) }  $ go run with-no-flag0.go a b c [a b c] $ go run with-no-flag0.go 1 2 3 [1 2 3]  $n$番目の要素のみを取り出したい場合はArg(n)でstringとして取得できます．$n$番目の要素が存在しない場合は\u0026quot;\u0026quot;が返ってくるようです．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { flag.Parse() fmt.Println(flag.Arg(0), flag.Arg(1)) }  $ go run with-no-flag1.go hoge fuga hoge fuga $ go run with-no-flag1.go 1 1  フラグの立っているコマンドライン引数の取得 型名()もしくは型名Var()で，フラグを定義したのち，Parse()でそれぞれの変数を取得できます．\nフラグの定義は「フラグ名」「デフォルト値」「ヘルプメッセージ」で行います．\n型名()の場合は，指定した型へのポインタが返ってきます．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { var ( i = flag.Int(\u0026quot;int\u0026quot;, 0, \u0026quot;int flag\u0026quot;) s = flag.String(\u0026quot;str\u0026quot;, \u0026quot;default\u0026quot;, \u0026quot;string flag\u0026quot;) b = flag.Bool(\u0026quot;bool\u0026quot;, false, \u0026quot;bool flag\u0026quot;) ) flag.Parse() fmt.Println(*i, *s, *b) }  $ go run with-flag0.go -int 2 -str hello -bool true 2 hello true $ go run with-flag0.go 0 default false  型名Var()の場合は，引数で渡した変数に代入されます．また，適切な値を渡さないと怒られます．ダメな理由も教えてくれるので怒られがいがあります．定義していないフラグも受け付けてくれません．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func main() { var ( d time.Duration f float64 ) flag.DurationVar(\u0026amp;d, \u0026quot;dur\u0026quot;, 1 * time.Second, \u0026quot;duration flag\u0026quot;) flag.Float64Var(\u0026amp;f, \u0026quot;float\u0026quot;, 0.1, \u0026quot;float flag\u0026quot;) flag.Parse() fmt.Println(d, f) }  $ go run with-flag1.go -dur 1h -float 2.3 1h0m0s 2.3 $ go run with-flag1.go -float str invalid value \u0026quot;str\u0026quot; for flag -float: strconv.ParseFloat: parsing \u0026quot;str\u0026quot;: invalid syntax Usage of /var/folders/.../with-flag1: -dur duration duration flag (default 1s) -float float float flag (default 0.1) exit status 2  フラグの書き方 フラグの書き方は次の2通りが可能です．\n -flag value -flag=value  ただし，Bool値を取得する場合はflag=valueを使った方が混乱がないかもしれません．というのも， フラグの型がBool値かつ引数が続かない場合，フラグが立っただけでtrueとなるからです．\nつまり，フラグを立ててBool値を取得したい場合は-bool=true/-bool=falseとしなければならないということです．-bool falseではtrueとなってしまいます．また-bool false以降の引数が全てフラグ無しで渡された引数として評価されてしまいます．注意が必要ですね．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { var ( i = flag.Int(\u0026quot;int\u0026quot;, 0, \u0026quot;int flag\u0026quot;) s = flag.String(\u0026quot;str\u0026quot;, \u0026quot;default\u0026quot;, \u0026quot;string flag\u0026quot;) b = flag.Bool(\u0026quot;bool\u0026quot;, false, \u0026quot;bool flag\u0026quot;) ) flag.Parse() fmt.Println(*i, *s, *b) }  $ go run with-flag0.go -bool false -int 123 -str abc # falseを含むそれ以降が全て非フラグで渡されたコマンドライン引数として扱われる 0 default true $ go run with-flag0.go -bool=true -int 123 -str abc 123 abc true $ go run with-flag0.go -bool=false -int 123 -str abc 123 abc false  ちなみに-hでヘルプを表示してくれます．賢いですね．\n$ go run with-flag0.go -h Usage of /var/folders/.../with-flag0: -bool bool flag -int int int flag -str string string flag (default \u0026quot;default\u0026quot;) exit status 2  コマンドライン引数の個数を数える NArg()で非フラグなものを，NFlag()でフラグなものをカウントできます．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { flag.Int(\u0026quot;int\u0026quot;, 0, \u0026quot;int flag\u0026quot;) flag.String(\u0026quot;str\u0026quot;, \u0026quot;default\u0026quot;, \u0026quot;string flag\u0026quot;) flag.Bool(\u0026quot;bool\u0026quot;, false, \u0026quot;bool flag\u0026quot;) flag.Parse() fmt.Println(\u0026quot;non flag:\u0026quot;, flag.NArg()) fmt.Println(\u0026quot;flag:\u0026quot;, flag.NFlag()) }  $ go run flag-test.go -int 1 -str foo -bool=true a b non flag: 2 flag: 3 $ go run flag-test.go -int 1 -str foo -bool true a b non flag: 3 flag: 3 $ go run flag-test.go -bool true -int 1 -str foo a b non flag: 7 flag: 1 $ go run flag-test.go a b c -bool=true -str foo non flag: 6 flag: 0 $ go run flag-test.go -bool=true -str foo a b c non flag: 3 flag: 2 $ go run flag-test.go a b c non flag: 3 flag: 0 $ go run flag-test.go -bool=true -str foo non flag: 0 flag: 2  ","date":1571997871,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1571997871,"objectID":"e87e45f7c902236c84d6f34657cf68de","permalink":"/post/20191025-handle-commandline-args-with-flag-package/","publishdate":"2019-10-25T19:04:31+09:00","relpermalink":"/post/20191025-handle-commandline-args-with-flag-package/","section":"post","summary":"flagパッケージでコマンドライン引数を賢く扱おう！","tags":["Golang","Tips"],"title":"🚩flagパッケージでコマンドライン引数を扱う","type":"post"},{"authors":[],"categories":[],"content":" はじめに 最近はもっぱら卒論の実装ばかりやっています，zakです．\nプログラム書くのって難しいですよね．僕にとってはとても難しいので，わからないことがあったらデキる人のブログを参考にさせていただいたりしています． そんな中で，自分もコードを書くことが増えてきて，そこで得た知識をなんらかの形で発信できないかなと思って，このブログを思いつきで始めました．\n採用技術 このブログはサイトジェネレータとしてHugo，ホスティングサービスとしてGitHub Pagesを採用しています．\nHugoはGolangで記述されたオープンソースの静的サイトジェネレーターです．設定をtomlで書いて，記事をMarkdownで書いて，それをHugoがHTMLその他ファイルに爆速でしたためてくれます．真面目にウェブサイトを作ろうとすると，「書きにくいHTMLで文章を書いて，CSSで見栄えを整えて」という感じで作っていくことになります．HTMLってあんまり洗練されていなくて人間にとっては読みずらいですよね．一方でMarkdownは文法が簡単なので，箇条書きでメモってるぐらいの感覚で構造を持った文章が書けてしまいます．Hugoを使うことで，サイト作成者はMarkdownというわかりやすい文法で記事を書くことができ，本来の仕事に専念できるわけです．\nHugoのいいところはそれだけではありません．Hugoはその便利さから，多くのユーザーから愛されていて，そのユーザーらがそれぞれ美しいデザインテーマを公開してくれています．どれもセンスが良く，機能面でも充実しています．このテーマはオープンソースで公開されているので，カスタマイズも簡単です．そこらへんのブログサービスを利用すると，テーマがどれも陳腐で不満ですよね．\n今回はMarkdownで記事が執筆できるところとHugoで用いることができるAcademicというテーマが気に入ったので，Hugoを使うことにしました．\nGitHub Pagesは，GitHubが提供している静的サイトのホスティングサービスです．GitHubのアカウントさえあれば，誰でも静的なサイトを公開することができます．何より無料なので，これを使わない手はありません．サイトのソースコードをGitHubで管理しつつ公開もできちゃうなんて，GitHubは太っ腹ですね．\nGitHub Pagesの他にもホスティングサービスはありますが，ソースコード管理と一緒にホスティングできるところが便利だと思ったので採用しました．\n 気が向いたら，もうちょっと追記します 🙇\n ","date":1571991698,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1571991698,"objectID":"92101e6776dc0197112ca68e1946c02c","permalink":"/post/20191025-about-this-site/","publishdate":"2019-10-25T17:21:38+09:00","relpermalink":"/post/20191025-about-this-site/","section":"post","summary":"このブログの技術的なところをまとめてみました！まだ途中です :bow:","tags":["Hugo","GitHub","Golang"],"title":"HugoとGitHub Pagesでブログを作ってみた！","type":"post"},{"authors":[],"categories":[],"content":" ご挨拶 はじめまして．技術ブログ始めてみました．ぼちぼち投稿します 👍\n","date":1571990829,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1571990829,"objectID":"5ad7fa8f419d08c6ac1ea749cefd66c3","permalink":"/post/20191025-first-post/","publishdate":"2019-10-25T17:07:09+09:00","relpermalink":"/post/20191025-first-post/","section":"post","summary":"ブログを始めてみたのでお知らせです．","tags":[],"title":"🚀最初の投稿","type":"post"}]