[{"authors":["admin"],"categories":null,"content":"はじめまして！zak です．\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"ja","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"はじめまして！zak です．","tags":null,"title":"尾崎 耀一 (@zak)","type":"authors"},{"authors":[],"categories":[],"content":"golangとconcurrentなプログラミング 「concurrentな処理をどのように実現するか」はざっくり分けて2アプローチがある．\n1つは「shared-memory communication」．つまり処理を実行しているworker同士は，メモリを共有して，その共有しているメモリを用いてコミュニケーションを取るというもの．この場合，データ競合が発生しないようにロックを取ったりなどの排他処理を伴うことになって，大抵の場合実装が難しくなるとされている．\nもう1つは「message-passing communication」．つまり処理を実行しているworker同士は，メッセージをやり取りし合うことでコミュニケーションを取るというもの．\nそれぞれのアプローチでいろんな実装が世の中にはすでに存在していて，例えばCでconcurrentなプログラムを書こうとするとshared-memory communicationな形で書くことになる．一方でErlangは言語としてconcurrentなプログラミングをサポートしていて，Actorモデルを実装してる．\ngolangは，設計の時点でconcurrentなプログラミングは\n Do not communicate by sharing memory; instead, share memory by communicating\n という思想で実装することとしている．golangのconcurrentなプログラミングの実装は「Communicating Sequential Processes」と「$\\pi$-caluculus」を参考にしている．\ngolangは「concurrentなプログラミングを簡潔にわかりやすく記述すること」を言語の設計レベルからサポートしているので，concurrentな処理がとても書きやすくなっている．じゃあgolangではどうやってconcurrentなプログラミングをサポートしているのかというと，concurrentなプログラミングのプリミティブとしてgoroutine，channelを提供している．\n「golangはconcurrentな処理が書きやすいんだよね」という話をすると混乱しがちなのが， 「golangはconcurrentな処理を書くための道具を提供してくれるが，その実行がparallelであるかどうかはハードウェアに依存する」 という点．concurrentな処理は，parallelに実行することができるかもしれない（し大抵parallelに実行できるならそうしたほうがいい）が，それはハードウェアがparallelな実行をサポートしているか（例えばCPUが複数コア搭載しているか）によって決まってくる話であって，「プログラムがconcurrentであること」と「プログラムの実行がparallelであること」は関連はしているけれども，全く別の話．Rob Pike先生も\n Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once. Not the same, but related. Concurrency is about structure, parallelism is about execution. Concurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.\n って仰っている．\nHello, goroutine!  「golangではconcurrentなプログラムを書きやすい」ということだったので，実際にconcurrentなプログラムを書いてみると上の例みたいになる．concurrentに処理を実行するworkerは，golangの世界ではgorutineと呼ばれていて，goという魔法の言葉に続けてworkerで実行してほしい関数を呼び出せば，それでconcurrentな処理を書き下したことになる．なんて簡単なんだ...！\n上の例を実行すると，Hello! I'm mainって印字されて，もしかしたらHi! I'm goroutine!も一緒に印字される かもしれない．「かもしれない」っていうのは，goroutineは「あるgoroutineの親は自分の子供の処理が終わるのを待たない」ことになっている．この場合だとmainが親でgo fmt.Println(\u0026quot;Hi! I'm goroutine!\u0026quot;)が子供の関係になっていて，mainのfmt.Println(\u0026quot;Hello! I'm main\u0026quot;)の終了したら，その時点で子供の実行も終了させられてしまう．もし，子供のgoroutineが自己紹介し終わる前に親が自己紹介しきっちゃえば子供の自己紹介は印字されないし，親の自己紹介が終わる前に子供が自己紹介しきっちゃえば，親子両方の自己紹介が聞けることになる．\n「なるほど．でも親が先に終わっちゃうと子供も強制終了って，それどうにかならないの？」って思った方は賢くて，どうにかするためにgoroutine間でおしゃべりできるchannelというデータ構造が実装してある．\nNice to meet you, channel! channelはgoroutineたちが同期しながらconcurrentな処理を実行していくためのmessage-passingのメカニズムを提供してくれる．channelは「そのchannelを通じてやり取りするデータの型・バッファサイズ・メッセージのやり取りの方向」で定義されて，組み込み関数のmake()で簡単に作ることができる．\ngolangでは「channelはfirst-class value」として扱われる．つまりchannelは，他の値（例えばなんらかの構造体とかint型の変数とか関数とか）と同じレベルで扱われる．だから関数がchannelを返すなんてこともできるし，関数の引数にchannelを与えることもできるし，channelのchannelも定義できる．\nchannelの入出力の方向は\u0026lt;-という演算子で表現することになっている．\u0026lt;- cって書けばchannel cからデータを読み込むことになるし，c \u0026lt;- 1って書けばchannel cに1を書き込んだことになる．\nということで，channelを使った簡単ばプログラムを書いてみるとこんな感じになる．\n channel done を使って「僕は自己紹介終わったよママ」って子供のgoroutineが親mainに連絡することで，実行が同期されて両方の自己紹介が聞けるようになった．\nchannel doneは「bool値を通す，バッファが0の，読み書きができるchannel」として定義されている．golangでは「バッファが0のchannelに対する読み書きは，情報の送受信両者がコミュニケーションの準備ができるようになるまでブロックされる」ことになっている．なので，この例だと，確実に子供goroutineの自己紹介を聞くことができることになる．「バッファが0のchannelに対する読み書きは，情報の送受信両者がコミュニケーションの準備ができるようになるまでブロックされる」という挙動からバッファが0のchannelは「synchronous」と言える．\n下の例を実行すると，channel messageに1を送り終わってから，mainが1秒寝てしまうので，子供はchannel messageに続く2，3を送れなくて，止められてしまう．この挙動はsynchronousということになる．\n 一方で，バッファのあるchannelに対する読み書きは「バッファが空でないなら読み込みはブロックされない」「バッファが一杯でないなら書き込みはブロックされない」という挙動になっている．なので，バッファのあるchannelは「asynchronous」と言える．\n下の例を実行すると，channel messageはバッファを持っているので子供は1，2，3，4と（mainが眠りから覚める前に）立て続けに送ることができる．この挙動はまさしくasynchronousだ．\nOh, poor deadlock... 「goroutineもchannelもわかったので」ということで下みたいなプログラムを書くとdeadlockと言われてgolangのruntimeから叱られる．\n これはつまりどういうことかというと，golangのruntimeが「お前のプログラム実行したけど7行目でバッファのないchannelに42って送ってる（c \u0026lt;- 42）けど，それしたら受信者がいないし，受信者がいないと送信者も実行を進められないので，どうすることもできなくなっちゃったぞ」と怒っているのだ．\n「バッファのないchannelはgoroutine間の挙動をsynchronousにするもの」なので「受信者となるgoroutineのいない，バッファ0のchannelに値を送るとdeadlockする」のだ．\n今回の場合だと，受信者が存在しないことが問題なので，受信者となるgoroutineを作ればうまくいく．\n Let's range channels and close them. channelはrange構文を使って1つずつ値を取り出すということも記述できる．でも，rangeを使ってchannelから値を次々取り出すときはchannelを明示的にclose()しないといけない．\n チャンネルは組み込み関数のclose()で「閉じる」ことができて，閉じられたchannelに対して書き込みを行おうとするとgolangのruntimeはpanicして，閉じられたchannelに対して読み込みを行おうとするとそのchannelの扱う型のゼロ値が得られることになっている．\n「閉じられたchannelに対する読み込み」の特徴は「goroutineに処理の終了を通知させる機構」として応用することができる．大抵，こういう処理終了通知を行う場合は空の構造体struct{}のchannelを使う．なんてったって空の構造体は0byteだからね．\n あと，閉じられたchannelに対する読み込みはブロックされないので，そのまま処理は進む．\nMultiple channels and select. goroutineとchannelを使って実際になんらかの意味のあるプログラムを書こうとすると，たくさんのgoroutineとたくさんのchannelを扱うことになるのが普通である．大抵の場合「複数のchannelを同時に待ち受けたい」状況に出くわす．golangでは複数のchannelを同時に待ち受けるselect構文を用意している．\n select { case ...: ...}という構文で，複数のchannelを同時に待ち受け，値が書き込まれたchannelだけに対応するという，イベント駆動みたいな処理も簡単に書くことができるようになっている．\nchannel，お前最高かよ！ channelはマジで便利！でも使いこなすにはchannelの挙動をよく理解していないといけない．\n","date":1572528748,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572528748,"objectID":"d1a9aaedba5cb2d487581db7040bf32b","permalink":"/post/golang-channels-tutorial/","publishdate":"2019-10-31T22:32:28+09:00","relpermalink":"/post/golang-channels-tutorial/","section":"post","summary":"Golangの根っこに組み込まれているconcurrencyを実現する重要な部品であるchannelについて解説します！","tags":["Goalg","Channel","Tutorial"],"title":"Golang channels tutorial","type":"post"},{"authors":[],"categories":[],"content":" 日本語にすると\u0026hellip; 調べてみると，「Concurrentは並行」「Parallelは並列」と訳されるのが一般的らしいですが，日本語にしたところで違いが判然としないので，自分なりの解釈を書いてはっきりさせておきます．\nっと，その前に広辞苑によれば\u0026hellip;  【並行】並びゆくこと．また，並び行なわれること．「両案を並行して審議する」\n【並列】並び連なること．直列の対義語\n ダメだった．\nじゃあ，英英辞典（Oxford Dictionary）で引くと\u0026hellip;  concurrent\nExisting, happening, or done at the same time. ‘there are three concurrent art fairs around the city’\nparallel\n[Computing] Involving the simultaneous performance of operations. ‘highly parallel multiprocessor systems’\n これでもダメだった．\n僕の理解 Concurrent 並行とは「複数のタスクが，論理的に，同時に処理されているように見えること」\n具体的には，CPUが1コアの時代に，「一つのパソコンでブラウジングしながらメールが読める理由」を説明するのが「CPUがタスクをConcurrentに処理しているから」で，これが僕の「並行」の理解．\n細切れにたくさんの仕事をちょっとずつ進めて，全体として複数のタスクが同時に処理されているように見えるってだけで，実際に複数のタスクが同時に処理されているわけではない．\n「一人でいろんな仕事を同時に進めている様」が並行．\nParallel 並列とは「複数のタスクが，物理的に，同時に処理されていること」\n具体的にはマルチコアのプロセッサが，搭載している複数のプロセッサをちゃんと使い切って演算をしている様は，並列という言葉で形容できる．\n「複数人が同時に，それぞれの仕事を進めている様」が並列．\nちなみに，「並列であれば常に並行である」という主張もあるらしい．「複数人が同時に，それぞれの仕事を進めている様」は側から見ると「いろんな仕事を同時に進めている」ように見えるから，確かにそうかもしれない．\nRob Pike先生によれば\u0026hellip;  Concurrency is about dealing with lots of things at once.\nParallelism is about doing lots of things at once.\nNot the same, but related.\nConcurrency is about structure, parallelism is about execution.\nConcurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.\n なるほど\nref  Concurrency is not Parallelism  ","date":1572506814,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572506814,"objectID":"c7e7cdbec1dbcce85a754deadfc1e74c","permalink":"/post/concurrent-vs-parallel/","publishdate":"2019-10-31T16:26:54+09:00","relpermalink":"/post/concurrent-vs-parallel/","section":"post","summary":"似てるようで違うのでちゃんと区別したい","tags":["Concurrent","Parallel","Terminology"],"title":"Concurrent v.s. Parallel","type":"post"},{"authors":[],"categories":[],"content":"0. これは何 僕が最近研究している「並行グラフ処理系」に関連して，僕自身のテーマにおいて非常に参考になった論文であるParallelizing Sequential Graph Computations1について，その詳細をまとめました．なお，以下の資料の内容は大学のカリキュラムの一環として行われた発表会で用いたハンドアウトです．\n1. 背景 一台のメモリに載り切らないほど巨大なグラフに対する計算需要の高まりを受け，グラフ計算を並列実行するPregel2やGraphLab3をはじめとする処理系が考案された．これらは「各頂点を一台の計算機と見なし，頂点ごとに処理を実行し，頂点間でコミュニケーションをとりながら状態を更新し，その収束を以って全体の解とする」ようなThink Like A Vertex(TLAV)という計算モデルを実装している．\nしかし，既存のグラフアルゴリズムは並列実行されることを前提としていないため，これらの処理系を利用するためには実行したいアルゴリズムをTLAVに書き下す必要があるが，これは容易な作業ではない．グラフアルゴリズムはTLAVの登場以前から研究されていて，問題を解決する最適なアルゴリズムが既に存在しているにも関わらず，TLAVな処理系ではアルゴリズムの変換が伴うため，敷居が十分に下がったとは言えない．\nそこで，既存のグラフアルゴリズムのロジックをそのまま用いながらも，並列実行することができるような処理系 $GRAPE$ を提案する． $GRAPE$ では，計算モデルとして，既存の分散グラフ処理系が採用するTLAVではなく，Partial evaluation \u0026amp; Incremental Computationモデル(以下$GRAPE$モデル)を採用し，既存のアルゴリズムのロジックを変更することなく並列化させる．同時に，$GRAPE$モデルはTLAVと比較してコミュニケーションコストを少なく抑えることができることからより効率的な計算の実行が可能となる．\n2. 関連研究 分散グラフ処理の計算モデルの変遷と$GRAPE$モデルの位置付けを述べる．分散グラフ処理を実現する計算モデルとして以下の二つがよく用いられる．\nThink Like A Vertex 最初に提案された計算モデル．PregelやGiraph4，GraphLab5に実装されている．頂点ごとに処理を実行し，頂点間でコミュニケーションをとりながら状態を更新．全頂点の状態の収束を以って全体の解とする．\nThink Like A Graph (or Block Centric) TLAVを高速化しようとする研究の中で提案されたモデル．$n$個の頂点をまとめて扱うことでコミュニケーションコストを抑え，実行効率の向上を図る．Blogel6で実装されている．\nTLAVとBlock Centricモデルおよび$GRAPE$モデルを，処理単位の粒度，コミュニケーションコストの大小，プログラミングのしやすさという三つの観点から整理すると下表のようになる．\n   表1. 分散グラフ計算モデルの比較   3. Partial evaluation \u0026amp; Incremental computation $GRAPE$では，Partial evaluation \u0026amp; Incremental computationという計算モデルを採用している．これは，最初に部分グラフに対して実行したい処理を行って部分解を求め，その部分解の更新を繰り返していくことで全体の解を求めるというモデルである．\nPartial evaluation コンパイラによるプログラム最適化の文脈で登場し，XML文章中の要素を指定するXPathを分散環境下で評価する研究などでも取り上げられている7．\nIncremental computation 巨大な動的グラフ$G$に対するクエリ$Q$の応答速度を向上させる技術．グラフの変化$\\Delta G$から$Q(G \\oplus \\Delta G) = Q(G) \\oplus \\Delta O$を満たすようなクエリ出力の差分$\\Delta O$を求めることで，グラフ全体を用いて再計算することなく，変化後のグラフに対するクエリ結果を求める8．\n例えば，図1のような5ノードからなるグラフ$G$を三つの部分グラフ$F_1$，$F_2$，$F_3$に分割する．部分グラフは，それを構成するノードとそのノードを始点とするエッジの終点も含めるものとして与える．例えば，部分グラフ$F_1$は図2となる．ここで，グラフ$G$に対してノード$1$を始点とする単一始点最短経路問題(SSSP)を考える．$GRAPE$ではまず，部分グラフ$F_1$に対してダイクストラ法を用いて計算する．この結果は$G$全体に対するSSSPの解ではないが，この結果は全体の解のたたき台となっている．この「部分グラフ$F_1$に対するダイクストラ法の適用」がPartial evaluationである．\n    図1. 全体グラフ      図2. 部分グラフ $F_1$   $F_1$にダイクストラ法を適用することで表2を得る．ここで，ノード$4$および$5$のコストが計算されていることに注目する．これは，$F_1$のpartial evaluationの結果から，$F_3$の状態が変化した(表3におけるノード$4$および$5$の初期状態からの変化)ということであり，この変化を元に$F_3$に対してダイクストラ法を適用することで全体解に収束していく．これが，$GRAPE$のIncremental computationである．\n    表2. 部分グラフ$F_1$に対するPartial evaluation      表3. 部分グラフ$F_3$に対するIncremental computation   4. $GRAPE$ Partial evaluation \u0026amp; Incremental computationを図3のように組み上げることで処理系$GRAPE$を実現する．\n   図3. $GRAPE$   $GRAPE$の利用者は実行したい処理を，$\\sf PEval$(Partial evaluation相当)，$\\sf IncEval$(Incremental computation)相当，部分解をまとめる$\\sf Assemble$という三つのプログラムとして$GRAPE$に与える．$GRAPE$は一つの$\\tt coordinator$と複数の$\\tt worker$で構成され，$\\tt coordinator$は部分グラフ間の接続関係やどの$\\tt worker$がどの部分グラフを担当するかを管理している．$\\tt worker$は各自が担当する部分グラフに$\\sf PEval$や$\\sf IncEval$を適用する．\n$GRAPE$での演算は三つのフェーズから成る．まず$\\tt coordinator$がクエリの実行を受け付け，$\\tt worker$が各自が担当している部分グラフに対して$\\sf PEval$を実行する．次に, 各$\\tt worker$が部分グラフの状態変化を$\\tt coordinator$に通知する．$\\tt coordinator$は部分グラフ同士の接続関係を考慮し，対応する$\\tt worker$に変化を伝達する．知らせを受けた$\\tt worker$は，状態変化に基づく$\\sf IncEval$を実行し自分の担当している部分グラフの状態を更新する．$\\sf IncEval$は更新が発生しなくなるまで繰り返される．$\\sf IncEval$が収束すると，$\\tt coordinator$は各$\\tt worker$から部分解を回収し，最終的な出力を得る．\n5. $GRAPE$のアドバンテージ $GRAPE$は処理効率と$GRAPE$モデルの表現力において，既存の処理系に対してアドバンテージがある．$GRAPE$では部分グラフ間の状態変化をやり取りするコストのみで済むため，TLAVと比較して大幅にコミュニケーションコストが抑えられる．これによって，TLAVよりも効率的な処理が実行できる．さらに$GRAPE$で実行されるアルゴリズムのロジックは既存のものと変わらないため，既存のグラフ最適化技法を適用することができ，さらなる高速化も見込むことができる．加えて，$\\sf MapReduce$など他の分散計算モデルを$GRAPE$上に表現することも可能である．例えば$\\sf IncEval$でやり取りする情報を\u0026lt;key: value\u0026gt;として$\\sf PEval$と偶数回目の$\\sf IncEval$を$\\sf Map$に，奇数回目の$\\sf IncEval$を$\\sf Reduce$とすれば$\\sf MapReduce$を表現できる．\n6. 評価 $GRAPE$モデルがTLAVよりも\n 処理時間 コミュニケーションコスト グラフの規模に対するスケーラビリティ  の三点において，TLAVとの性能を比較し$GRAPE$モデルの優位性を検証した．プロセッサの数を64から192まで変化させながら，liveJournal9など複数の実世界グラフに対して単一始点最小経路問題をGiraph，GraphLab，Blogel，$GRAPE$で実行した結果を図4に示す．$GRAPE$はGiraph，GraphLab，Blogeと比べて484，36，15倍高速に処理を実行し，$\\tt worker$間でやり取りされるデータ量を0.07%，0.12%，0.7%に抑えられている．\nグラフの規模に対するスケーラビリティを，入力グラフを5Mノード50Mエッジから25Mノード250Mエッジまで変化させながら実行時間とコミュニケーションコストを計測した．その結果を図5の左二図に示す．グラフ規模に対して十分にスケールしていることがわかる．\n図5の右端図から，${GRAPE}$では，並列実行に伴うオーバーヘッドを考慮してもなお，既存のアルゴリズムに対する高速化技法の効果が得られることがわかる．\n    表4. 処理系ごとの実行時間とコミュニケーションコスト      表5. ${GRAPE}$のスケーラビリティーとグラフレベル最適化の効果   7. 結論 Partial evaluation \u0026amp; Incremental computationという計算モデルはグラフに対しても有効であり，この計算モデルを用いることで 既存のグラフアルゴリズムのロジックをほぼ変更することなく並列化を実現でき，分散グラフ処理系を利用する敷居を下げられる．そこでPartial evaluation \u0026amp; Incremental computationを実装する処理系$GRAPE$を提案する．Partial evaluationに相当する$\\sf PEval$とIncremental computationに相当する$\\sf IncEval$，部分解を集める$\\sf Assemble$を定義することで既存のグラフアルゴリズムの並列化を実現する．\n    Wenfei Fan, Wenyuan Yu, Jingbo Xu, Jingren Zhou, Xiaojian Luo, Qiang Yin, Ping Lu, Yang Cao, and Ruiqi Xu. 2018. Parallelizing Sequential Graph Computations. ACM Trans. Database Syst. 43, 4, Article 18 (December 2018), 39 pages. DOI: https://doi.org/10.1145/3282488 ^ Grzegorz Malewicz, Matthew H. Austern, Aart J.C Bik, JamesC. Dehnert, Ilan Horn, Naty Leiser, and Grzegorz Czajkowski.2010. Pregel: a system for large-scale graph processing. In Pro-ceedings of the 2010 ACM SIGMOD International Conferenceon Management of data (SIGMOD ’10). ACM, New York, NY,USA, 135-146. ^ Yucheng Low, Danny Bickson, Joseph Gonzalez, CarlosGuestrin, Aapo Kyrola, and Joseph M. Hellerstein. 2012. Dis-tributed GraphLab: a framework for machine learning and datamining in the cloud. Proc. VLDB Endow. 5, 8 (April 2012),716-727. ^ Giraph. http://giraph.apache.org/ ^ Yucheng Low, Danny Bickson, Joseph Gonzalez, CarlosGuestrin, Aapo Kyrola, and Joseph M. Hellerstein. 2012. Dis-tributed GraphLab: a framework for machine learning and datamining in the cloud. Proc. VLDB Endow. 5, 8 (April 2012),716-727. ^ Da Yan, James Cheng, Yi Lu, and Wilfred Ng. 2014. Blogel:a block-centric framework for distributed computation on real-world graphs. Proc. VLDB Endow. 7, 14 (October 2014), 1981-1992. ^ Peter Buneman, Gao Cong, Wenfei Fan, and Anastasios Ke-mentsietsidis. 2006. Using partial evaluation in distributedquery evaluation. In Proceedings of the 32nd international con-ference on Very large data bases (VLDB ’06), UmeshwarDayal, Khu-Yong Whang, David Lomet, Gustavo Alonso, GuyLohman, Martin Kersten, Sang K. Cha, and Young-Kuk Kim(Eds.). VLDB Endowment 211-222 ^ Wenfei Fan, Chunming Hu, and Chao Tian. 2017. Incremen-tal Graph Computations: Doable and Undoable. In Proceedingsof the 2017 ACM International Conference on Management ofData (SIGMOD ’17). ACM, New York, NY, USA, 155-169. ^ Snap. http://snap.stanford.edu/data/index.html ^   ","date":1572360869,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572360869,"objectID":"968af61da1967f4fa2f595bb94735e9d","permalink":"/post/parallelizing-sequential-graph-computations/","publishdate":"2019-10-29T23:54:29+09:00","relpermalink":"/post/parallelizing-sequential-graph-computations/","section":"post","summary":"僕が最近研究している「並行グラフ処理系」に関連して，僕自身のテーマにおいて非常に参考になった論文であるParallelizing Sequential Graph Computationsについて，その詳細をまとめました．","tags":["Parallel Graph Computation","Graph","Parallel Computation","GRAPE","Distributed Graph Processing"],"title":"Parallelizing Sequential Graph Computations","type":"post"},{"authors":[],"categories":[],"content":" ある人によれば\u0026hellip;  Simulation = For analysis and study\nEmulation = For usage as a substitute\nA simulator is an environment which models but an emulator is one that replicates the usage as on the original device or system.\nSimulator mimics the activity of something that it is simulating. It \u0026ldquo;appears\u0026rdquo; (a lot can go with this \u0026ldquo;appears\u0026rdquo;, depending on the context) to be the same as the thing being simulated. For example the flight simulator \u0026ldquo;appears\u0026rdquo; to be a real flight to the user, although it does not transport you from one place to another.\nEmulator, on the other hand, actually \u0026ldquo;does\u0026rdquo; what the thing being emulated does, and in doing so it too \u0026ldquo;appears to be doing the same thing\u0026rdquo;. An emulator may use different set of protocols for mimicking the thing being emulated, but the result/outcome is always the same as the original object. For example, EMU8086 emulates the 8086 microprocessor on your computer, which obviously is not running on 8086 (= different protocols), but the output it gives is what a real 8086 would give.\n また別の人によれば\u0026hellip;   Simulator is broader than Emulator\n Simulator tends to imitate/model more global processes/things in general with ability to narrow the imitation down (e.g. capacitor simulator with presets representing some known models)\n Emulator tends to imitate certain hardware devices with certain specification, known characteristics and properties (e.g. SNES emulator, Intel 8087 or Roland TB-303)\n   語源を辿ると\u0026hellip;   emulate is \u0026ldquo;to be equal\u0026rdquo; (looks like more aggressive and straightforward - rivalry) simulate is \u0026ldquo;to be similar\u0026rdquo; (looks like more sly and tricky - imitation)   日本語だと\u0026hellip;  Emulation: （代替可能なレベルでの）模倣 Simulation: 模擬  かな？🤔\nReference  Simulator or Emulator? What is the difference?  ","date":1572359078,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572359078,"objectID":"705d566c5c9beb942ffe89b0794f72f7","permalink":"/post/simulator-vs-emulator/","publishdate":"2019-10-29T23:24:38+09:00","relpermalink":"/post/simulator-vs-emulator/","section":"post","summary":"似て非なるもの","tags":["Simulator","Emulator","Terminology"],"title":"Emulator v.s. Simulator","type":"post"},{"authors":[],"categories":[],"content":" GitHub上でのmerge GitHub上で行えるmergeには3種類あります．\n Create a merge commit Squash and merge Rebase and merge  これらは，「merge commitの有無」「merge commitのauthorが誰になるのか」などの点で微妙に異なります．\n   Command merge commitの有無 merge commitのauthor merge元のbranchのcommit log     Create a merge commit 有 merge先 残る   Squash and merge 有 merge元 残らない   Rebase and merge 無  残る    Create a merge commit 「Create a merge commit」では，git merge --no-ffでmergeすることになります．つまり，merge先に新たなcommitが作成され，そのcommitがmerge元のcommitを取り込みます．このとき作成されるmerge commitのauthorはmerge先のauthorとして記録されます．\nこの方法は\n 「何をmergeしたのか」がmerge commitという形で記録として残る merge元のbranchがそのまま残るので変更箇所を追いやすい merge後に，merge元のbranchを削除したとしても，このbranchのcommit logがmerge先に残る  という特徴があります．わかりやすい一方で，「merge commitのauthorがmerge元ではない」のが（個人的に）「その人の頑張りを讃えたいのになぁ」とか思っちゃったりしてちょっと申し訳ない気がするとかしないとか．\n   Create a merge commit   Squash and merge 「Squash and merge」では，git merge --squashでmergeすることになります．つまり，merge元のcommitを一つのcommitにまとめた上で，merge先にmerge commitとして先頭に追加されます．このときのmerge commitのauthorはmerge元のauthorとなります．\nこの方法は\n 「何をmergeしたのか」がmerge commitという形で記録として残る 複数のcommitをまとめて一つにできるのでmerge先のcommit logがわかりやすい  という特徴があります．一方で，一度commitをまとめてしまうと，「どの変更が誰によってどのcommitで行われたのか」という情報が失われてしまうことになります．他の人の複数のcommitを一つのcommitに押し込むことになるので，個人的には若干怖さがあります．\n   Squash and merge   Rebase and merge 「Rebase and merge」では，まずmerge元のブランチにあるcommit列に対してgit rebaseして，commit列が一列になったところでfast-forwardの形でmergeが実行されます．\nこの方法は\n mergeした結果，merge先のcommit logが一直線で見やすい merge commitが作成されない  という特徴があります．\n   Rebase and merge   Reference  About merge methods on GitHub  ","date":1572346258,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572346258,"objectID":"23d6b53e02b5322745a0e712092cb5bf","permalink":"/post/three-kinds-of-merge-on-github/","publishdate":"2019-10-29T19:50:58+09:00","relpermalink":"/post/three-kinds-of-merge-on-github/","section":"post","summary":"GitHub上で実行できる3種類のmergeについて「どのようなものなのか？」をまとめました．","tags":["GitHub","Git","Tips"],"title":"GitHub上でのmerge","type":"post"},{"authors":[],"categories":[],"content":" 暗号の基礎技術 暗号技術の中でも基礎となるもの．\n 暗号 鍵配送 ハッシュ関数 メッセージ認証コード デジタル署名 擬似乱数生成器  暗号 暗号とは，「正当な送信者と受信者以外に内容を秘匿する技術」のこと．送信者は平文に対して，なんらかの操作を施すことで，暗号文を生成する．この過程を暗号化という．一方で，受信者は暗号文に対してなんらかの操作を施すことで平文を得る．この過程を復号という．\n鍵配送 鍵配送とは，暗号化や復号に用いる鍵を安全に配送・共有するための技術や方式のこと．鍵は「第三者に知られないように」配送する必要があります．\nハッシュ関数 ハッシュ関数とは，任意長のビット列を入力として固定長のビット列を出力する関数のこと．同一の入力に対して同一の出力をする一方で，異なる入力に対して異なる出力となり，異なる入力に対して同一の出力にならないという性質が求められる．\nメッセージ認証コード メッセージ認証コードとは，「伝送路上を通ってきたデータが改ざんされていないこと」「データが期待した通信相手から送信されていること」を検証するための技術のこと．\nデジタル署名 デジタル署名とは，契約書における物理的なサインのデジタル版で，ユーザー認証とデータ認証を同時に実現する技術のこと．メッセージの改ざんを防ぎ，メッセージに対する署名は署名した本人でしか生成できないことから，後から署名者が署名した契約について否認することを防止することができる．\n擬似乱数生成器 真の乱数ではないにしても，暗号論的に安全とみなせる乱数列を生成するための技術のこと．\n","date":1572234048,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572234048,"objectID":"171b152bec97767e38aadfdd4c806b24","permalink":"/post/basic-cryptographic-technologies/","publishdate":"2019-10-28T12:40:48+09:00","relpermalink":"/post/basic-cryptographic-technologies/","section":"post","summary":"暗号技術学習メモ #1","tags":["Cryptography","Memo"],"title":"暗号の基礎技術","type":"post"},{"authors":[],"categories":[],"content":" 情報セキュリティの構成要素 「情報セキュリティ」の言葉の指し示す意味範囲はOECDの情報セキュリティガイドラインやISO/IEC TR133351として国際的に定義されている．\nISO/IEC TR13335にて情報セキュリティとは下記6要素のことを指すとされている．\n 機密性 Confidentiality 完全性 Integrity 可用性 Availability 責任追跡性 Accountability 真正性 Authenticity 信頼性 Reliability  機密性 Confidentiality  意味  意図した相手以外に情報が漏れないこと  リスク  盗聴や内部からの情報漏洩  対策  暗号技術   完全性 Integrity  意味  情報が正確であること  リスク  情報の改ざん，ノイズによるビット反転・ビットの欠落  対策  誤り訂正符号，ハッシュ関数，メッセージ認証コード，デジタル署名   可用性 Availability  意味  ある情報にアクセスすることが許されている主体が，任意の時点で情報にアクセスすることができること  リスク  システムへの過負荷，災害，意図しないロック  対策  システムの多重化，クラウド化，負荷分散   責任追跡性 Accountability  意味  ユーザやシステムの振る舞いについて説明が可能であること  リスク  ログの改ざん，否認  対策  ロギング，デジタル署名（否認防止）   真正性 Authenticity  意味  観測されるユーザやシステムの振る舞いが，その主体によるものであること（なりすましではない）  リスク  なりすまし  対策  認証，デジタル署名（なりすまし防止）   信頼性 Reliability  意味  システムが一貫して動作すること  リスク  盗聴や内部からの情報漏洩  対策  システムの多重化，負荷の監視    正確には企業のセキュリティリスクを査定する際のガイドラインを定めたものになっている．通称GMITS（Guidelines for the Management for IT Security） ^   ","date":1572231267,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572231267,"objectID":"856dc76386ac6865a6fbad2e2fc6b522","permalink":"/post/six-elements-of-infomation-security/","publishdate":"2019-10-28T11:54:27+09:00","relpermalink":"/post/six-elements-of-infomation-security/","section":"post","summary":"暗号技術学習メモ #0","tags":["Security","Memo"],"title":"情報セキュリティの構成要素","type":"post"},{"authors":[],"categories":[],"content":" ありがちな会話 「Web Application Frameworkと言ったら，やっぱりRuby on Railsだよね！」\n「Webのフロント開発ではjQueryってライブラリがあってだな\u0026hellip;」\n「最近だと，FacebookがJavascriptのフレームワークとしてReactを発表してるよね」\n「ReactよりAngular JSの方がいいよ」\nWeb系の技術の話では，たくさんのFrameworkだのLibraryだのが提案されて使用されていると思います．僕なんかも初めて聞くものがあれば，すぐにググってその正体を知ろうとするのですが，どれもこれも「これは便利なWeb Frameworkです」ぐらいしか教えてくれません．Frameworkの正体って一体何なのでしょうか．気になったので調べてみました．\nLibrary v.s. Framework Library Libraryは，コードの再利用を目的とした「便利な関数やクラスの（ただの）コレクション」のようなものです．Libraryに含まれる関数やクラスは，ある特定の処理を達成するロジックを含んでいて，開発者がそれらを利用することで開発を進めていくことになります．例えばグラフアルゴリズムのライブラリなら，Dijkstra法とかBellman-Ford法を実装した関数が含まれていて，開発者がその関数を利用することでアプリケーションを開発します．アプリケーションの開発者が書いているロジックにライブラリの関数が利用されるので，アプリケーションの制御は開発者側にあります．\nLibraryを用いることで，他の人の仕事の恩恵に与りながら開発を進めることができます．これはとても嬉しいことです．開発の速度が上がります．\n要するに「Libraryのコードを開発者が利用する」のがLibraryです．\nFramework Frameworkは， (初期化から実際の処理，終了といった) アプリケーションの制御は 全てFramework側にあります ．アプリケーションを開発者は，Frameworkが要求するロジックを部品としてFrameworkに提供することになるわけです．Frameworkはアプリケーションの骨格を定義しているともいるかもしれません．外枠だけ定義しているのです．このFrameworkの持つ性質は，ソフトウェア工学的には「制御の反転 IoC (Inversion of Control)」と呼ばれています．\nFrameworkを用いることで，アプリケーション開発者は設計についてあれやこれや悩む必要がなくなります．Frameworkの要求に従っていれば，それなりの品質のシステムが勝手に出来上がることになるからです．また，Frameworkに則ってアプリケーションを開発していくと，コードに一貫性が生まれます．これはコードに可読性を与え，メンテナンスがしやすくなります．\n一方で，Frameworkは「制約の集合」でもあります．アプリケーションの全体としての制御が開発者の自由にできないわけですから，Frameworkを導入するならばFrameworkの課すルールを理解する必要があります．ルールを理解するのには時間がかかるものですし，Frameworkのルールに窮屈さを感じることもあるかもしれません．小規模なその場限りの開発現場などでは，この制約がFrameworkのメリットを上回ることがあるので，Frameworkを導入しないこともあるでしょう．\n要するに「Frameworkが開発者のコードを利用する」のがFrameworkです．\n   LibraryとFrameworkとあなた   参考  ソフトウエアのフレームワークとはなにか (日経XTECH) フレームワークとライブラリの違い (Qiita) The Difference Between a Framework and a Library (freeCodeCamp) What is the difference between a framework and a library? (stackoverflow)  ","date":1572011115,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1572011115,"objectID":"e54cb1b7589f8c07b1423f581d1a62ba","permalink":"/post/what-is-the-difference-between-library-and-framework/","publishdate":"2019-10-25T22:45:15+09:00","relpermalink":"/post/what-is-the-difference-between-library-and-framework/","section":"post","summary":"ちゃんと説明できますか？","tags":["Framework","Library"],"title":"FramworkとLibraryの違い","type":"post"},{"authors":[],"categories":[],"content":" flagパッケージ Golangでは，標準パッケージとしてコマンドライン引数を扱うflagパッケージが付属しています．「痒い所に手が届く」とはこのことですね．\nフラグの立っていないコマンドライン引数の取得 Parse()の後にArgs()で[]stringとして取得できます．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { flag.Parse() args := flag.Args() fmt.Println(args) }  $ go run with-no-flag0.go a b c [a b c] $ go run with-no-flag0.go 1 2 3 [1 2 3]  $n$番目の要素のみを取り出したい場合はArg(n)でstringとして取得できます．$n$番目の要素が存在しない場合は\u0026quot;\u0026quot;が返ってくるようです．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { flag.Parse() fmt.Println(flag.Arg(0), flag.Arg(1)) }  $ go run with-no-flag1.go hoge fuga hoge fuga $ go run with-no-flag1.go 1 1  フラグの立っているコマンドライン引数の取得 型名()もしくは型名Var()で，フラグを定義したのち，Parse()でそれぞれの変数を取得できます．\nフラグの定義は「フラグ名」「デフォルト値」「ヘルプメッセージ」で行います．\n型名()の場合は，指定した型へのポインタが返ってきます．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { var ( i = flag.Int(\u0026quot;int\u0026quot;, 0, \u0026quot;int flag\u0026quot;) s = flag.String(\u0026quot;str\u0026quot;, \u0026quot;default\u0026quot;, \u0026quot;string flag\u0026quot;) b = flag.Bool(\u0026quot;bool\u0026quot;, false, \u0026quot;bool flag\u0026quot;) ) flag.Parse() fmt.Println(*i, *s, *b) }  $ go run with-flag0.go -int 2 -str hello -bool true 2 hello true $ go run with-flag0.go 0 default false  型名Var()の場合は，引数で渡した変数に代入されます．また，適切な値を渡さないと怒られます．ダメな理由も教えてくれるので怒られがいがあります．定義していないフラグも受け付けてくれません．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func main() { var ( d time.Duration f float64 ) flag.DurationVar(\u0026amp;d, \u0026quot;dur\u0026quot;, 1 * time.Second, \u0026quot;duration flag\u0026quot;) flag.Float64Var(\u0026amp;f, \u0026quot;float\u0026quot;, 0.1, \u0026quot;float flag\u0026quot;) flag.Parse() fmt.Println(d, f) }  $ go run with-flag1.go -dur 1h -float 2.3 1h0m0s 2.3 $ go run with-flag1.go -float str invalid value \u0026quot;str\u0026quot; for flag -float: strconv.ParseFloat: parsing \u0026quot;str\u0026quot;: invalid syntax Usage of /var/folders/.../with-flag1: -dur duration duration flag (default 1s) -float float float flag (default 0.1) exit status 2  フラグの書き方 フラグの書き方は次の2通りが可能です．\n -flag value -flag=value  ただし，Bool値を取得する場合はflag=valueを使った方がいいかもしれません．というのも， フラグの型がBool値かつ引数が続かない場合，フラグが立っただけでtrueとなるからです．\nつまり，フラグを立ててBool値を取得したい場合は-bool=true/-bool=falseとしなければならないということです．-bool falseではtrueとなってしまいます．また-bool false以降の引数が全てフラグ無しで渡された引数として評価されてしまいます．注意が必要ですね．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { var ( i = flag.Int(\u0026quot;int\u0026quot;, 0, \u0026quot;int flag\u0026quot;) s = flag.String(\u0026quot;str\u0026quot;, \u0026quot;default\u0026quot;, \u0026quot;string flag\u0026quot;) b = flag.Bool(\u0026quot;bool\u0026quot;, false, \u0026quot;bool flag\u0026quot;) ) flag.Parse() fmt.Println(*i, *s, *b) }  $ go run with-flag0.go -bool false -int 123 -str abc # falseを含むそれ以降が全て非フラグで渡されたコマンドライン引数として扱われる 0 default true $ go run with-flag0.go -bool=true -int 123 -str abc 123 abc true $ go run with-flag0.go -bool=false -int 123 -str abc 123 abc false  ちなみに-hでヘルプを表示してくれます．賢いですね．\n$ go run with-flag0.go -h Usage of /var/folders/.../with-flag0: -bool bool flag -int int int flag -str string string flag (default \u0026quot;default\u0026quot;) exit status 2  コマンドライン引数の個数を数える NArg()で非フラグなものを，NFlag()でフラグなものをカウントできます．\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { flag.Int(\u0026quot;int\u0026quot;, 0, \u0026quot;int flag\u0026quot;) flag.String(\u0026quot;str\u0026quot;, \u0026quot;default\u0026quot;, \u0026quot;string flag\u0026quot;) flag.Bool(\u0026quot;bool\u0026quot;, false, \u0026quot;bool flag\u0026quot;) flag.Parse() fmt.Println(\u0026quot;non flag:\u0026quot;, flag.NArg()) fmt.Println(\u0026quot;flag:\u0026quot;, flag.NFlag()) }  $ go run flag-test.go -int 1 -str foo -bool=true a b non flag: 2 flag: 3 $ go run flag-test.go -int 1 -str foo -bool true a b non flag: 3 flag: 3 $ go run flag-test.go -bool true -int 1 -str foo a b non flag: 7 flag: 1 $ go run flag-test.go a b c -bool=true -str foo non flag: 6 flag: 0 $ go run flag-test.go -bool=true -str foo a b c non flag: 3 flag: 2 $ go run flag-test.go a b c non flag: 3 flag: 0 $ go run flag-test.go -bool=true -str foo non flag: 0 flag: 2  ","date":1571997871,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1571997871,"objectID":"0bf003175f088b27d9d436b60a11ab98","permalink":"/post/handle-commandline-args-with-flag-package/","publishdate":"2019-10-25T19:04:31+09:00","relpermalink":"/post/handle-commandline-args-with-flag-package/","section":"post","summary":"flagパッケージでコマンドライン引数を賢く扱おう！","tags":["Golang","Tips"],"title":"🚩flagパッケージでコマンドライン引数を扱う","type":"post"},{"authors":[],"categories":[],"content":" はじめに 最近はもっぱら卒論の実装ばかりやっています，zakです．\nプログラム書くのって難しいですよね．僕にとってはとても難しいので，わからないことがあったらデキる人のブログを参考にさせていただいたりしています． そんな中で，自分もコードを書くことが増えてきて，そこで得た知識をなんらかの形で発信できないかなと思って，このブログを思いつきで始めました．\n採用技術 このブログはサイトジェネレータとしてHugo，ホスティングサービスとしてGitHub Pagesを採用しています．\nHugoはGolangで記述されたオープンソースの静的サイトジェネレーターです．設定をtomlで書いて，記事をMarkdownで書いて，それをHugoがHTMLその他ファイルに爆速でしたためてくれます．真面目にウェブサイトを作ろうとすると，「書きにくいHTMLで文章を書いて，CSSで見栄えを整えて」という感じで作っていくことになります．HTMLってあんまり洗練されていなくて人間にとっては読みずらいですよね．一方でMarkdownは文法が簡単なので，箇条書きでメモってるぐらいの感覚で構造を持った文章が書けてしまいます．Hugoを使うことで，サイト作成者はMarkdownというわかりやすい文法で記事を書くことができ，本来の仕事に専念できるわけです．\nHugoのいいところはそれだけではありません．Hugoはその便利さから，多くのユーザーから愛されていて，そのユーザーらがそれぞれ美しいデザインテーマを公開してくれています．どれもセンスが良く，機能面でも充実しています．このテーマはオープンソースで公開されているので，カスタマイズも簡単です．そこらへんのブログサービスを利用すると，テーマがどれも陳腐で不満ですよね．\n今回はMarkdownで記事が執筆できるところとHugoで用いることができるAcademicというテーマが気に入ったので，Hugoを使うことにしました．\nGitHub Pagesは，GitHubが提供している静的サイトのホスティングサービスです．GitHubのアカウントさえあれば，誰でも静的なサイトを公開することができます．何より無料なので，これを使わない手はありません．サイトのソースコードをGitHubで管理しつつ公開もできちゃうなんて，GitHubは太っ腹ですね．\nGitHub Pagesの他にもホスティングサービスはありますが，ソースコード管理と一緒にホスティングできるところが便利だと思ったので採用しました．\n 気が向いたら，もうちょっと追記します 🙇\n ","date":1571991698,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1571991698,"objectID":"7c7a7a98c108a8c69ca3bde923f50c92","permalink":"/post/about-this-site/","publishdate":"2019-10-25T17:21:38+09:00","relpermalink":"/post/about-this-site/","section":"post","summary":"このブログの技術的なところをまとめてみました！まだ途中です :bow:","tags":["Hugo","GitHub","Golang"],"title":"HugoとGitHub Pagesでブログを作ってみた！","type":"post"},{"authors":[],"categories":[],"content":" ご挨拶 はじめまして．技術ブログ始めてみました．ぼちぼち投稿します 👍\n","date":1571990829,"expirydate":-62135596800,"kind":"page","lang":"ja","lastmod":1571990829,"objectID":"2247257f33c5eaa1cd0616bf37b07249","permalink":"/post/first-post/","publishdate":"2019-10-25T17:07:09+09:00","relpermalink":"/post/first-post/","section":"post","summary":"ブログを始めてみたのでお知らせです．","tags":[],"title":"🚀最初の投稿","type":"post"}]